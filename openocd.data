#----------------------------------------
# Purpose - Create some $BIT variables
#           Create $K and $M variables
#          and some bit field extraction variables.
# Creat helper variables ...
#    BIT0.. BIT31

for { set x 0  } { $x < 32 } { set x [expr $x + 1]} {
    set vn [format "BIT%d" $x]
    global $vn
    set $vn   [expr (1 << $x)]
}

# Create K bytes values
#    __1K ... to __2048K
for { set x 1  } { $x < 2048 } { set x [expr $x * 2]} {
    set vn [format "__%dK" $x]
    global $vn
    set $vn   [expr (1024 * $x)]
}

# Create M bytes values
#    __1M ... to __2048K
for { set x 1  } { $x < 2048 } { set x [expr $x * 2]} {
    set vn [format "__%dM" $x]
    global $vn
    set $vn [expr (1024 * 1024 * $x)]
}

proc create_mask { MSB LSB } {
    return [expr (((1 << ($MSB - $LSB + 1))-1) << $LSB)]
}

# Cut Bits $MSB to $LSB out of this value.
# Example: % format "0x%08x" [extract_bitfield 0x12345678 27 16]
# Result:  0x02340000

proc extract_bitfield { VALUE MSB LSB } {
    return [expr [create_mask $MSB $LSB] & $VALUE]
}


# Cut bits $MSB to $LSB out of this value
# and shift (normalize) them down to bit 0.
#
# Example: % format "0x%08x" [normalize_bitfield 0x12345678 27 16]
# Result:  0x00000234
#
proc normalize_bitfield { VALUE MSB LSB } {
    return [expr [extract_bitfield $VALUE $MSB $LSB ] >> $LSB]
}

proc show_normalize_bitfield { VALUE MSB LSB } {
    set m [create_mask $MSB $LSB]
    set mr [expr $VALUE & $m]
    set sr [expr $mr >> $LSB]
    echo [format "((0x%08x & 0x%08x) -> 0x%08x) >> %2d => (0x%x) %5d " $VALUE $m $mr $LSB $sr $sr]
   return $sr
}
# Product page:
# https://www.8devices.com/products/lima
#
# Location of JTAG pins:
# J2 GPIO0	JTAG TCK
# J2 GPIO1	JTAG TDI
# J2 GPIO2	JTAG TDO
# J2 GPIO3	JTAG TMS
# J2 RST	directly connected to RESET_L of the SoC and can be used as
#               JTAG SRST. Note: this pin will also reset the debug engine.
# J1 +3,3V	Can be use as JTAG Vref
# J1 or J2 GND	Can be used for JTAG GND
#
# This board is powered from mini USB connecter which is also used
# as USB to UART converted based on FTDI FT230XQ chip

source [find target/qualcomm_qca4531.cfg]

proc board_init { } {
	qca4531_ddr2_550_550_init
}

$_TARGETNAME configure -event reset-init {
	board_init
}

set ram_boot_address 0xa0000000
$_TARGETNAME configure -work-area-phys 0xa1FFE000 -work-area-size 0x1000

flash bank flash0 ath79 0xbf000000 0 0 0 $_TARGETNAME cs0
# board config file for AcTux3/XBA IXP42x board
# Date:   2010-12-16
# Author: Michael Schwingen <michael@schwingen.org>

reset_config trst_and_srst separate

adapter srst delay 100
jtag_ntrst_delay 100

source [find target/ixp42x.cfg]

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x10000 -work-area-backup 0

$_TARGETNAME configure -event reset-init { init_actux3 }

proc init_actux3 { } {
    ##########################################################################
    # setup expansion bus CS
    ##########################################################################
    mww 0xc4000000  0xbd113842  ;#CS0  : Flash, write enabled @0x50000000
    mww 0xc4000004  0x94d10013  ;#CS1
    mww 0xc4000008  0x95960003  ;#CS2
    mww 0xc400000c  0x00000000  ;#CS3
    mww 0xc4000010  0x80900003  ;#CS4
    mww 0xc4000014  0x9d520003  ;#CS5
    mww 0xc4000018  0x81860001  ;#CS6
    mww 0xc400001c  0x80900003  ;#CS7

    ixp42x_init_sdram $::IXP42x_SDRAM_16MB_4Mx16_1BANK 2100 3

    #mww 0xc4000020  0xffffee ;# CFG0: remove expansion bus boot flash mirror at 0x00000000

    ixp42x_set_bigendian

    flash probe 0
}

proc flash_boot { {FILE "/tftpboot/actux3/u-boot.bin"} } {
    echo "writing bootloader: $FILE"
    flash write_image erase $FILE 0x50000000 bin
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x50000000 0x400000 2 2 $_TARGETNAME

init
reset init

# setup to debug u-boot in flash
proc uboot_debug {} {
    gdb_breakpoint_override hard
    xscale vector_catch 0xFF

    xscale vector_table low  1 0xe59ff018
    xscale vector_table low  2 0xe59ff018
    xscale vector_table low  3 0xe59ff018
    xscale vector_table low  4 0xe59ff018
    xscale vector_table low  5 0xe59ff018
    xscale vector_table low  6 0xe59ff018
    xscale vector_table low  7 0xe59ff018

    xscale vector_table high 1 0xe59ff018
    xscale vector_table high 2 0xe59ff018
    xscale vector_table high 3 0xe59ff018
    xscale vector_table high 4 0xe59ff018
    xscale vector_table high 5 0xe59ff018
    xscale vector_table high 6 0xe59ff018
    xscale vector_table high 7 0xe59ff018
}
#
# Adapteva Parallella-I board (via Porcupine-1 adapter board)
#

reset_config srst_only

source [find target/zynq_7000.cfg]
#
# Analog Devices ADSP-SC584-EZBRD evaluation board
#
# Evaluation boards by Analog Devices (and designs derived from them) use a
# non-standard 10-pin 0.05" ARM Cortex Debug Connector.  In this bastardized
# implementation, pin 9 (GND or GNDDetect) has been usurped with JTAG /TRST.
#
# As a result, a standards-compliant debug pod will force /TRST active,
# putting the processor's debug interface into reset and preventing usage.
#
# A connector adapter must be employed on these boards to isolate or remap
# /TRST so that it is only asserted when intended.

# Analog expects users to use their proprietary ICE-1000 / ICE-2000 with all
# ADSP-SC58x designs, but this is an ARM target (and subject to the
# qualifications above) many ARM debug pods should be compatible.

#source [find interface/cmsis-dap.cfg]
source [find interface/jlink.cfg]

# Analog's silicon supports SWD and JTAG, but their proprietary ICE is limited
# to JTAG.  (This is presumably why their connector pinout was modified.)
# SWD is chosen here, as it is more efficient and doesn't require /TRST.

transport select swd

# chosen speed is 'safe' choice, but your adapter may be capable of more
adapter speed 400

source [find target/adsp-sc58x.cfg]
source [find target/alphascale_asm9260t.cfg]

reset_config trst_and_srst

$_TARGETNAME configure -event reset-init {
	echo "Configure clock"
	# Enable SRAM clk
	mww 0x80040024 0x4
	# Enable IRQ clk
	mww 0x80040034 0x100
	# Enable DMA0,1 clk
	mww 0x80040024 0x600
	# Make sysre syspll is enabled
	mww 0x80040238 0x750
	#CPU = PLLCLK/2
	mww 0x8004017C 0x2
	#SYSAHBCLK = CPUCLK/2
	mww 0x80040180 0x2
	# Set PLL freq to 480MHz
	mww 0x80040100 480
	# normally we shoul waiting here until we get 0x1 (0x80040104)&0x1)==0x0)
	sleep 100

	# select PLL as main source
	mww 0x80040120 0x1
	# disable and enable main clk to update changes?
	mww 0x80040124 0x0
	mww 0x80040124 0x1

	echo "Configure memory"
	#enable EMI CLK
	mww 0x80040024 0x40

	# configure memory controller for internal SRAM
	mww 0x80700000 0x1188
	# change default emi clk delay
	mww 0x8004034C 0xA0503
	# make sure chip_select_register2_low has correct value (why?)
	mww 0x8070001c 0x20000000
	# set type to sdram and size to 32MB
	mww 0x8070005c 0xa
	# configure internal SDRAM timing
	mww 0x80700004 0x024996d9
	# configure Static Memory timing
	mww 0x80700094 0x00542b4f

	echo "Configure uart4"
	# enable pinctrl clk
	mww 0x80040024 0x2000000
	# mux GPIO3_0 and GPIO3_1 to UART4
	mww 0x80044060 0x2
	mww 0x80044064 0x2
	# configure UART4CLKDIV
	mww 0x800401a8 0x1
	# enable uart4 clk
	mww 0x80040024 0x8000
	# clear softrst and clkgate on uart4
	mww 0x80010008 0xC0000000
	# set bandrate 115200 12M
	mww 0x80010030 0x00062070
	# enable Rx&Tx
	mww 0x80010024 0x301
	# clear hw control
	mww 0x80010028 0xc000
}

$_TARGETNAME configure -work-area-phys 0x21ffe000 -work-area-virt 0xc1ffe000 -work-area-size 0x1000
$_TARGETNAME arm7_9 fast_memory_access enable
$_TARGETNAME arm7_9 dcc_downloads enable
#
# Cyclone V SocKit board
# http://www.altera.com/b/arrow-sockit.html
#
# Software support page:
# http://www.rocketboards.org/

# openocd does not currently support the on-board USB Blaster II.
# Install the JTAG header and use a USB Blaster instead.
adapter driver usb_blaster

source [find target/altera_fpgasoc.cfg]

# If the USB Blaster II were supported, these settings would be needed
#usb_blaster_vid_pid 0x6810 0x09fb
#usb_blaster_device_desc "USB-Blaster II"

adapter speed 100
# DANGER!!!! early work in progress for this PCB/target.
#
# The most basic operations work well enough that it is
# useful to have this in the repository for cooperation
# alpha testing purposes.
#
# TI AM3517
#
# http://focus.ti.com/docs/prod/folders/print/am3517.html
# http://processors.wiki.ti.com/index.php/Debug_Access_Port_(DAP)
# http://processors.wiki.ti.com/index.php?title=How_to_Find_the_Silicon_Revision_of_your_OMAP35x

set CHIPTYPE "am35x"
source [find target/amdm37x.cfg]

# The TI-14 JTAG connector does not have srst.  CPU reset is handled in
# hardware.
reset_config trst_only

# "amdm37x_dbginit am35x.cpu" needs to be run after init.
# This board is from ARM and has an samsung s3c45101x01 chip

source [find target/samsung_s3c4510.cfg]

#
# FIXME:
#  Add (A) sdram configuration
#  Add (B) flash cfi programing configuration
#
#
# Configuration script for ARM Musca-A development board
#
# For now we do not support Musca A flash programming using OpenOCD. However, a
# work area is configured for flash programming speed up.
#
# GDB considers all memory as RAM unless target supplies a memory map.
# OpenOCD will only send memory map if flash banks are configured. Otherwise,
# configure GDB after connection by issuing following commands:
# (gdb) mem 0x10200000 0x109FFFFF ro
# (gdb) mem 0x00200000 0x009FFFFF ro
# (gdb) set mem inaccessible-by-default off

# ARM Musca A board supports both JTAG and SWD transports.
source [find target/swj-dp.tcl]

# set a safe JTAG clock speed, can be overridden
adapter speed 1000

global _CHIPNAME
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME MUSCA_A
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x6ba00477
}

# Enable CPU1 debugging as a separate GDB target
set _ENABLE_CPU1 1

# Musca A1 has 32KB SRAM banks. Override default work-area-size to 8KB per CPU
set WORKAREASIZE_CPU0 0x2000
set WORKAREASIZE_CPU1 0x2000

# Set SRAM bank 1 to be used for work area. Override here if needed.
set WORKAREAADDR_CPU0 0x30008000
set WORKAREAADDR_CPU1 0x3000A000

source [find target/arm_corelink_sse200.cfg]
#
# Arty S7: Spartan7 25/50 FPGA Board for Makers and Hobbyists
#
# https://www.xilinx.com/products/boards-and-kits/1-pnziih.html
# https://store.digilentinc.com/arty-s7-spartan-7-fpga-board-for-makers-and-hobbyists/

source [find interface/ftdi/digilent-hs1.cfg]

# Xilinx Spartan7-25/50 FPGA (XC7S{25,50}-CSGA324)
source [find cpld/xilinx-xc7.cfg]
source [find cpld/jtagspi.cfg]

adapter speed 25000

# Usage:
#
# Load Bitstream into FPGA:
#    openocd -f board/arty_s7.cfg -c "init;\
#    pld load 0 bitstream.bit;\
#    shutdown"
#
# Write Bitstream to Flash:
#    openocd -f board/arty_s7.cfg -c "init;\
#    jtagspi_init 0 bscan_spi_xc7s??.bit;\
#    jtagspi_program bitstream.bin 0;\
#    xc7s_program xc7s.tap;\
#    shutdown"
#
# jtagspi flash proxies can be found at:
# https://github.com/quartiq/bscan_spi_bitstreams
#
# For the Spartan 50 variant, use
#  - https://github.com/quartiq/bscan_spi_bitstreams/raw/master/bscan_spi_xc7s50.bit
# For the Spartan 25 variant, use
#  - https://github.com/quartiq/bscan_spi_bitstreams/raw/master/bscan_spi_xc7s25.bit
#
# http://wikidevi.com/wiki/ASUS_RT-N16
#

set partition_list {
    CFE		{ Bootloader			0xbc000000 0x00040000 }
    firmware	{ "Kernel+rootfs"		0xbc040000 0x01fa0000 }
    nvram	{ "Config space"		0xbdfe0000 0x00020000 }
}

source [find target/bcm4718.cfg]

# External 32MB NOR Flash (Macronix MX29GL256EHTI2I-90Q)
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xbc000000 0x02000000 1 1 $_TARGETNAME x16_as_x8
#
# http://wikidevi.com/wiki/Asus_RT-N66U
#

echo "ATTENTION: you need to solder a 4.7-10k pullup resistor to pin 21 of flash IC"
echo "to enable JTAG, see http://wl500g.info/album.php?albumid=28&attachmentid=8991 ,"
echo "there is an unpopulated footprint near U8.\n"

set partition_list {
    CFE		{ Bootloader			0xbc000000 0x00040000 }
    firmware	{ "Kernel+rootfs"		0xbc040000 0x01fa0000 }
    nvram	{ "Config space"		0xbdfe0000 0x00020000 }
}

source [find target/bcm4706.cfg]

# External 32MB NOR Flash (Spansion S29GL256P10TF101
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xbc000000 0x02000000 2 2 $_TARGETNAME
# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4394
#
# use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst srst_pulls_trst

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME cap7
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x40700f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-start {
	# start off real slow when we're running off internal RC oscillator
	adapter speed 32
}

proc peek32 {address} {
	mem2array t 32 $address 1
	return $t(0)
}

# Wait for an expression to be true with a timeout
proc wait_state {expression} {
	for {set i 0} {$i < 1000} {set i [expr $i + 1]} {
		if {[uplevel 1 $expression] == 0} {
			return
		}
	}
	return -code 1 "Timed out"
}

# Use a global variable here to be able to tinker interactively with
# post reset jtag frequency.
global post_reset_khz
# Danger!!!! Even 16MHz kinda works with this target, but
# it needs to be as low as 2000kHz to be stable.
set post_reset_khz 2000

$_TARGETNAME configure -event reset-init {
	echo "Configuring master clock"
	# disable watchdog
	mww 0xfffffd44 0xff008000
	# enable user reset
	mww 0xfffffd08 0xa5000001
	# Enable main oscillator
	mww 0xFFFFFc20  0x00000f01
	wait_state {expr {([peek32 0xFFFFFC68] & 0x1) == 0}}

	# Set PLLA to 96MHz
	mww 0xFFFFFc28 0x20072801
	wait_state {expr {([peek32 0xFFFFFC68] & 0x2) == 0}}

	# Select prescaler
	mww 0xFFFFFC30 0x00000004
	wait_state {expr {([peek32 0xFFFFFC68] & 0x8) == 0}}

	# Select master clock to 48MHz
	mww 0xFFFFFC30 0x00000006
	wait_state {expr {([peek32 0xFFFFFC68] & 0x8) == 0}}

	echo "Master clock ok."

	# Now that we're up and running, crank up speed!
	global post_reset_khz ;	adapter speed $post_reset_khz

	echo "Configuring the SDRAM controller..."

	# Configure EBI Chip select for SDRAM
	mww 0xFFFFEF30 0x00000102

	# Enable clock on EBI PIOs
	mww 0xFFFFFC10 0x00000004

	# Configure PIO for SDRAM
	mww 0xFFFFF470 0xFFFF0000
	mww 0xFFFFF474 0x00000000
	mww 0xFFFFF404 0xFFFF0000

	# Configure SDRAMC CR
	mww 0xFFFFEA08 0xA63392F9

	# NOP command
	mww 0xFFFFEA00 0x1
	mww 0x20000000 0

	# Precharge All Banks command
	mww 0xFFFFEA00 0x2
	mww 0x20000000 0

	# Set 1st CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000010 0x00000001

	# Set 2nd CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000020 0x00000002

	# Set 3rd CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000030 0x00000003

	# Set 4th CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000040 0x00000004

	# Set 5th CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000050 0x00000005

	# Set 6th CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000060 0x00000006

	# Set 7th CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000070 0x00000007

	# Set 8th CBR
	mww 0xFFFFEA00 0x00000004
	mww 0x20000080 0x00000008

	# Set LMR operation
	mww 0xFFFFEA00 0x00000003

	# Perform LMR burst=1, lat=2
	mww 0x20000020 0xCAFEDEDE

	# Set Refresh Timer
	mww 0xFFFFEA04 0x00000203

	# Set Normal mode
	mww 0xFFFFEA00 0x00000000
	mww 0x20000000 0x00000000

	#remap internal memory at address 0x0
	mww 0xffffef00 0x3

	echo "SDRAM configuration ok."
}

$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable

#set _FLASHNAME $_CHIPNAME.flash
#flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
#Script for AT91EB40a

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME at91eb40a
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1f0f0f0f
}


#Atmel ties SRST & TRST together, at which point it makes
#no sense to use TRST, but use TMS instead.
#
#The annoying thing with tying SRST & TRST together is that
#there is no way to halt the CPU *before and during* the
#SRST reset, which means that the CPU will run a number
#of cycles before it can be halted(as much as milliseconds).
reset_config srst_only srst_pulls_trst

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

#target configuration
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

# speed up memory downloads
arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

#flash driver
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x01000000 0x200000 2 2 $_TARGETNAME

# required for usable performance. Used for lots of
# other things than flash programming.
$_TARGETNAME configure -work-area-phys 0x00030000 -work-area-size 0x10000 -work-area-backup 0

$_TARGETNAME configure -event reset-init {
	echo "Running reset init script for AT91EB40A"
	# Reset script for AT91EB40a
	reg cpsr 0x000000D3
	mww 0xFFE00020 0x1
	mww 0xFFE00024 0x00000000
	mww 0xFFE00000 0x01002539
	mww 0xFFFFF124 0xFFFFFFFF
	mww 0xffff0010 0x100
	mww 0xffff0034 0x100
}

# This target is pretty snappy...
adapter speed 16000
#
# This is for the "at91rm9200-DK" (not the EK) eval board.
#
# The two are probably very simular.... I have DK...
#
# It has atmel at91rm9200 chip.
source [find target/at91rm9200.cfg]

reset_config trst_and_srst

$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { at91rm9200_dk_init }

#flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x00200000 2 2 $_TARGETNAME


proc at91rm9200_dk_init { } {
    # Try to run at 1khz... Yea, that slow!
    # Chip is really running @ 32khz
    adapter speed 8

    mww 0xfffffc64 0xffffffff
    ##  disable all clocks but system clock
    mww 0xfffffc04 0xfffffffe
    ##  disable all clocks to pioa and piob
    mww 0xfffffc14 0xffffffc3
    ##  master clock = slow cpu = slow
    ##  (means the CPU is running at 32khz!)
    mww 0xfffffc30 0
    ##  main osc enable
    mww 0xfffffc20 0x0000ff01
    ##  program pllA
    mww 0xfffffc28 0x20263e04
    ##  program pllB
    mww 0xfffffc2c 0x10483e0e
    ##  let pll settle... sleep 100msec
    sleep 100
    ##  switch to fast clock
    mww 0xfffffc30 0x202
    ## Sleep some - (go read)
    sleep 100

    #========================================
    # CPU now runs at 180mhz
    # SYS runs at 60mhz.
    adapter speed 40000
    #========================================


    ##  set memc for all memories
    mww 0xffffff60 0x02
    ##  program smc controller
    mww 0xffffff70 0x3284
    ##  init sdram
    mww 0xffffff98 0x7fffffd0
    ##  all banks precharge
    mww 0xffffff80 0x02
    ##  touch sdram chip to make it work
    mww 0x20000000 0
    ##  sdram controller mode register
    mww 0xffffff90 0x04
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    mww 0x20000000 0
    ##  sdram controller mode register
    ##  Refresh, etc....
    mww 0xffffff90 0x03
    mww 0x20000080 0
    mww 0xffffff94 0x1f4
    mww 0x20000080 0
    mww 0xffffff90 0x10
    mww 0x20000000 0
    mww 0xffffff00 0x01

}
#
# Copyright 2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
#
# under GPLv2 Only
#
# This is for the "at91rm9200-ek" eval board.
#
#
# It has atmel at91rm9200 chip.
source [find target/at91rm9200.cfg]

reset_config trst_and_srst

$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { at91rm9200_ek_init }

## flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME

# The chip may run @ 32khz, so set a really low JTAG speed
adapter speed 8

proc at91rm9200_ek_init { } {
	# Try to run at 1khz... Yea, that slow!
	# Chip is really running @ 32khz
	adapter speed 8

	mww 0xfffffc64 0xffffffff
	## disable all clocks but system clock
	mww 0xfffffc04 0xfffffffe
	## disable all clocks to pioa and piob
	mww 0xfffffc14 0xffffffc3
	## master clock = slow cpu = slow
	## (means the CPU is running at 32khz!)
	mww 0xfffffc30 0
	## main osc enable
	mww 0xfffffc20 0x0000ff01
	## MC_PUP
	mww 0xFFFFFF50 0x00000000
	## MC_PUER: Memory controller protection unit disable
	mww 0xFFFFFF54 0x00000000
	## EBI_CFGR
	mww 0xFFFFFF64 0x00000000
	## SMC2_CSR[0]: 16bit, 2 TDF, 4 WS
	mww 0xFFFFFF70 0x00003284

	## Init Clocks
	## CKGR_PLLAR
	mww 0xFFFFFC28 0x2000BF05
	## PLLAR: 179,712000 MHz for PCK
	mww 0xFFFFFC28 0x20263E04
	sleep 100
	## PMC_MCKR
	mww 0xFFFFFC30 0x00000100
	sleep 100
	## ;MCKR : PCK/3 = MCK Master Clock = 59,904000MHz from PLLA
	mww 0xFFFFFC30 0x00000202
	sleep 100

	#========================================
	# CPU now runs at 180mhz
	# SYS runs at 60mhz.
	adapter speed 40000
	#========================================

	## Init SDRAM
	## PIOC_ASR: Configure PIOC as peripheral (D16/D31)
	mww 0xFFFFF870 0xFFFF0000
	## PIOC_BSR:
	mww 0xFFFFF874 0x00000000
	## PIOC_PDR:
	mww 0xFFFFF804 0xFFFF0000
	## EBI_CSA : CS1=SDRAM
	mww 0xFFFFFF60 0x00000002
	## EBI_CFGR:
	mww 0xFFFFFF64 0x00000000
	## SDRC_CR :
	mww 0xFFFFFF98 0x2188c155
	## SDRC_MR : Precharge All
	mww 0xFFFFFF90 0x00000002
	## access SDRAM
	mww 0x20000000 0x00000000
	## SDRC_MR : Refresh
	mww 0xFFFFFF90 0x00000004
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
	## SDRC_MR : Load Mode Register
	mww 0xFFFFFF90 0x00000003
	## access SDRAM
	mww 0x20000080 0x00000000
	## SDRC_TR : Write refresh rate
	mww 0xFFFFFF94 0x000002E0
	## access SDRAM
	mww 0x20000000 0x00000000
	## SDRC_MR : Normal Mode
	mww 0xFFFFFF90 0x00000000
	## access SDRAM
	mww 0x20000000 0x00000000
}
################################################################################
# Atmel AT91SAM9261-EK eval board
################################################################################

source [find mem_helper.tcl]
source [find target/at91sam9261.cfg]
uplevel #0 [list source [find chip/atmel/at91/hardware.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9261.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9261_matrix.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9_init.cfg]]

# By default S1 is open and this means that NTRST is not connected.
# The reset_config in target/at91sam9261.cfg is overridden here.
# (or S1 must be populated with a 0 Ohm resistor)
reset_config srst_only

scan_chain
$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { at91sam9261ek_reset_init }
$_TARGETNAME configure -event reset-start { at91sam9_reset_start }

proc at91sam9261ek_reset_init { } {

	;# for ppla at 199 Mhz
	set config(master_pll_div)	15
	set config(master_pll_mul)	162

	;# for ppla at 239 Mhz
	;# set master_pll_div	1
	;# set master_pll_mul	13

	set val	[expr $::AT91_WDT_WDV]			;# Counter Value
	set val	[expr ($val | $::AT91_WDT_WDDIS)]	;# Watchdog Disable
	set val	[expr ($val | $::AT91_WDT_WDD)]		;# Delta Value
	set val	[expr ($val | $::AT91_WDT_WDDBGHLT)]	;# Debug Halt
	set val	[expr ($val | $::AT91_WDT_WDIDLEHLT)]	;# Idle Halt

	set config(wdt_mr_val) $val

	;# EBI_CSA, no pull-ups for D[15:0], CS1 SDRAM, CS3 NAND Flash
	set config(matrix_ebicsa_addr)	$::AT91_MATRIX_EBICSA
	set config(matrix_ebicsa_val) [expr ($::AT91_MATRIX_DBPUC | $::AT91_MATRIX_CS1A_SDRAMC)]

	;# SDRAMC_CR - Configuration register
	set val [expr $::AT91_SDRAMC_NC_9]
	set val [expr ($val | $::AT91_SDRAMC_NR_13)]
	set val [expr ($val | $::AT91_SDRAMC_NB_4)]
	set val [expr ($val | $::AT91_SDRAMC_CAS_3)]
	set val [expr ($val | $::AT91_SDRAMC_DBW_32)]
	set val [expr ($val | (2 <<  8))]		;# Write Recovery Delay
	set val [expr ($val | (7 << 12))]		;# Row Cycle Delay
	set val [expr ($val | (3 << 16))]		;# Row Precharge Delay
	set val [expr ($val | (2 << 20))]		;# Row to Column Delay
	set val [expr ($val | (5 << 24))]		;# Active to Precharge Delay
	set val [expr ($val | (8 << 28))]		;# Exit Self Refresh to Active Delay

	set config(sdram_cr_val) $val

	set config(sdram_tr_val) 0x13c

	set config(sdram_base) $::AT91_CHIPSELECT_1
	at91sam9_reset_init $config
}
################################################################################
# Atmel AT91SAM9263-EK eval board
################################################################################

source [find mem_helper.tcl]
source [find target/at91sam9263.cfg]
uplevel #0 [list source [find chip/atmel/at91/hardware.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9263.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9263_matrix.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91sam9_init.cfg]]

# By default S1 is open and this means that NTRST is not connected.
# The reset_config in target/at91sam9263.cfg is overridden here.
# (or S1 must be populated with a 0 Ohm resistor)
reset_config srst_only

scan_chain
$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { at91sam9263ek_reset_init }
$_TARGETNAME configure -event reset-start { at91sam9_reset_start }

proc at91sam9263ek_reset_init { } {

	set config(master_pll_div)	14
	set config(master_pll_mul)	171

	set val	[expr $::AT91_WDT_WDV]			;# Counter Value
	set val	[expr ($val | $::AT91_WDT_WDDIS)]	;# Watchdog Disable
	set val	[expr ($val | $::AT91_WDT_WDD)]		;# Delta Value
	set val	[expr ($val | $::AT91_WDT_WDDBGHLT)]	;# Debug Halt
	set val	[expr ($val | $::AT91_WDT_WDIDLEHLT)]	;# Idle Halt

	set config(wdt_mr_val) $val

	set config(sdram_piod) 1
	;# EBI_CSA, no pull-ups for D[15:0], CS1 SDRAM, CS3 NAND Flash
	set config(matrix_ebicsa_addr)	$::AT91_MATRIX_EBI0CSA

	set val	[expr $::AT91_MATRIX_EBI0_DBPUC]
	set val [expr ($val | $::AT91_MATRIX_EBI0_VDDIOMSEL_3_3V)]
	set val [expr ($val | $::AT91_MATRIX_EBI0_CS1A_SDRAMC)]
	set config(matrix_ebicsa_val) $val

	;# SDRAMC_CR - Configuration register
	set val [expr $::AT91_SDRAMC_NC_9]
	set val [expr ($val | $::AT91_SDRAMC_NR_13)]
	set val [expr ($val | $::AT91_SDRAMC_NB_4)]
	set val [expr ($val | $::AT91_SDRAMC_CAS_3)]
	set val [expr ($val | $::AT91_SDRAMC_DBW_32)]
	set val [expr ($val | (1 <<  8))]		;# Write Recovery Delay
	set val [expr ($val | (7 << 12))]		;# Row Cycle Delay
	set val [expr ($val | (2 << 16))]		;# Row Precharge Delay
	set val [expr ($val | (2 << 20))]		;# Row to Column Delay
	set val [expr ($val | (5 << 24))]		;# Active to Precharge Delay
	set val [expr ($val | (1 << 28))]		;# Exit Self Refresh to Active Delay

	set config(sdram_cr_val) $val

	set config(sdram_tr_val) 0x13c

	set config(sdram_base) $::AT91_CHIPSELECT_1
	at91sam9_reset_init $config
}
#################################################################################################
#												#
# Author: Gary Carlson (gcarlson@carlson-minot.com)						#
# Generated for Atmel AT91SAM9G20-EK evaluation board using Atmel SAM-ICE (J-Link) version 8.	#
#												#
#################################################################################################

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

source [find target/at91sam9g20.cfg]

set _FLASHTYPE nandflash_cs3

# Set reset type.  Note that the AT91SAM9G20-EK board has the trst signal disconnected.  Therefore
# the reset needs to be configured for "srst_only".  If for some reason, a zero-ohm jumper is
# added to the board to connect the trst signal, then this parameter may need to be changed.

reset_config srst_only

adapter srst delay 200
jtag_ntrst_delay 200

# If you don't want to execute built-in boot rom code (and there are good reasons at times not to do that) in the
# AT91SAM9 family, the microcontroller is a lump on a log without initialization.  Because this family has
# some powerful features, we want to have a special function that handles "reset init".  To do this we declare
# an event handler where these special activities can take place.

scan_chain
$_TARGETNAME configure -event reset-init {at91sam9g20_reset_init}
$_TARGETNAME configure -event reset-start {at91sam9g20_reset_start}

# NandFlash configuration and definition

nand device nandflash_cs3 at91sam9 $_TARGETNAME 0x40000000 0xfffffe800
at91sam9 cle 0 22
at91sam9 ale 0 21
at91sam9 rdy_busy 0 0xfffff800 13
at91sam9 ce 0 0xfffff800 14

proc read_register {register} {
        set result ""
        mem2array result 32 $register 1
        return $result(0)
}

proc at91sam9g20_reset_start { } {

	# Make sure that the the jtag is running slow, since there are a number of different ways the board
	# can be configured coming into this state that can cause communication problems with the jtag
	# adapter.  Also since this call can be made following a "reset init" where fast memory accesses
	# are enabled, need to temporarily shut this down so that the RSTC_MR register can be written at slower
	# jtag speed without causing GDB keep alive problem.

	arm7_9 fast_memory_access disable
	adapter speed 2                 ;# Slow-speed oscillator enabled at reset, so run jtag speed slow.
	halt                            ;# Make sure processor is halted, or error will result in following steps.
	wait_halt 10000
	mww 0xfffffd08 0xa5000501       ;# RSTC_MR : enable user reset.
}

proc at91sam9g20_reset_init { } {

	# At reset AT91SAM9G20 chip runs on slow clock (32.768 kHz).  To shift over to a normal clock requires
	# a number of steps that must be carefully performed.  The process outline below follows the
	# recommended procedure outlined in the AT91SAM9G20 technical manual.
	#
	# Several key and very important things to keep in mind:
	# The SDRAM parts used currently on the Atmel evaluation board are -75 grade parts.  This
	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.

	mww 0xfffffd44 0x00008000	;# WDT_MR : disable watchdog.

	# Enable the main 18.432 MHz oscillator in CKGR_MOR register.
	# Wait for MOSCS in PMC_SR to assert indicating oscillator is again stable after change to CKGR_MOR.

	mww 0xfffffc20 0x00004001
	while { [expr [read_register 0xfffffc68] & 0x01] != 1 } { sleep 1 }

	# Set PLLA Register for 792.576 MHz (divider: bypass, multiplier: 43).
	# Wait for LOCKA signal in PMC_SR to assert indicating PLLA is stable.

	mww 0xfffffc28 0x202a3f01
	while { [expr [read_register 0xfffffc68] & 0x02] != 2 } { sleep 1 }

	# Set master system clock prescaler divide by 6 and processor clock divide by 2 in PMC_MCKR.
	# Wait for MCKRDY signal from PMC_SR to assert.

	mww 0xfffffc30 0x00000101
	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }

	# Now change PMC_MCKR register to select PLLA.
	# Wait for MCKRDY signal from PMC_SR to assert.

	mww 0xfffffc30 0x00001302
	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }

	# Processor and master clocks are now operating and stable at maximum frequency possible:
	#	-> MCLK = 132.096 MHz
	#	-> PCLK = 396.288 MHz

	# Switch over to adaptive clocking.

	adapter speed 0

	# Enable faster DCC downloads and memory accesses.

	arm7_9 dcc_downloads enable
	arm7_9 fast_memory_access enable

	# To be able to use external SDRAM, several peripheral configuration registers must
	# be modified.  The first change is made to PIO_ASR to select peripheral functions
	# for D15 through D31.  The second change is made to the PIO_PDR register to disable
	# this for D15 through D31.

	mww 0xfffff870 0xffff0000
	mww 0xfffff804 0xffff0000

	# The EBI chip select register EBI_CS must be specifically configured to enable the internal SDRAM controller
	# using CS1.  Additionally we want CS3 assigned to NandFlash.  Also VDDIO is connected physically on
	# the board to the 3.3 VDC power supply so set the appropriate register bit to notify the micrcontroller.

	mww 0xffffef1c 0x000100a

	# The AT91SAM9G20-EK evaluation board has built-in NandFlash.  The exact physical timing characteristics
	# for the memory type used on the current board (MT29F2G08AACWP) can be established by setting
	# a number of registers.  The first step involves setting up the general I/O pins on the processor
	# to be able to interface and support the external memory.

	mww 0xfffffc10 0x00000010	;# PMC_PCER : enable PIOC clock
	mww 0xfffff800 0x00006000	;# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
	mww 0xfffff810 0x00004000	;# PIOC_OER : enable output on 14
	mww 0xfffff814 0x00002000	;# PIOC_ODR : disable output on 13
    	mww 0xfffff830 0x00004000	;# PIOC_SODR : set 14 to disable NAND

	# The exact physical timing characteristics for the memory type used on the current board
	# (MT29F2G08AACWP) can be established by setting four registers in order:  SMC_SETUP3,
	# SMC_PULSE3, SMC_CYCLE3, and SMC_MODE3.  Computing the exact values of these registers
	# is a little tedious to do here.  If you have questions about how to do this, Atmel has
	# a decent application note #6255B that covers this process.

	mww 0xffffec30 0x00020002	;# SMC_SETUP3 : 2 clock cycle setup for NRD and NWE
	mww 0xffffec34 0x04040404	;# SMC_PULSE3 : 4 clock cycle pulse for all signals
	mww 0xffffec38 0x00070006	;# SMC_CYCLE3 : 7 clock cycle NRD and 6 NWE cycle
	mww 0xffffec3C 0x00020003	;# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW,

	mww 0xffffe800 0x00000001	;# ECC_CR : reset the ECC parity registers
	mww 0xffffe804 0x00000002	;# ECC_MR : page size is 2112 words (word is 8 bits)

	# Identify NandFlash bank 0.

	nand probe nandflash_cs3

	# The AT91SAM9G20-EK evaluation board has build-in serial data flash also.

	# Now setup SDRAM.  This is tricky and configuration is very important for reliability!  The current calculations
	# are based on 2 x Micron MT48LC16M16A2-75 memory (4 M x 16 bit x 4 banks).  If you use this file as a reference
	# for a new board that uses different SDRAM devices or clock rates, you need to recalculate the value inserted
	# into the SDRAM_CR register.  Using the memory datasheet for the -75 grade part and assuming a master clock
	# of 132.096 MHz then the SDCLK period is equal to 7.6 ns.  This means the device requires:
	#
	#	CAS latency = 3 cycles
	#	TXSR = 10 cycles
	#	TRAS = 6 cycles
	#	TRCD = 3 cycles
	#	TRP = 3 cycles
	#	TRC = 9 cycles
	#	TWR = 2 cycles
	#	9 column, 13 row, 4 banks
	#	refresh equal to or less then 7.8 us for commercial/industrial rated devices
	#
	#	Thus SDRAM_CR = 0xa6339279

	mww 0xffffea08 0xa6339279

	# Next issue a 'NOP' command through the SDRAMC_MR register followed by writing a zero value into
	# the starting memory location for the SDRAM.

	mww 0xffffea00 0x00000001
	mww 0x20000000 0

	# Issue an 'All Banks Precharge' command through the SDRAMC_MR register followed by writing a zero
	# value into the starting memory location for the SDRAM.

	mww 0xffffea00 0x00000002
	mww 0x20000000 0

	# Now issue an 'Auto-Refresh' command through the SDRAMC_MR register.  Follow this operation by writing
	# zero values eight times into the starting memory location for the SDRAM.

	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0

	# Almost done, so next issue a 'Load Mode Register' command followed by a zero value write to the
	# the starting memory location for the SDRAM.

	mww 0xffffea00 0x3
	mww 0x20000000 0

	# Signal normal mode using the SDRAMC_MR register and follow with a zero value write the the starting
	# memory location for the SDRAM.

	mww 0xffffea00 0x0
	mww 0x20000000 0

	# Finally set the refresh rate to about every 7 us (7.5 ns x 924 cycles).

	mww 0xffffea04 0x0000039c
}
# Atmel AT91SAM7S-EK
# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3784

set CHIPNAME at91sam7s256

source [find target/at91sam7sx.cfg]
################################################################################
# Atmel AT91SAM9260-EK eval board
#
# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933
#
# Atmel AT91SAM9260 : PLLA = 198.656 MHz, MCK = 99.328 MHz
#                     OSCSEL configured for external 32.768 kHz crystal
#
# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
#
################################################################################

# We add to the minimal configuration.
source [find target/at91sam9260.cfg]

# By default S1 is open and this means that NTRST is not connected.
# The reset_config in target/at91sam9260.cfg is overridden here.
# (or S1 must be populated with a 0 Ohm resistor)
reset_config srst_only

$_TARGETNAME configure -event reset-start {
        # At reset CPU runs at 32.768 kHz.
        # JTAG Frequency must be 6 times slower if RCLK is not supported.
        jtag_rclk 5
        halt
        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
        mww phys 0xfffffd08 0xa5000501
}

$_TARGETNAME configure -event reset-init {
        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog

	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198.656 MHz
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
        sleep 10                          ;# wait 10 ms

	# Increase JTAG Speed to 6 MHz if RCLK is not supported
        jtag_rclk 6000

	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads

	mww 0xfffff870 0xffff0000         ;# PIO_ASR  : Select peripheral function for D15..D31
        mww 0xfffff804 0xffff0000         ;# PIO_PDR  : Disable PIO function for D15..D31

        mww 0xffffef1c 0x00010002         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory

	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)

	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
	mww 0x20000000 0
	mww 0xffffea04 0x2b6              ;# SDRAMC_TR : Set refresh timer count to 7us
}
################################################################################
#
# Generated for Atmel AT91SAM9RL-EK evaluation board using Atmel SAM-ICE (J-Link) V6
#
# Atmel AT91SAM9RL : PLL = 200 MHz, MCK = 100 MHz
#                     OSCSEL configured for external 32.768 kHz crystal
#
# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
#
################################################################################

# We add to the minimal configuration.
source [find target/at91sam9rl.cfg]

$_TARGETNAME configure -event reset-start {
        # At reset CPU runs at 32.768 kHz.
        # JTAG Frequency must be 6 times slower if RCLK is not supported.
        jtag_rclk 5
        halt
        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
        mww phys 0xfffffd08 0xa5000501
}

$_TARGETNAME configure -event reset-init {
        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog

	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc28 0x2031bf03         ;# CKGR_PLLR: Set PLL Register for 200 MHz
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLL is selected (100 MHz)
        sleep 10                          ;# wait 10 ms

	# Increase JTAG Speed to 6 MHz if RCLK is not supported
        jtag_rclk 6000

	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads

	mww 0xfffff670 0xffff0000         ;# PIO_ASR  : Select peripheral function for D16..D31 (PIOB)
        mww 0xfffff604 0xffff0000         ;# PIO_PDR  : Disable PIO function for D16..D31 (PIOB)

        mww 0xffffef20 0x00010002         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory

	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)

	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
	mww 0x20000000 0
	mww 0xffffea04 0x2b6              ;# SDRAMC_TR : Set refresh timer count to 7us
}

#
# Board configuration for Atmel's SAM3N-EK
#

reset_config srst_only

set CHIPNAME at91sam3n4c

adapter speed 32

source [find target/at91sam3nXX.cfg]
source [find target/at91sam3sXX.cfg]
source [find target/at91sam3u4e.cfg]

reset_config srst_only
source [find target/at91sam3ax_8x.cfg]

reset_config srst_only
# This is an SAM4E-EK board with a single SAM4E16 chip.
# http://www.atmel.com/tools/sam4e-ek.aspx

# chip name
set CHIPNAME SAM4E16E

source [find target/at91sam4sXX.cfg]
#
# Atmel SAM4L8 Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAM4L8-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME ATSAM4LC8CA

source [find target/at91sam4lXX.cfg]
source [find target/at91sam4sXX.cfg]
#
# Atmel SAM4S Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAM4S-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME ATSAM4SD32C

source [find target/at91sam4sd32x.cfg]
#
# Atmel SAMC20 Xplained Pro evaluation kit.
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samc20j18

source [find target/at91samdXX.cfg]
#
# Atmel SAMC21 Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAMC21-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samc21j18

source [find target/at91samdXX.cfg]
#
# Atmel SAMD10 Xplained mini evaluation kit.
# http://www.atmel.com/tools/atsamd10-xmini.aspx

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samd10d14

source [find target/at91samdXX.cfg]
#
# Atmel SAMD11 Xplained Pro evaluation kit.
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samd11d14

source [find target/at91samdXX.cfg]
#
# Atmel SAMD20 Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAMD20-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samd20j18

source [find target/at91samdXX.cfg]
#
# Atmel SAMD21 Xplained Pro evaluation kit.
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samd21j18

source [find target/at91samdXX.cfg]
#
# Atmel SAME70 Xplained evaluation kit.
# http://www.atmel.com/tools/ATSAME70-XPLD.aspx
#
# Connect using the EDBG chip on the dev kit over USB
source [find interface/cmsis-dap.cfg]

set CHIPNAME atsame70q21

source [find target/atsamv.cfg]

reset_config srst_only
#
# Atmel SAMG53 Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAMG53-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME ATSAMG53N19

source [find target/at91samg5x.cfg]
#
# Atmel SAMG55 Xplained Pro evaluation kit.
# http://www.atmel.com/tools/ATSAMG55-XPRO.aspx
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME ATSAMG55J19

source [find target/at91samg5x.cfg]
#
# Atmel SAML21 Xplained Pro evaluation kit.
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91saml21j18

source [find target/at91samdXX.cfg]
#
# Atmel SAMR21 Xplained Pro evaluation kit.
#

source [find interface/cmsis-dap.cfg]

# chip name
set CHIPNAME at91samr21g18

source [find target/at91samdXX.cfg]
#
# Atmel SAMV71 Xplained Ultra evaluation kit.
# http://www.atmel.com/tools/ATSAMV71-XULT.aspx
#
# To connect using the EDBG chip on the dev kit over USB, you will
# first need to source [find interface/cmsis-dap.cfg]
# however, since this board also has a SWD+ETM connector, we don't
# automatically source that file here.

set CHIPNAME samv71

source [find target/atsamv.cfg]
#
# AVNET UltraZED EG StarterKit
# ZynqMP UlraScale-EG plus IO Carrier with on-board digilent smt2
#
source [find interface/ftdi/digilent_jtag_smt2_nc.cfg]
# jtag transport only
transport select jtag
# reset lines are not wired
reset_config none

# slow default clock
adapter speed 1000

set CHIPNAME uscale

source [find target/xilinx_zynqmp.cfg]
# Config for balloon3 board, cpu JTAG port. http://balloonboard.org/
# The board has separate JTAG ports for cpu and CPLD/FPGA devices
# Chaining is done on IO interfaces if desired.

source [find target/pxa270.cfg]

# The board supports separate reset lines
# Override this in the interface config for parallel dongles
reset_config trst_and_srst separate

# flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
# 29LV650 64Mbit Flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x800000 2 2 $_TARGETNAME
# BCM28155_AP

adapter speed 20000

set CHIPNAME bcm28155
source [find target/bcm281xx.cfg]

reset_config trst_and_srst
#
# Board configuration for BlueField SoC.
#

source [find interface/rshim.cfg]
source [find target/bluefield.cfg]
#
# BT HomeHub v1
#

set partition_list {
    CFE       { Bootloader              0xbe400000 0x00020000 }
    firmware  { "Kernel+rootfs"         0xbe420000 0x007d0000 }
    fisdir    { "FIS Directory"         0xbebf0000 0x0000f000 }
    nvram     { "Config space"          0xbebff000 0x00001000 }
}

source [find target/bcm6348.cfg]

set _FLASHNAME $_CHIPNAME.norflash
flash bank $_FLASHNAME cfi 0xbe400000 0x00800000 2 2 $_TARGETNAME
# Toradex Colibri PXA270
source [find target/pxa270.cfg]
reset_config trst_and_srst srst_push_pull
adapter srst pulse_width 40

# CS0 -- one bank of CFI flash, 32 MBytes
# the bank is 32-bits wide, two 16-bit chips in parallel
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x02000000 2 4 $_TARGETNAME
# Crossbow Technology iMote2

set  CHIPNAME imote2
source [find target/pxa270.cfg]

# longer-than-normal reset delay
adapter srst delay 800

reset_config trst_and_srst separate

# works for P30 flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x2000000 2 2 $_TARGETNAME
# Cogent CSB337
#   http://cogcomp.com/csb_csb337.htm

source [find target/at91rm9200.cfg]

# boots from NOR on CS0:  8 MBytes CFI flash, 16-bit bus
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME

# ETM9 trace port connector present on this board, 16 data pins.
if { [info exists ETM_DRIVER] } {
	etm config $_TARGETNAME 16 normal half $ETM_DRIVER
	# OpenOCD may someday support a real trace port driver...
	# system config file would need to configure it.
} else {
	etm config $_TARGETNAME 16 normal half dummy
	etm_dummy config $_TARGETNAME
}

proc csb337_clk_init { } {
	# CPU is in Slow Clock Mode (32KiHz) ... needs slow JTAG clock
	adapter speed 8

	# CKGR_MOR:  start main oscillator (3.6864 MHz)
	mww 0xfffffc20 0xff01
	sleep 10

	# CKGR_PLLAR:  start PLL A for CPU and peripherals (184.32 MHz)
	mww 0xfffffc28 0x20313e01
	# CKGR_PLLBR:  start PLL B for USB timing (96 MHz, with div2)
	mww 0xfffffc2c 0x12703e18
	# let PLLs lock
	sleep 10

	# PMC_MCKR:  switch to CPU clock = PLLA, master clock = CPU/4
	mww 0xfffffc30 0x0302
	sleep 20

	# CPU is in Normal Mode ... allows faster JTAG clock speed
	adapter speed 40000
}

proc csb337_nor_init { } {
	# SMC_CSR0:  adjust timings (10 wait states)
	mww 0xffffff70 0x1100318a

	flash probe 0
}

proc csb337_sdram_init { } {
	# enable PIOC clock
	mww 0xfffffc10 0x0010
	# PC31..PC16 are D31..D16, with internal pullups like D15..D0
	mww 0xfffff870 0xffff0000
	mww 0xfffff874 0x0
	mww 0xfffff804 0xffff0000

	# SDRC_CR: set timings
	mww 0xffffff98 0x2188b0d5

	# SDRC_MR: issue all banks precharge to SDRAM
	mww 0xffffff90 2
	mww 0x20000000 0

	# SDRC_MR: 8 autorefresh cycles
	mww 0xffffff90 4
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0
	mww 0x20000000 0

	# SDRC_MR: set SDRAM mode registers (CAS, burst len, etc)
	mww 0xffffff90 3
	mww 0x20000080 0

	# SDRC_TR: set refresh rate
	mww 0xffffff94 0x200
	mww 0x20000000 0

	# SDRC_MR: normal mode, 32 bit bus
	mww 0xffffff90 0
	mww 0x20000000 0
}

# The rm9200 chip has just been reset.  Bring it up far enough
# that we can write flash or run code from SDRAM.
proc csb337_reset_init { } {
	csb337_clk_init

	# EBI_CSA:  CS0 = NOR, CS1 = SDRAM
	mww 0xffffff60 0x02

	csb337_nor_init
	csb337_sdram_init

	# Update CP15 control register ... we don't seem to be able to
	# read/modify/write its value through a TCL variable, so just
	# write it.  Fields are zero unless listed here ... and note
	# that OpenOCD numbers this register "2", not "1" (!).
	#
	#  - Core to use Async Clocking mode (so it uses 184 MHz most
	#    of the time instead of limiting to the master clock rate):
	#	iA(31) = 1, nF(30) = 1
	#  - Icache on (it's disabled now, slowing i-fetches)
	#	I(12) = 1
	#  - Reserved/ones
	#	6:3 = 1
	arm920t cp15 2 0xc0001078
}

$_TARGETNAME configure -event reset-init {csb337_reset_init}

arm7_9 fast_memory_access enable
# The Cogent CSB732 board has a single i.MX35 chip
source [find target/imx35.cfg]

# Determined by trial and error
reset_config trst_and_srst combined
adapter srst delay 200
jtag_ntrst_delay 200

$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { csb732_init }

# Bare-bones initialization of core clocks and SDRAM
proc csb732_init { } {

	# Disable fast writing only for init
	memwrite burst disable

	# All delay loops are omitted.
	# We assume the interpreter latency is enough.

	# Allow access to all coprocessors
	arm mcr 15 0 15 1 0 0x2001

	# Disable MMU, caches, write buffer
	arm mcr 15 0 1 0 0 0x78

	# Grant manager access to all domains
	arm mcr 15 0 3 0 0 0xFFFFFFFF

	# Set ARM clock to 532 MHz, AHB to 133 MHz
	mww 0x53F80004 0x1000

	# Set core clock to 2 * 24 MHz * (11 + 1/12) = 532 MHz
	mww 0x53F8001C 0xB2C01

	set ESDMISC 0xB8001010
	set ESDCFG0 0xB8001004
	set ESDCTL0 0xB8001000

	# Enable DDR
	mww $ESDMISC 0x4

	# Timing
	mww $ESDCFG0 0x007fff3f

	# CS0
	mww $ESDCTL0 0x92120080

	# Precharge all dummy write
	mww 0x80000400 0

	# Enable CS) auto-refresh
	mww $ESDCTL0 0xA2120080

	# Refresh twice (dummy writes)
	mww 0x80000000 0
	mww 0x80000000 0

	# Enable CS0 load mode register
	mww $ESDCTL0 0xB2120080

	# Dummy writes
	mwb 0x80000033 0x01
	mwb 0x81000000 0x01

	mww $ESDCTL0 0x82226080
	mww 0x80000000 0

	# Re-enable fast writing
	memwrite burst enable
}
#DA850 EVM board
# http://focus.ti.com/dsp/docs/thirdparty/catalog/devtoolsproductfolder.tsp?actionPerformed=productFolder&productId=5939
# http://www.logicpd.com/products/development-kits/zoom-omap-l138-evm-development-kit

source [find target/omapl138.cfg]

reset_config trst_and_srst separate

#currently any pinmux/timing must be setup by UBL before openocd can do debug
#TODO: implement pinmux/timing on reset like in board/dm365evm.cfg
######################################
# Target: DIGI ConnectCore Wi-9C
######################################

reset_config trst_and_srst

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME ns9360
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
  # This config file was defaulting to big endian..
   set  _ENDIAN big
}


# What's a good fallback frequency for this board if RCLK is
# not available??
jtag_rclk 1000


if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926031
}

set _TARGETNAME $_CHIPNAME.cpu
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

adapter srst delay 200
jtag_ntrst_delay 0


######################
# Target configuration
######################

target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-init {
	mww 0x90600104 0x33313333
	mww 0xA0700000 0x00000001  ;# Enable the memory controller.
	mww 0xA0700024 0x00000006  ;# Set the refresh counter 6
	mww 0xA0700028 0x00000001  ;#
	mww 0xA0700030 0x00000001  ;# Set the precharge period
	mww 0xA0700034 0x00000004  ;# Active to precharge command period is 16 clock cycles
	mww 0xA070003C 0x00000001  ;# tAPR
	mww 0xA0700040 0x00000005  ;# tDAL
	mww 0xA0700044 0x00000001  ;# tWR
	mww 0xA0700048 0x00000006  ;# tRC 32 clock cycles
	mww 0xA070004C 0x00000006  ;# tRFC 32 clock cycles
	mww 0xA0700054 0x00000001  ;# tRRD
	mww 0xA0700058 0x00000001  ;# tMRD
	mww 0xA0700100 0x00004280  ;# Dynamic Config 0 (cs4)
	mww 0xA0700120 0x00004280  ;# Dynamic Config 1 (cs5)
	mww 0xA0700140 0x00004280  ;# Dynamic Config 2 (cs6)
	mww 0xA0700160 0x00004280  ;# Dynamic Config 3 (cs7)
	#
	mww 0xA0700104 0x00000203  ;# CAS latency is 2 at 100 MHz
	mww 0xA0700124 0x00000203  ;# CAS latency is 2 at 100 MHz
	mww 0xA0700144 0x00000203  ;# CAS latency is 2 at 100 MHz
	mww 0xA0700164 0x00000203  ;# CAS latency is 2 at 100 MHz
	#
	mww 0xA0700020 0x00000103  ;# issue SDRAM PALL command
	#
	mww 0xA0700024 0x00000001  ;# Set the refresh counter to be as small as possible
	#
	# Add some dummy writes to give the SDRAM time to settle, it needs two
	# AHB clock cycles, here we poke in the debugger flag, this lets
	# the software know that we are in the debugger
	mww 0xA0900000 0x00000002
	mww 0xA0900000 0x00000002
	mww 0xA0900000 0x00000002
	mww 0xA0900000 0x00000002
	mww 0xA0900000 0x00000002
	#
	mdw 0xA0900000
	mdw 0xA0900000
	mdw 0xA0900000
	mdw 0xA0900000
	mdw 0xA0900000
	#
	mww 0xA0700024 0x00000030 ;# Set the refresh counter to 30
	mww 0xA0700020 0x00000083 ;# Issue SDRAM MODE command
	#
	# Next we perform a read of RAM.
	# mw = move word.
	mdw 0x00022000
	# mw 0x00022000:P, r3  # 22000 for cas2 latency, 32000 for cas 3
	#
	mww 0xA0700020 0x00000003   ;# issue SDRAM NORMAL command
	mww 0xA0700100 0x00084280   ;# Enable buffer access
	mww 0xA0700120 0x00084280   ;# Enable buffer access
	mww 0xA0700140 0x00084280   ;# Enable buffer access
	mww 0xA0700160 0x00084280   ;# Enable buffer access

	#Set byte lane state (static mem 1)"
	mww 0xA0700220 0x00000082
	#Flash Start
	mww 0xA09001F8 0x50000000
	#Flash Mask Reg
	mww 0xA09001FC 0xFF000001
	mww 0xA0700028 0x00000001

	#  RAMAddr = 0x00020000
	#  RAMSize = 0x00004000

	# Set the processor mode
	reg cpsr 0xd3
}

$_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x1000 -work-area-backup 1

#####################
# Flash configuration
#####################

#M29DW323DB - not working
#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x50000000 0x0400000 2 2 $_TARGETNAME
#
# Digilent Analog Discovery
#
# http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,842,1018&Prod=ANALOG-DISCOVERY
#
# Config is based on data from
# https://github.com/bvanheu/urjtag-ad/commit/8bd883ee01d134f94b79cbbd00df42cd03bafd71
#

adapter driver ftdi
ftdi_device_desc "Digilent USB Device"
ftdi_vid_pid 0x0403 0x6014

ftdi_layout_init 0x8008 0x800b

adapter speed 25000

source [find cpld/xilinx-xc6s.cfg]
# http://digilentinc.com/atlys/
#
# The Digilent Atlys normally requires proprietary tools to program and will
# enumerate as:
#   ID 1443:0007 Digilent Development board JTAG
#
# However, the ixo-usb-jtag project provides an alternative open firmware for
# the on board programmer. When using thie firmware the board will then
# enumerate as:
#   ID 16c0:06ad Van Ooijen Technische Informatica
# (With SerialNumber == hw_nexys)
#
# See the interface/usb-jtag.cfg for more information.

source [find interface/usb-jtag.cfg]
source [find cpld/xilinx-xc6s.cfg]
source [find cpld/jtagspi.cfg]
#
# Digilent Zedboard Rev.C, Rev.D with Xilinx Zynq chip
#
# http://zedboard.com/product/zedboard
#

source [find interface/ftdi/digilent_jtag_smt2.cfg]

reset_config srst_only srst_push_pull

source [find target/zynq_7000.cfg]
#
# Diolan LPC-4350-DB1 development board
#

set CHIPNAME lpc4350

source [find target/lpc4350.cfg]

flash bank $_CHIPNAME.nor cfi 0x1C000000 0x00200000 2 2 $_CHIPNAME.m4
#
# Diolan LPC-4357-DB1 development board
#

set CHIPNAME lpc4357

source [find target/lpc4357.cfg]

flash bank $_CHIPNAME.nor cfi 0x1C000000 0x00200000 2 2 $_CHIPNAME.m4
echo "WARNING: board/dk-tm4c129.cfg is deprecated, please switch to board/ti_dk-tm4c129.cfg"

source [find board/ti_dk-tm4c129.cfg]
# DM355 EVM board
#   http://focus.ti.com/docs/toolsw/folders/print/tmdsevm355.html
#   http://c6000.spectrumdigital.com/evmdm355/

source [find target/ti_dm355.cfg]

reset_config trst_and_srst separate

# NOTE:  disable or replace this call to dm355evm_init if you're
# debugging new UBL code from SRAM.
$_TARGETNAME configure -event reset-init { dm355evm_init }

#
# This post-reset init is called when the MMU isn't active, all IRQs
# are disabled, etc.  It should do most of what a UBL does, except for
# loading code (like U-Boot) into DRAM and running it.
#
proc dm355evm_init {} {
	global dm355

	echo "Initialize DM355 EVM board"

	# CLKIN	= 24 MHz ... can't talk quickly to ARM yet
	jtag_rclk 1500

	########################
	# PLL1		= 432 MHz (/8, x144)
	# ...SYSCLK1	= 216 MHz (/2)  ... ARM, MJCP
	# ...SYSCLK2	= 108 MHz (/4)  ... Peripherals
	# ...SYSCLK3	= 27  MHz (/16) ... VPBE, DAC
	# ...SYSCLK4	= 108 MHz (/4)  ... VPSS
	#	pll1.{prediv,div1,div2} are fixed
	#	pll1.postdiv set in MISC (for *this* speed grade)

	set addr [dict get $dm355 pllc1]
	set pll_divs [dict create]
	dict set pll_divs div3 16
	dict set pll_divs div4 4
	pll_v02_setup $addr 144 $pll_divs

	# ARM is now running at 216 MHz, so JTAG can go faster
	jtag_rclk 20000

	########################
	# PLL2		= 342 MHz (/8, x114)
	# ....SYSCLK1	= 342 MHz (/1)  ... DDR PHY at 171 MHz, 2x clock
	#	pll2.{postdiv,div1} are fixed

	set addr [dict get $dm355 pllc2]
	set pll_divs [dict create]
	dict set pll_divs div1 1
	dict set pll_divs prediv 8
	pll_v02_setup $addr 114 $pll_divs

	########################
	# PINMUX

	# All Video Inputs
	davinci_pinmux $dm355 0 0x00007f55
	# All Video Outputs
	davinci_pinmux $dm355 1 0x00145555
	# EMIFA (NOTE: more could be set up for use as GPIOs)
	davinci_pinmux $dm355 2 0x00000c08
	# SPI0, SPI1, UART1, I2C, SD0, SD1, McBSP0, CLKOUTs
	davinci_pinmux $dm355 3 0x1bff55ff
	# MMC/SD0 instead of MS; SPI0
	davinci_pinmux $dm355 4 0x00000000

	########################
	# PSC setup (minimal)

	# DDR EMIF/13, AEMIF/14, UART0/19
	psc_enable 13
	psc_enable 14
	psc_enable 19
	psc_go

	########################
	# DDR2 EMIF

	# VTPIOCR impedance calibration
	set addr [dict get $dm355 sysbase]
	set addr [expr $addr + 0x70]

	# clear CLR, LOCK, PWRDN; wait a clock; set CLR
	mmw $addr 0 0x20c0
	mmw $addr 0x2000 0

	# wait for READY
        while { [expr [mrw $addr] & 0x8000] == 0 } { sleep 1 }

	# set IO_READY; then LOCK and PWRSAVE; then PWRDN
	mmw $addr 0x4000 0
	mmw $addr 0x0180 0
	mmw $addr 0x0040 0

	# NOTE:  this DDR2 initialization sequence borrows from
	# both UBL 1.50 and the SPRUEH7D DDR2 EMIF spec.

	# reset (then re-enable) DDR controller
	psc_reset 13
	psc_go
	psc_enable 13
	psc_go

	# now set it up for Micron MT47H64M16HR-37E @ 171 MHz

	set addr [dict get $dm355 ddr_emif]

	# DDRPHYCR1
	mww [expr $addr + 0xe4] 0x50006404

	# PBBPR -- burst priority
	mww [expr $addr + 0x20] 0xfe

	# SDCR -- unlock boot config; init for DDR2, relock, unlock SDTIM*
	mmw [expr $addr + 0x08] 0x00800000 0
	mmw [expr $addr + 0x08] 0x0013c632 0x03870fff

	# SDTIMR0, SDTIMR1
	mww [expr $addr + 0x10] 0x2a923249
	mww [expr $addr + 0x14] 0x4c17c763

	# SDCR -- relock SDTIM*
	mmw [expr $addr + 0x08] 0 0x00008000

	# SDRCR -- refresh rate (171 MHz * 7.8usec)
	mww [expr $addr + 0x0c] 1336

	########################
	# ASYNC EMIF

	set addr [dict get $dm355 a_emif]

	# slow/pessimistic timings
	set nand_timings 0x40400204
	# fast (25% faster page reads)
	#set nand_timings 0x0400008c

	# AWCCR
	mww [expr $addr + 0x04] 0xff
	# CS0 == socketed NAND (default MT29F16G08FAA, 2GByte)
	mww [expr $addr + 0x10] $nand_timings
	# CS1 == dm9000 Ethernet
	mww [expr $addr + 0x14] 0x00a00505
	# NANDFCR -- only CS0 has NAND
	mww [expr $addr + 0x60] 0x01

	# default: both chipselects to the NAND socket are used
	nand probe 0
	nand probe 1

	########################
	# UART0

	set addr [dict get $dm355 uart0]

	# PWREMU_MGNT -- rx + tx in reset
	mww [expr $addr + 0x30] 0

	# DLL, DLH -- 115200 baud
	mwb [expr $addr + 0x20] 0x0d
	mwb [expr $addr + 0x24] 0x00

	# FCR - clear and disable FIFOs
	mwb [expr $addr + 0x08] 0x07
	mwb [expr $addr + 0x08] 0x00

	# IER - disable IRQs
	mwb [expr $addr + 0x04] 0x00

	# LCR - 8-N-1
	mwb [expr $addr + 0x0c] 0x03

	# MCR - no flow control or loopback
	mwb [expr $addr + 0x10] 0x00

	# PWREMU_MGNT -- rx + tx normal, free running during JTAG halt
	mww [expr $addr + 0x30] 0xe001


	########################

	# turn on icache - set I bit in cp15 register c1
	arm mcr 15 0 0 1 0 0x00051078
}

# NAND -- socket has two chipselects, MT29F16G08FAA puts 1GByte on each one.
#
# NOTE:  "hwecc4" here presumes that if you're using the standard 2GB NAND
# you either (a) have 'new' DM355 chips, with boot ROMs that don't need to
# use "hwecc4_infix" for the UBL; or else (b) aren't updating anything that
# needs infix layout ... like an old UBL, old U-Boot, old MVL kernel, etc.
set _FLASHNAME $_CHIPNAME.boot
nand device $_FLASHNAME davinci $_TARGETNAME 0x02000000 hwecc4 0x01e10000
set _FLASHNAME $_CHIPNAME.flash
nand device $_FLASHNAME davinci $_TARGETNAME 0x02004000 hwecc4 0x01e10000

# FIXME
#  - support writing UBL with its header (new layout only with new ROMs)
#  - support writing ABL/U-Boot with its header (new layout)
# DM365 EVM board -- Beta
#   http://focus.ti.com/docs/toolsw/folders/print/tmdxevm365.html
#   http://support.spectrumdigital.com/boards/evmdm365

source [find target/ti_dm365.cfg]

# NOTE:  in Rev C boards, the CPLD ignores SRST from the ARM-20 JTAG
# connector, so it doesn't affect generation of the reset signal.
# Accordingly, resets require something else.  ICEpick could do it;
# but its docs aren't generally available.
#
# At this writing, newer boards aren't available ... so assume no SRST.
# Also ICEpick docs aren't available ... so we must use watchdog reset,
# and hope the CPU isn't wedged or in a WFI loop (either of which can
# block access to CPU and thus watchdog registers).

reset_config trst_only
$_TARGETNAME configure -event reset-assert "davinci_wdog_reset"

# SW5.1 routes CS0: NAND vs OneNAND.
# SW4.6:4 controls AEMIF width (8 for NAND, 16 for OneNand)
# for boot-from-flash, those must agree with SW4.3:1 settings.

if { [info exists CS0MODE] } {
	# NAND or OneNAND
	set CS0 $CS0MODE
} else {
	set CS0 ""
	echo "WARNING:  CS0 configuration not known"
	proc cs0_setup {a_emif} {}
	proc flashprobe {} {}
}

set a_emif [dict get $dm365 a_emif]

# As shipped:  boot from NAND.
if { $CS0 == "NAND" } {
	echo "CS0 NAND"

	# NAND socket has two chipselects.  Default MT29F16G08FAA chip
	# has 1GByte on each one.
	# NOTE:  "hwecc4" here presumes that you're not updating anything
	# that needs infix layout (e.g. UBL, old U-Boot, etc)
	nand device low davinci $_TARGETNAME 0x02000000 hwecc4 $a_emif
	nand device high davinci $_TARGETNAME 0x02004000 hwecc4 $a_emif

	proc cs0_setup {a_emif} {
		global dm365

		# 8 bit EMIF
		davinci_pinmux $dm365 2 0x00000016

		# slow/pessimistic timings
		set nand_timings 0x40400204
		# fast (25% faster page reads)
		#set nand_timings 0x0400008c

		# CS0 == socketed NAND (default MT29F16G08FAA, 2 GBytes)
		mww [expr $a_emif + 0x10] $nand_timings

		# NANDFCR -- CS0 has NAND
		mww [expr $a_emif + 0x60] 0x01
	}
	proc flashprobe {} {
		nand probe 0
		nand probe 1
	}

} elseif { $CS0 == "OneNAND" } {
	echo "CS0 OneNAND"

	# No support for this OneNAND in OpenOCD (yet) or Linux ...
	# REVISIT OneNAND timings not verified to work!
	echo "WARNING -- OneNAND not yet tested!"

	proc cs0_setup {a_emif} {
		global dm365

		# 16 bit EMIF
		davinci_pinmux $dm365 2 0x00000055

		# CS0 == OneNAND (KFG1G16U2B-DIB6, 128 KBytes)
		mww [expr $a_emif + 0x10] 0x00000001

		# ONENANDCTRL -- CS0 has OneNAND, enable sync reads
		mww [expr $a_emif + 0x5c] 0x0441
	}
	proc flashprobe {} { }
}

# NOTE:  disable or replace this call to dm365evm_init if you're
# debugging new UBL/NANDboot code from SRAM.
$_TARGETNAME configure -event reset-init { dm365evm_init }

#
# This post-reset init is called when the MMU isn't active, all IRQs
# are disabled, etc.  It should do most of what a UBL does, except for
# loading code (like U-Boot) into DRAM and running it.
#
proc dm365evm_init {} {
	global dm365

	echo "Initialize DM365 EVM board"

	# CLKIN	= 24 MHz ... can't talk quickly to ARM yet
	adapter speed 1500

	# FIXME -- PLL init

	########################
	# PINMUX setup

	davinci_pinmux $dm365 0 0x00fd0000
	davinci_pinmux $dm365 1 0x00145555
	# mux2 controls AEMIF ... 8 bit for NAND, 16 for OneNand
	davinci_pinmux $dm365 3 0x375affff
	davinci_pinmux $dm365 4 0x55556555

	########################
	# PSC setup (minimal)

	# DDR EMIF/13, AEMIF/14, UART0/19
	psc_enable 13
	psc_enable 14
	psc_enable 19
	psc_go

	# FIXME setup DDR2 (needs PLL)

	########################
	# ASYNC EMIF

	set a_emif [dict get $dm365 a_emif]

	# AWCCR
	mww [expr $a_emif + 0x04] 0xff
	# CS0 == NAND or OneNAND
	cs0_setup $a_emif
	# CS1 == CPLD
	mww [expr $a_emif + 0x14] 0x00a00505

	# FIXME setup UART0

	flashprobe
}
# DM6446 EVM board
#   http://focus.ti.com/docs/toolsw/folders/print/tmdsevm6446.html
#   http://c6000.spectrumdigital.com/davincievm/
# EVM is just the board; buy that at Spectrum.
# The "kit" from TI also has: video camera, LCD video monitor, more.

source [find target/ti_dm6446.cfg]

# J4 controls what CS2 hooks up to, usually NOR or NAND flash.
# S3.1/S3.2 controls boot mode, which may force J4 and S3.3 settings.
# S3.3 controls AEMIF bus width.

if { [info exists J4_OPTION] } {
	# NOR, NAND, SRAM, ...
	set CS2_MODE $J4_OPTION
} else {
	set CS2_MODE ""
}

# ARM boot:
#  S3.1 = 0, S3.2 = 0	==> ROM/UBL boot via NAND (J4 == NAND)
#  S3.1 = 1, S3.2 = 0	==> AEMIF boot (J4 == NOR or SRAM)
#  S3.1 = 0, S3.2 = 1	==> ROM/UBL boot via HPI
#  S3.1 = 1, S3.2 = 1	==> ROM/UBL boot via UART (J4 == don't care)
# AEMIF bus width:
#  S3.3 = 0		==> 8 bit bus width
#  S3.3 = 1		==> 16 bit bus width
# DSP boot:
#  S3.4 = 0		==> controlled by ARM

if { $CS2_MODE == "NOR" } {
	# 16 Mbytes address space; 16 bit bus width
	# (older boards used 32MB parts, with upper 16 MB unusable)
	set _FLASHNAME $_CHIPNAME.flash
	flash bank $_FLASHNAME cfi 0x02000000 0x01000000 2 2 $_TARGETNAME
	proc flashprobe {} { flash probe 0 }
} elseif { $CS2_MODE == "NAND" } {
	# 64 Mbyte small page; 8 bit bus width
	nand device davinci $_TARGETNAME 0x02000000 hwecc1 0x01e00000
	proc flashprobe {} { nand probe 0 }
} elseif { $CS2_MODE == "SRAM" } {
	# 4 Mbyte address space; 16 bit bus width
	# loaded via JTAG or HPI
	proc flashprobe {} {}
} else {
	# maybe it's HPI boot?  can't tell...
	echo "WARNING:  CS2/flash configuration not recognized"
	proc flashprobe {} {}
}

# NOTE:  disable or replace this call to dm6446evm_init if you're
# debugging new UBL code from SRAM (for NAND boot).
$_TARGETNAME configure -event reset-init { dm6446evm_init }

#
# This post-reset init is called when the MMU isn't active, all IRQs
# are disabled, etc.  It should do most of what a UBL does, except for
# loading code (like U-Boot) into DRAM and running it.
#
proc dm6446evm_init {} {

	echo "Initialize DM6446 EVM board"

	# FIXME initialize everything:
	#  - PLL1
	#  - PLL2
	#  - PINMUX
	#  - PSC
	#  - DDR
	#  - AEMIF
	#  - UART0
	#  - icache

	flashprobe
}
#
# Dangerous Prototypes - Bus Blaster
#
# http://dangerousprototypes.com/docs/Bus_Blaster
#
# To reprogram the on-board CPLD do:
# openocd -f board/dp_busblaster_v3.cfg -c "adapter speed 1000; init; svf <path_to_svf>; shutdown"
#

source [find interface/ftdi/dp_busblaster.cfg]
ftdi_channel 1

jtag newtap xc2c32a tap -expected-id 0x06e1c093 -irlen 8
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Dangerous Prototypes - Bus Blaster
#
# http://dangerousprototypes.com/docs/Bus_Blaster
#
# The Bus Blaster has a configurable buffer between the FTDI FT2232H
# and the JTAG header which allows it to emulate various debugger
# types. This config works with KT-Link compatible implementation from
# https://raw.githubusercontent.com/dergraaf/busblaster_v4/master/ktlink/ktlink.svf
#
# To reprogram the on-board CPLD do:
# openocd -f board/dp_busblaster_v4.cfg -c "adapter_khz 1000; init; svf <path_to_svf>; shutdown"
#

source [find interface/ftdi/dp_busblaster.cfg]
ftdi_channel 1

jtag newtap xc2c64a tap -expected-id 0x06e5c093 -irlen 8
# Product page:
# https://www.dptechnics.com/en/products/dpt-board-v1.html
#
# JTAG is a 5 pin array located close to main module in following order:
# 1. JTAG TCK
# 2. JTAG TDO
# 3. JTAG TDI
# 4. JTAG TMS
# 5. GND	The GND is located near letter G of word JTAG on board.
#
# Two RST pins are connected to:
# 1. GND
# 2. GPIO11	this pin is located near letter R of word RST.
#
# To enable EJTAG mode, GPIO11 (RST[1]) pin should be pulled up. For example
# with 10K resistor connected to V3.3 pin.
#
# This board is powered from micro USB connector. No real reset pin or button, for
# example RESET_L is available.

source [find target/atheros_ar9331.cfg]

$_TARGETNAME configure -event reset-init {
	ar9331_25mhz_pll_init
	sleep 1
	ar9331_ddr2_init
}

set ram_boot_address 0xa0000000
$_TARGETNAME configure -work-area-phys 0xa1FFE000 -work-area-size 0x1000

flash bank flash0 ath79 0xbf000000 0 0 0 $_TARGETNAME cs0
# Genesi USA EfikaMX
#  http://www.genesi-usa.com/products/efika

# Fall back to 6MHz if RTCK is not supported
jtag_rclk 6000
$_TARGETNAME configure -event "reset-start" { jtag_rclk 6000 }

source [find target/imx51.cfg]

reset_config trst_only
# Configuration for EFM32 boards with on-board SEGGER J-Link
#
# Tested with Tiny, Giant and Zero Gecko Starter Kit.
#

source [find interface/jlink.cfg]
transport select swd
adapter speed 1000

set CHIPNAME efm32
source [find target/efm32.cfg]
# Elector Internet Radio board
# http://www.ethernut.de/en/hardware/eir/index.html

source [find target/at91sam7se512.cfg]

$_TARGETNAME configure -event reset-init {
	# WDT_MR, disable watchdog
	mww 0xFFFFFD44 0x00008000

	# RSTC_MR, enable user reset
	mww 0xfffffd08 0xa5000001

	# CKGR_MOR
	mww 0xFFFFFC20 0x00000601
	sleep 10

	# CKGR_PLLR
	mww 0xFFFFFC2C 0x00481c0e
	sleep 10

	# PMC_MCKR
	mww 0xFFFFFC30 0x00000007
	sleep 10

	# PMC_IER
	mww 0xFFFFFF60 0x00480100

	#
	# Enable SDRAM interface.
	#

	# Enable SDRAM control at PIO A.
	mww 0xfffff474 0x3f800000 ;# PIO_BSR_OFF
	mww 0xfffff404 0x3f800000 ;# PIO_PDR_OFF

	# Enable address bus (A0, A2-A11, A13-A17) at PIO B
	mww 0xfffff674 0x0003effd ;# PIO_BSR_OFF
	mww 0xfffff604 0x0003effd ;# PIO_PDR_OFF

	# Enable 16 bit data bus at PIO C
	mww 0xfffff870 0x0000ffff ;# PIO_ASR_OFF
	mww 0xfffff804 0x0000ffff ;# PIO_PDR_OFF

	# Enable SDRAM chip select
	mww 0xffffff80 0x00000002 ;# EBI_CSA_OFF

	# Set SDRAM characteristics in configuration register.
	# Hard coded values for MT48LC32M16A2 with 48MHz CPU.
	mww 0xffffffb8 0x2192215a ;# SDRAMC_CR_OFF
	sleep 10

	# Issue 16 bit SDRAM command: NOP
	mww 0xffffffb0 0x00000011 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000

	# Issue 16 bit SDRAM command: Precharge all
	mww 0xffffffb0 0x00000012 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000

	# Issue 8 auto-refresh cycles
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000
	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000000

	# Issue 16 bit SDRAM command: Set mode register
	mww 0xffffffb0 0x00000013 ;# SDRAMC_MR_OFF
	mww 0x20000014 0xcafedede

	# Set refresh rate count ???
	mww 0xffffffb4 0x00000013 ;# SDRAMC_TR_OFF

	# Issue 16 bit SDRAM command: Normal mode
	mww 0xffffffb0 0x00000010 ;# SDRAMC_MR_OFF
	mww 0x20000000 0x00000180

	#
	# Enable external reset key.
	#
	mww 0xfffffd08 0xa5000001
}
#
# TI/Luminary Stellaris LM3S1968 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s1968
#

# NOTE:  to use J-Link instead of the on-board interface,
# you may also need to reduce adapter speed to be about 1200.
# source [find interface/jlink.cfg]

# include the FT2232 interface config for on-board JTAG interface
# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
# so is using in JTAG mode, as done here.
source [find interface/ftdi/luminary.cfg]

# include the target config
set WORKAREASIZE 0x2000
set CHIPNAME lm3s1968
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris lm3s3748 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s3748
#

# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
# so is using it in JTAG mode, as done here.
source [find interface/ftdi/luminary.cfg]

# 20k working area
set WORKAREASIZE 0x4000
set CHIPNAME lm3s3748
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S6965 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s6965
#

# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
# so is using it in JTAG mode, as done here.
source [find interface/ftdi/luminary.cfg]

# 20k working area
set WORKAREASIZE 0x5000
set CHIPNAME lm3s6965
# include the target config
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S811 Evaluation Kits (rev B and earlier)
#
# http://www.ti.com/tool/ek-lm3s811
#

# NOTE: newer 811-EK boards (rev C and above) shouldn't use this.
# use board/ek-lm3s811.cfg
source [find interface/ftdi/luminary-lm3s811.cfg]

# include the target config
set WORKAREASIZE 0x2000
set CHIPNAME lm3s811
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S811 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s811
#

# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
# so is using it in JTAG mode, as done here.
# NOTE:  older '811-EK boards (before rev C) shouldn't use this.
source [find interface/ftdi/luminary.cfg]

# include the target config
set WORKAREASIZE 0x2000
set CHIPNAME lm3s811
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S8962 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s8962
#

# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
# so is using it in JTAG mode, as done here.
source [find interface/ftdi/luminary.cfg]

# 64k working area
set WORKAREASIZE 0x10000
set CHIPNAME lm3s8962
# include the target config
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S9B9x Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s9b90
# http://www.ti.com/tool/ek-lm3s9b92
#

# NOTE:  using the bundled FT2232 JTAG/SWD/SWO interface is optional!
# so is using in JTAG mode, as done here.
source [find interface/ftdi/luminary-icdi.cfg]

set WORKAREASIZE 0x4000
set CHIPNAME lm3s9b9x
source [find target/stellaris.cfg]
#
# TI/Luminary Stellaris LM3S9D92 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm3s9d92
#

# NOTE:  using the bundled FT2232 JTAG/SWD/SWO interface is optional!
# so is using in JTAG mode, as done here.
source [find interface/ftdi/luminary-icdi.cfg]

# 64k working area
set WORKAREASIZE 0x10000
set CHIPNAME lm3s9d92
source [find target/stellaris.cfg]
#
# TI Stellaris Launchpad ek-lm4f120xl Evaluation Kits
#
# http://www.ti.com/tool/ek-lm4f120xl
#

#
# NOTE: using the bundled ICDI interface is optional!
# This interface is not ftdi based as previous boards were
#
source [find interface/ti-icdi.cfg]

transport select hla_jtag

set WORKAREASIZE 0x8000
set CHIPNAME lm4f120h5qr
source [find target/stellaris.cfg]
#
# TI Stellaris LM4F232 Evaluation Kits
#
# http://www.ti.com/tool/ek-lm4f232
#

#
# NOTE: using the bundled ICDI interface is optional!
# This interface is not ftdi based as previous boards were
#
source [find interface/ti-icdi.cfg]

transport select hla_jtag

set WORKAREASIZE 0x8000
set CHIPNAME lm4f23x
source [find target/stellaris.cfg]
echo "WARNING: board/ek-tm4c123gxl.cfg is deprecated, please switch to board/ti_ek-tm4c123gxl.cfg"

source [find board/ti_ek-tm4c123gxl.cfg]
echo "WARNING: board/ek-tm4c1294xl.cfg is deprecated, please switch to board/ti_ek-tm4c1294xl.cfg"

source [find board/ti_ek-tm4c1294xl.cfg]
# Embedded Artists eval board for LPC2478
# http://www.embeddedartists.com/

# Target device: LPC2478
set CCLK 72000
source [find target/lpc2478.cfg]

# Helper
#
proc read_register {register} {
    set result ""
    mem2array result 32 $register 1
    return $result(0)
}

proc init_board {} {
    # Delays on reset lines
    adapter srst delay 500
    jtag_ntrst_delay 1

    # Adaptive JTAG clocking through RTCK.
    #
    jtag_rclk 20

    global _TARGETNAME
    global _CHIPNAME

    # A working area will help speeding the flash programming
    $_TARGETNAME configure -work-area-phys 0x40000200 -work-area-size [expr 0x10000-0x200-0x20] -work-area-backup 0

    # External 16-bit flash at chip select CS0 (SST39VF3201-70, 4 MiB)
    flash bank $_CHIPNAME.extflash cfi 0x80000000 0x400000 2 2 $_TARGETNAME jedec_probe

    # Event handlers
    #
    $_TARGETNAME configure -event reset-start {
        # Back to the slow JTAG clock
        jtag_rclk 20
    }

    $_TARGETNAME configure -event reset-init {
        arm core_state arm
        arm7_9 dcc_downloads enable     ;# Speed up downloads by using DCC transfer
        arm7_9 fast_memory_access enable

        # Peripheral clocks
        mww 0xE01FC0C4 0x04280FFE       ;# PCONP: (reset value)

        # Map the user flash to the vector table area (0x00...0x3F)
        mww 0xE01FC040 0x00000001       ;# MEMMAP: User flash

        # Memory accelerator module
        mww 0xE01FC004 0x00000003       ;# MAMTIM: 3 clock cycles
        mww 0xE01FC000 0x00000002       ;# MAMCR: fully enabled

        # Enable external memory bus (32-bit SDRAM at DYCS0, 16-bit flash at CS0)
        mww 0xE002C014 0x55010115       ;# PINSEL5: P2.16=CAS, P2.17=RAS, P2.18=CLKOUT0,
                                         # P2.20=DYCS0, P2.24=CKEOUT0, P2.28=DQMOUT0,
                                         # P2.29=DQMOUT1, P2.30=DQMOUT2, P2.31=DQMOUT3
        mww 0xE002C018 0x55555555       ;# PINSEL6: P3.0...P3.15=D0...D15
        mww 0xE002C01C 0x55555555       ;# PINSEL7: P3.16...P3.31=D16...D31
        mww 0xE002C020 0x55555555       ;# PINSEL8: P4.0...P4.15=A0...A15
        mww 0xE002C024 0x50051555       ;# PINSEL9: P4.16...P4.22=A16...A22, P4.24=OE,
                                         # P4.25=WE, P4.30=CS0, P4.31=CS1
        mww 0xFFE08000 0x00000001       ;# EMCControl: Enable EMC

        # Start PLL, then use faster JTAG clock
        enable_pll
        jtag_rclk 3000

        # 16-bit flash @ CS0 (SST39VF3201-70)
        mww 0xFFE08200 0x00080081       ;# EMCStaticConfig0: 16 bit, PB=1, buffers on
        mww 0xFFE08204 0x00000000       ;# EMCStaticWaitWen0
        mww 0xFFE08208 0x00000000       ;# EMCStaticWaitOen0
        mww 0xFFE0820C 0x00000005       ;# EMCStaticWaitRd0
        mww 0xFFE08210 0x00000005       ;# EMCStaticWaitPage0
        mww 0xFFE08214 0x00000003       ;# EMCStaticWaitWr0
        mww 0xFFE08218 0x00000001       ;# EMCStaticWaitTurn0

        # 8-bit NAND @ CS1
        # TODO

        # 32-bit SDRAM @ DYCS0 (K4M563233G-HN75)
        mww 0xFFE08028 0x00000001       ;# EMCDynamicReadConfig
        mww 0xFFE08030 0x00000001       ;# EMCDynamicRP
        mww 0xFFE08034 0x00000003       ;# EMCDynamicRAS
        mww 0xFFE08038 0x00000005       ;# EMCDynamicSREX
        mww 0xFFE0803C 0x00000001       ;# EMCDynamicAPR
        mww 0xFFE08040 0x00000005       ;# EMCDynamicDAL
        mww 0xFFE08044 0x00000001       ;# EMCDynamicWR
        mww 0xFFE08048 0x00000005       ;# EMCDynamicRC
        mww 0xFFE0804C 0x00000005       ;# EMCDynamicRFC
        mww 0xFFE08050 0x00000005       ;# EMCDynamicXSR
        mww 0xFFE08054 0x00000001       ;# EMCDynamicRRD
        mww 0xFFE08058 0x00000001       ;# EMCDynamicMRD
        #
        mww 0xFFE08104 0x00000202       ;# EMCDynamicRasCas0
        mww 0xFFE08100 0x00005488       ;# EMCDynamicConfig0
        sleep 100
        mww 0xFFE08020 0x00000183       ;# EMCDynamicControl: Clock on continuously, NOP
        sleep 10
        mww 0xFFE08020 0x00000103       ;# EMCDynamicControl: PRECHARGE-ALL
        mww 0xFFE08024 0x00000046       ;# EMCDynamicRefresh
        sleep 100
        mww 0xFFE08020 0x00000083       ;# EMCDynamicControl: MODE
        mdw 0xA0011000 1                ;# Set SDRAM mode register
        mww 0xFFE08020 0x00000000       ;# EMCDynamicControl: NORMAL
        mww 0xFFE08100 0x00085488       ;# EMCDynamicConfig0: Enable buffers
    }

    $_TARGETNAME configure -event gdb-attach {
        # Without this gdb-attach will first time as probe will fail
        reset init
    }
}

# Enable the PLL.
# Generate maximum CPU clock (72 MHz) Run from internal RC oscillator.
# Note: The PLL output runs at a frequency N times the desired CPU clock.
#       It in unavoidable that the CPU clock drops down to (4 MHz/N) during
#       the initialization!
#       Here: N=4
#       Note that if the PLL is already active at the time this script is
#       called, the effective value of N is the value of CCLKCFG at that time!
#
proc enable_pll {} {
    # Disconnect PLL in case it is already connected
    if {[expr [read_register 0xE01FC080] & 0x03] == 3} {
        # Disconnect it, but leave it enabled
        # (This MUST be done in two steps)
        mww 0xE01FC080 0x00000001       ;# PLLCON: disconnect PLL
        mww 0xE01FC08C 0x000000AA       ;# PLLFEED
        mww 0xE01FC08C 0x00000055       ;# PLLFEED
    }
    # Disable PLL (as it might already be enabled at this time!)
    mww 0xE01FC080 0x00000000       ;# PLLCON: disable PLL
    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
    mww 0xE01FC08C 0x00000055       ;# PLLFEED

    # Setup PLL to generate 288 MHz from internal RC oscillator
    mww 0xE01FC10C 0x00000000       ;# CLKSRCSEL: IRC
    mww 0xE01FC084 0x00000023       ;# PLLCFG: N=1, M=36
    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
    mww 0xE01FC08C 0x00000055       ;# PLLFEED
    mww 0xE01FC080 0x00000001       ;# PLLCON: enable PLL
    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
    mww 0xE01FC08C 0x00000055       ;# PLLFEED
    sleep 100
    mww 0xE01FC104 0x00000003       ;# CCLKCFG: divide by 4 (72 MHz)
    mww 0xE01FC080 0x00000003       ;# PLLCON: connect PLL
    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
    mww 0xE01FC08C 0x00000055       ;# PLLFEED
}
#
# configuration file for Emcraft IMX8M-SOM-BSB
#

# only JTAG supported
transport select jtag

# set a safe JTAG clock speed, can be overridden
adapter speed 1000

# SRST and TRST are wired up
reset_config trst_and_srst

# delay after SRST goes inactive
adapter srst delay 70

# board has an i.MX8MQ with 4 Cortex-A53 cores
set CHIPNAME imx8mq
set CHIPCORES 4

# source SoC configuration
source [find target/imx8m.cfg]
#
# EmCraft Systems TWR-VF6-SOM-BSB
#
# http://www.emcraft.com/products/259#twr-kit
#

source [find board/emcraft_vf6-som.cfg]

reset_config srst_only srst_nogate
#
# EmCraft Systems Vybrid VF6 SOM
#
# http://www.emcraft.com/products/259#som
#

set CHIPNAME vf610
source [find target/vybrid_vf6xx.cfg]
#
# Ethernut 3 board configuration file
#
# http://www.ethernut.de/en/hardware/enut3/


# AT91R40008-66AU ARM7TDMI Microcontroller
# 256kB internal RAM
source [find target/at91r40008.cfg]


# AT49BV322A-70TU NOR Flash
# 2M x 16 mode at address 0x10000000
# Common flash interface supported
#
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x400000 2 2 $_TARGETNAME


# Micrel MIC2775-29YM5 Supervisor
# Reset output will remain active for 280ms (maximum)
#
adapter srst delay 300
jtag_ntrst_delay 300


arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable
adapter speed 16000


# Target events
#
$_TARGETNAME configure -event reset-init { board_init }

# Initialize board hardware
#
proc board_init { } {
	board_remap
	flash probe 0
}

# Memory remap
#
proc board_remap {{VERBOSE 0}} {
	# CS0: NOR flash
	#      16MB @ 0x10000000
	#      16-bit data bus
	#      4 wait states
	#
	mww 0xffe00000 0x1000212d

	# CS1: Ethernet controller
	#      1MB @ 0x20000000
	#      16-bit data bus
	#      2 wait states
	#      Byte select access
	#
	mww 0xffe00004 0x20003025

	# CS2: CPLD registers
	#      1MB @ 0x21000000
	#      8-bit data bus
	#      2 wait states
	#
	mww 0xffe00008 0x21002026

	# CS3: Expansion bus
	#      1MB @ 0x22000000
	#      8-bit data bus
	#      8 wait states
	#
	mww 0xffe00010 0x22002e3e

	# Remap command
	#
	mww 0xffe00020 0x00000001

	if {$VERBOSE != 0} {
		echo "0x00000000 RAM"
		echo "0x10000000 Flash"
		echo "0x20000000 Ethernet"
		echo "0x21000000 CPLD"
		echo "0x22000000 Expansion"
	}
}
# This is an Freescale Freedom eval board with a single MKL25Z128VLK4 chip.
# http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=FRDM-KL25Z
#

source [find interface/cmsis-dap.cfg]

# increase working area to 16KB
set WORKAREASIZE 0x4000

# chip name
set CHIPNAME MKL25Z128VLK4

reset_config srst_only

source [find target/kl25.cfg]
# This is an Freescale Freedom eval board with a single MKL46Z256VLL4 chip.
# http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=FRDM-KL46Z
#

source [find interface/cmsis-dap.cfg]

# increase working area to 16KB
set WORKAREASIZE 0x4000

# chip name
set CHIPNAME MKL46Z256VLL4

reset_config srst_only

source [find target/kl46.cfg]
#
# Board configuration file for the Freescale IMX6Q Sabre SD EVM
#
# This board does not have an embedded JTAG adapter, you must source
# a suitable adapter configuration before sourcing this file.

# Sabre SD has a standard ARM-20 JTAG connector with
# nTRST and nSRST available.
reset_config trst_and_srst

# the only possible transport is JTAG
transport select jtag

# iMX6Q POR gates JTAG and the chip is completely incommunicado
# over JTAG for at least 10ms after nSRST is deasserted
adapter srst delay 11

# Source generic iMX6Q target configuration
set CHIPNAME imx6q
source [find target/imx6.cfg]

# function to apply initial configuration after a reset. It
# provides a basic pad configuration and also DDR memory and clocks
# sufficient to load and execute a boot loader (e.g. barebox) from
# DDR memory. This list is extracted from the barebox flash image
# header.
proc apply_dcd { } {
	mww 0x020e05a8 0x00000030
	mww 0x020e05b0 0x00000030
	mww 0x020e0524 0x00000030
	mww 0x020e051c 0x00000030
	mww 0x020e0518 0x00000030
	mww 0x020e050c 0x00000030
	mww 0x020e05b8 0x00000030
	mww 0x020e05c0 0x00000030
	mww 0x020e05ac 0x00020030
	mww 0x020e05b4 0x00020030
	mww 0x020e0528 0x00020030
	mww 0x020e0520 0x00020030
	mww 0x020e0514 0x00020030
	mww 0x020e0510 0x00020030
	mww 0x020e05bc 0x00020030
	mww 0x020e05c4 0x00020030
	mww 0x020e056c 0x00020030
	mww 0x020e0578 0x00020030
	mww 0x020e0588 0x00020030
	mww 0x020e0594 0x00020030
	mww 0x020e057c 0x00020030
	mww 0x020e0590 0x00003000
	mww 0x020e0598 0x00003000
	mww 0x020e058c 0x00000000
	mww 0x020e059c 0x00003030
	mww 0x020e05a0 0x00003030
	mww 0x020e0784 0x00000030
	mww 0x020e0788 0x00000030
	mww 0x020e0794 0x00000030
	mww 0x020e079c 0x00000030
	mww 0x020e07a0 0x00000030
	mww 0x020e07a4 0x00000030
	mww 0x020e07a8 0x00000030
	mww 0x020e0748 0x00000030
	mww 0x020e074c 0x00000030
	mww 0x020e0750 0x00020000
	mww 0x020e0758 0x00000000
	mww 0x020e0774 0x00020000
	mww 0x020e078c 0x00000030
	mww 0x020e0798 0x000c0000
	mww 0x021b081c 0x33333333
	mww 0x021b0820 0x33333333
	mww 0x021b0824 0x33333333
	mww 0x021b0828 0x33333333
	mww 0x021b481c 0x33333333
	mww 0x021b4820 0x33333333
	mww 0x021b4824 0x33333333
	mww 0x021b4828 0x33333333
	mww 0x021b0018 0x00081740
	mww 0x021b001c 0x00008000
	mww 0x021b000c 0x555a7975
	mww 0x021b0010 0xff538e64
	mww 0x021b0014 0x01ff00db
	mww 0x021b002c 0x000026d2
	mww 0x021b0030 0x005b0e21
	mww 0x021b0008 0x09444040
	mww 0x021b0004 0x00025576
	mww 0x021b0040 0x00000027
	mww 0x021b0000 0x831a0000
	mww 0x021b001c 0x04088032
	mww 0x021b001c 0x0408803a
	mww 0x021b001c 0x00008033
	mww 0x021b001c 0x0000803b
	mww 0x021b001c 0x00428031
	mww 0x021b001c 0x00428039
	mww 0x021b001c 0x09408030
	mww 0x021b001c 0x09408038
	mww 0x021b001c 0x04008040
	mww 0x021b001c 0x04008048
	mww 0x021b0800 0xa1380003
	mww 0x021b4800 0xa1380003
	mww 0x021b0020 0x00005800
	mww 0x021b0818 0x00022227
	mww 0x021b4818 0x00022227
	mww 0x021b083c 0x434b0350
	mww 0x021b0840 0x034c0359
	mww 0x021b483c 0x434b0350
	mww 0x021b4840 0x03650348
	mww 0x021b0848 0x4436383b
	mww 0x021b4848 0x39393341
	mww 0x021b0850 0x35373933
	mww 0x021b4850 0x48254A36
	mww 0x021b080c 0x001f001f
	mww 0x021b0810 0x001f001f
	mww 0x021b480c 0x00440044
	mww 0x021b4810 0x00440044
	mww 0x021b08b8 0x00000800
	mww 0x021b48b8 0x00000800
	mww 0x021b001c 0x00000000
	mww 0x021b0404 0x00011006
	mww 0x020c4068 0x00c03f3f
	mww 0x020c406c 0x0030fc03
	mww 0x020c4070 0x0fffc000
	mww 0x020c4074 0x3ff00000
	mww 0x020c4078 0x00fff300
	mww 0x020c407c 0x0f0000c3
	mww 0x020c4080 0x000003ff
	mww 0x020e0010 0xf00000cf
	mww 0x020e0018 0x007f007f
	mww 0x020e001c 0x007f007f
}

# disable watchdog
proc disable_wdog { } {
	mwh 0x020bc000 0x30
}

# This function applies the initial configuration after a "reset init"
# command
proc imx6q_sabresd_init { } {
	disable_wdog
	apply_dcd
}

# prevent cortex-a code from asserting SRST again
$_TARGETNAME.0 configure -event reset-assert { }
# hook the init function into the reset-init event
$_TARGETNAME.0 configure -event reset-init { imx6q_sabresd_init }
# set a slow default JTAG clock, can be overridden later
adapter speed 1000
#
# Glyn Tonga2 SO-DIMM CPU module (Toshiba TMPA900CMXBG, ARM9)
#
# http://toshiba-mikrocontroller.de/sites/TMPA900CPUBOARDStarter.htm
#
# Hardware on the S0-DIMM module:
#   - Toshiba TMPA900CMXBG (ARM9, ARM926EJ-S, max. 200MHz)
#   - DDR SDRAM: Hynix H5MS5162DFR-J3M (64Mbyte, x16, 1.8V, 166/83MHz at CL3/2)
#   - NAND flash: Samsung K9F2G08U0B-PIB0 (256M x 8 Bit, 3.3V)
#   - Ethernet: SMSC LAN9221I-ABZJ (10/100Mbit, Non-PCI, 16 bit interface)
#

source [find target/tmpa900.cfg]

########################
# Target configuration #
########################

# Initial JTAG speed should not exceed 1/6 of the initial CPU clock
# frequency (24MHz). Be conservative and use 1/8 of the frequency.
# (24MHz / 8 = 3MHz)
adapter speed 3000

$_TARGETNAME configure -event reset-start {
	# Upon reset, set the JTAG frequency to 3MHz again, see above.
	echo "Setting JTAG speed to 3MHz until clocks are initialized."
	adapter speed 3000

	# Halt the CPU.
	halt

	# Disable faster memory access for now.
	arm7_9 fast_memory_access disable
}

$_TARGETNAME configure -event reset-init {
	# Setup clocks, and initialize SRAM and DDR SDRAM.
	tonga2_init

	# At this point the CPU is running at 192MHz, increase JTAG speed.
	# Tests showed that 15MHz works OK, higher speeds can cause problems,
	# though. Not sure if this is a CPU issue or JTAG adapter issue.
	echo "Increasing JTAG speed to 15MHz."
	adapter speed 15000

	# Enable faster memory access.
	arm7_9 fast_memory_access enable
}

proc tonga2_init { } {
	######################
	# PLL initialization #
	######################

	# Clock overview (see datasheet chapter 3.5.2, page 57):
	#   - fs: Low-frequency oscillator
	#   - fOSCH: High-frequency oscillator (24MHz on this board)
	#   - fPLL = fOSCH * multiplier (where multiplier can be 6 or 8)
	#   - fFCLK = fPLL / gear (where gear can be 1/2/4/8)
	#   - fHCLK is always fFCLK/2. fPCLK is also fFCLK/2.
	#
	# We select multiplier = 8 and gear = 1, so
	#   fFCLK = fOSCH * 8 / 1 = 192MHz.

	# SYSCR3 (System Control Register 3): Disable and configure PLL.
	#   - PLL operation control: off
	#   - PLL constant value setting 1: always 0, as per datasheet
	#   - PLL constant value setting 2: x8 (multiplier = 8)
	mww 0xf005000c 0x00000007

	# SYSCR4 (System Control Register 4): Configure PLL.
	#   - PLL constant value setting 3: 140MHz or more
	#   - PLL constant value setting 4: always 1, as per datasheet
	#   - PLL constant value setting 5: 140MHz or more
	mww 0xf0050010 0x00000065

	# SYSCR3 (System Control Register 3): Enable PLL.
	#   - PLL operation control: on
	#   - All other bits remain set as above.
	mww 0xf005000c 0x00000087

	# Wait for PLL to stabilize.
	sleep 10

	# SYSCR2 (System Control Register 2): Switch from fOSCH to fPLL.
	#   - Selection of the PLL output clock: fPLL
	mww 0xf0050008 0x00000002

	# SYSCR1 (System Control Register 1):
	#   - Clock gear programming: fc/1 (i.e., gear = 1, don't divide).
	mww 0xf0050004 0x00000000

	# CLKCR5 (Clock Control Register 5): Set bits 3 and 6. The datasheet
	# says the bits are reserved, but also recommends "Write as one".
	mww 0xf0050054 0x00000048


	##############################################################
	# Dynamic Memory Controller (DMC) / DDR SDRAM initialization #
	##############################################################

	# PMC (Power Management Controller):
	# PMCDRV (External Port "Driverbility" control register):
	# Bits DRV_MEM0/DRV_MEM1 (memory relation port drive power):
	mww 0xf0020260 0x00000003	;# Select 1.8V +/- 0.1V

	# Setup DDR SDRAM timing parameters for our specific chip.
	mww 0xf4310014 0x00000004	;# cas_latency = 2
	mww 0xf4310018 0x00000001	;# t_dqss = 1
	mww 0xf431001c 0x00000002	;# t_mrd = 2
	mww 0xf4310020 0x0000000a	;# t_ras = 10
	mww 0xf4310024 0x0000000a	;# t_rc = 10
	mww 0xf4310028 0x00000013	;# t_rcd = 3, schedule_rcd = 2
	mww 0xf431002c 0x0000010a	;# t_rfc = 10, schedule_rfc = 8
	mww 0xf4310030 0x00000013	;# t_rp = 3, schedule_rp = 2
	mww 0xf4310034 0x00000002	;# t_rrd = 2
	mww 0xf4310038 0x00000002	;# t_wr = 2
	mww 0xf431003c 0x00000001	;# t_wtr = 1
	mww 0xf4310040 0x0000000a	;# t_xp = 10
	mww 0xf4310044 0x0000000c	;# t_xsr = 12
	mww 0xf4310048 0x00000014	;# t_esr = 20

	# dmc_memory_cfg_5 (DMC Memory Configuration register):
	# Set memory configuration:
	# column_bits = 10, row_bits = 13, ap-bit = 10, power_down_prd = 0,
	# auto_power_down = disable, stop_mem_clock = disable, memory_burst = 4
	mww 0xf431000c 0x00010012

	# dmc_user_config_5 (DMC user_config register):
	# Data bus width of DDR SDRAM: 16 bit
	mww 0xf4310304 0x00000058

	# dmc_refresh_prd_5 (DMC Refresh Period register):
	# Auto refresh: every 2656 (0xa60) DMCSCLK periods.
	mww 0xf4310010 0x00000a60

	# dmc_chip_0_cfg_5 (DMC chip_0_cfg registers):
	#   - SDRAM address structure: bank, row, column
	#   - address_match = 01000000 (start address [31:24])
	#   - address_mask  = 11111100 (start address [31:24] mask value)
	mww 0xf4310200 0x000140fc

	# Initialize the DDR SDRAM chip.
	# dmc_direct_cmd_5 (DMC Direct Command register).
	# See datasheet chapter 3.10.5.1, page 268.
	mww 0xf4310008 0x000c0000	;# RAM init: NOP
	mww 0xf4310008 0x00000000	;# RAM init: Precharge all
	mww 0xf4310008 0x00040000	;# RAM init: Autorefresh
	mww 0xf4310008 0x00040000	;# RAM init: Autorefresh
	mww 0xf4310008 0x00080032	;# RAM init: addr_13_to_0 = 0x32
	mww 0xf4310008 0x000c0000	;# RAM init: NOP
	mww 0xf4310008 0x000a0000	;# RAM init: bank_addr = bank 2

	# dmc_id_<0-5>_cfg_5 (DMC id_<0-5>_cfg registers):
	# Set min./max. QoS values.
	#   - 0x5: Enable QoS, max. QoS = 1
	#   - 0xb: Enable QoS, min. QoS = 2
	mww 0xf4310100 0x00000005	;# AHB0: CPU Data
	mww 0xf4310104 0x00000005	;# AHB1: CPU Inst
	mww 0xf4310108 0x0000000b	;# AHB2: LCDC
	mww 0xf431010c 0x00000005	;# AHB3: LCDDA, USB
	mww 0xf4310110 0x00000005	;# AHB4: DMA1
	mww 0xf4310114 0x00000005	;# AHB5: DMA2

	# dmc_memc_cmd_5 (DMC Memory Controller Command register):
	# Change DMC state to ready.
	mww 0xf4310004 0x00000000	;# memc_cmd = "Go"

	# EBI: SMC Timeout register
	mww 0xf00a0050 0x00000001	;# smc_timeout = 1


	########################################################
	# Static Memory Controller (SMC) / SRAM initialization #
	########################################################

	# smc_set_cycles_5 (SMC Set Cycles register):
	# tRC = 10, tWC = 10, tCEOE = 7, tWP = 5, tPC=2, tTR=2
	mww 0xf4311014 0x0004afaa

	# smc_set_opmode_5 (SMC Set Opmode register):
	# Memory data bus width = 16 bits, async read mode, read burst
	# length = 1 beat, async write mode, write burst length = 1 beat,
	# byte enable (SMCBE0-1) timing = SMCCSn timing, memory burst boundary
	# split setting = burst can cross any address boundary
	mww 0xf4311018 0x00000001

	# smc_direct_cmd_5 (SMC Direct Command register):
	# cmd_type = UpdateRegs, chip_select = CS1
	mww 0xf4311010 0x00c00000

	echo "Clocks, SRAM, and DDR SDRAM are now initialized."
}

#######################
# Flash configuration #
#######################

# TODO: Implement NAND support.
# config for ESPRESSObin from
# Globalscale Technologies Inc.

# srst is isolated through missing resistor
reset_config trst_only

source [find target/marvell/88f3720.cfg]
# JTAG for the STM32F4x chip used on the Gumstix AeroCore is available on
# the first interface of a Quad FTDI chip.  nTRST is bit 4.
adapter driver ftdi
ftdi_vid_pid 0x0403 0x6011

ftdi_layout_init 0x0000 0x001b
ftdi_layout_signal nTRST -data 0x0010

source [find target/stm32f4x.cfg]
reset_config trst_only
# Target Configuration for the TinCanTools S3C2410 Based Hammer Module
# http://www.tincantools.com

source [find target/samsung_s3c2410.cfg]

$_TARGETNAME configure -event reset-init {
	# Reset Script for the TinCanTools S3C2410 Based Hammer Module
	# http://www.tincantools.com
	#
	# Setup primary clocks and initialize the SDRAM
	mww 0x53000000 0x00000000
	mww 0x4a000008 0xffffffff
	mww 0x4a00000c 0x000007ff
	mww 0x4c000000 0x00ffffff
	mww 0x4c000014 0x00000003
	mww 0x4c000004 0x000a1031
	mww 0x48000000 0x11111122
	mww 0x48000004 0x00000700
	mww 0x48000008 0x00000700
	mww 0x4800000c 0x00000700
	mww 0x48000010 0x00000700
	mww 0x48000014 0x00000700
	mww 0x48000018 0x00000700
	mww 0x4800001c 0x00018005
	mww 0x48000020 0x00018005
	mww 0x48000024 0x009c0459
	mww 0x48000028 0x000000b2
	mww 0x4800002c 0x00000030
	mww 0x48000030 0x00000030
	flash probe 0
}


#flash configuration
#flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target> [driver_options ...]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x1000000 2 2 $_TARGETNAME
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx500.cfg]

reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
  halt

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads enable

  sdram_fix

  puts "Configuring SDRAM controller for paired K4S561632C (64MB) "
  mww 0x00100140 0
  mww 0x00100144 0x03C13261
  mww 0x00100140 0x030D0121

  puts "Configuring SRAM nCS0 for 150ns paired Par. Flash (x32)"
  mww 0x00100100 0x0201000E

  flash probe 0
}

#####################
# Flash configuration
#####################

#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
flash bank parflash cfi 0xC0000000 0x02000000 4 4 $_TARGETNAME

init
reset init
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx500.cfg]

reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
  halt

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads disable

  sdram_fix

  puts "Configuring SDRAM controller for MT48LC8M32 (32MB) "
  mww 0x00100140 0
  mww 0x00100144 0x03C23251
  mww 0x00100140 0x030D0111

  puts "Configuring SRAM nCS0 for 150ns Par. Flash (x16)"
  mww 0x00100100 0x0101000E

  flash probe 0
}

#####################
# Flash configuration
#####################

#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME

init
reset init
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx10.cfg]

# Usually it is not needed to set srst_pulls_trst
# but sometimes it does not work without it. If you encounter
# problems try to line below
# reset_config trst_and_srst srst_pulls_trst
reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x08000000 -work-area-phys 0x08000000 -work-area-size 0x4000 -work-area-backup 1

# Par. Flash can only be accessed if DIP switch on the board is set in proper
# position and init_sdrambus was called. Don't call these functions if the DIP
# switch is in invalid position, as some outputs may collide. This is why this
# function is not called automatically
proc flash_init { } {
  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
  mww 0x101C0100 0x01010008

  flash probe 0
}

proc mread32 {addr} {
  set value(0) 0
  mem2array value 32 $addr 1
  return $value(0)
}

proc init_clocks { } {
  puts "Enabling all clocks "
  set accesskey [mread32 0x101c0070]
  mww  0x101c0070 [expr $accesskey]

  mww  0x101c0028 0x00007511
}

proc init_sdrambus { } {
  puts "Initializing external SDRAM Bus 16 Bit "
  set accesskey [mread32 0x101c0070]
  mww  0x101c0070 [expr $accesskey]
  mww  0x101c0C40 0x00000050

  puts "Configuring SDRAM controller for K4S561632E (32MB) "
  mww 0x101C0140 0
  sleep 100
  #mww 0x101C0144 0x00a13262
  mww 0x101C0144 0x00a13251
  mww 0x101C0148 0x00000033
  mww 0x101C0140 0x030d0121
}

$_TARGETNAME configure -event reset-init {
  halt
  wait_halt 1000

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads enable

  init_clocks
#  init_sdrambus

  puts ""
  puts "-------------------------------------------------"
  puts "Call 'init_clocks' to enable all clocks"
  puts "Call 'init_sdrambus' to enable external SDRAM bus"
  puts "-------------------------------------------------"
}

#####################
# Flash configuration
#####################

#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
#flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME

init
reset init
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx50.cfg]

reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x10000000 -work-area-phys 0x10000000 -work-area-size 0x4000 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
  halt

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads enable

  sdram_fix

  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
  mww 0x1C000140 0
  mww 0x1C000144 0x00A12151
  mww 0x1C000140 0x030D0001

  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
  mww 0x1C000100 0x01010008

  flash probe 0
}

#####################
# Flash configuration
#####################

#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME

init
reset init
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx500.cfg]

reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
  halt

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads enable

  sleep 100

  sdram_fix

  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
  mww 0x00100140 0
  mww 0x00100144 0x03C23251
  mww 0x00100140 0x030D0001

  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
  mww 0x00100100 0x01010008

  flash probe 0
}

#####################
# Flash configuration
#####################

#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME

init
reset init
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

source [find target/hilscher_netx500.cfg]

reset_config trst_and_srst
adapter srst delay 500
jtag_ntrst_delay 500

$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
  halt

  arm7_9 fast_memory_access enable
  arm7_9 dcc_downloads enable

  sdram_fix

  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
  mww 0x00100140 0
  mww 0x00100144 0x03C23251
  mww 0x00100140 0x030D0001

}

init
reset init
# Hitex LPC1768 Stick
#
# http://www.hitex.com/?id=1602
#

reset_config trst_and_srst

source [find interface/ftdi/hitex_lpc1768stick.cfg]

source [find target/lpc17xx.cfg]


# startup @ 500kHz
adapter speed 500
# Hitex eval board for LPC2929/LPC2939
# http://www.hitex.com/

# Delays on reset lines
adapter srst delay 50
jtag_ntrst_delay 1

# Maximum of 1/8 of clock frequency (XTAL = 16 MHz).
# Adaptive clocking through RTCK is not supported.
adapter speed 2000

# Target device: LPC29xx with ETB
# The following variables are used by the LPC2900 script:
#   HAS_ETB             Must be set to 1. The CPU on this board has ETB.
#   FLASH_CLOCK         CPU frequency at the time of flash programming (in kHz)
set HAS_ETB             1
set FLASH_CLOCK         112000
source [find target/lpc2900.cfg]

# A working area will help speeding the flash programming
#$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x2000 -work-area-backup 0
$_TARGETNAME configure -work-area-phys 0x58000000 -work-area-size 0x10000 -work-area-backup 0

# Event handlers
$_TARGETNAME configure -event reset-start {
  # Back to the slow JTAG clock
  adapter speed 2000
}

# External 16-bit flash at chip select CS7 (SST39VF3201-70, 4 MiB)
set _FLASHNAME $_CHIPNAME.extflash
flash bank $_FLASHNAME cfi 0x5C000000 0x400000 2 2 $_TARGETNAME jedec_probe


$_TARGETNAME configure -event reset-init {
  # Flash
  mww 0x20200010 0x00000007     ;# FBWST: 7 wait states, not chached

  # Use PLL
  mww 0xFFFF8020 0x00000001     ;# XTAL_OSC_CONTROL: enable, 1-20 MHz
  mww 0xFFFF8070 0x01000000     ;# SYS_CLK_CONF: Crystal
  mww 0xFFFF8028 0x00000005     ;# PLL: (power down)
  mww 0xFFFF8028 0x01060004     ;# PLL: M=7, 2P=2 (power up)
                                 # --> f=112 MHz, fcco=224 MHz
  sleep 100
  mww 0xFFFF8070 0x02000000     ;# SYS_CLK_CONF: PLL

  # Increase JTAG speed
  adapter speed 6000

  # Enable external memory bus (16-bit SRAM at CS6, 16-bit flash at CS7)
  mww 0xE0001138 0x0000001F     ;# P1.14 = D0
  mww 0xE000113C 0x0000001F     ;# P1.15 = D1
  mww 0xE0001140 0x0000001F     ;# P1.16 = D2
  mww 0xE0001144 0x0000001F     ;# P1.17 = D3
  mww 0xE0001148 0x0000001F     ;# P1.18 = D4
  mww 0xE000114C 0x0000001F     ;# P1.19 = D5
  mww 0xE0001150 0x0000001F     ;# P1.20 = D6
  mww 0xE0001154 0x0000001F     ;# P1.21 = D7
  mww 0xE0001200 0x0000001F     ;# P2.0  = D8
  mww 0xE0001204 0x0000001F     ;# P2.1  = D9
  mww 0xE0001208 0x0000001F     ;# P2.2  = D10
  mww 0xE000120C 0x0000001F     ;# P2.3  = D11
  mww 0xE0001210 0x0000001F     ;# P2.4  = D12
  mww 0xE0001214 0x0000001F     ;# P2.5  = D13
  mww 0xE0001218 0x0000001F     ;# P2.6  = D14
  mww 0xE000121C 0x0000001F     ;# P2.7  = D15
  mww 0xE0001104 0x00000007     ;# P1.1  = A1
  mww 0xE0001108 0x00000007     ;# P1.2  = A2
  mww 0xE000110C 0x00000007     ;# P1.3  = A3
  mww 0xE0001110 0x00000007     ;# P1.4  = A4
  mww 0xE0001114 0x00000007     ;# P1.5  = A5
  mww 0xE0001118 0x00000007     ;# P1.6  = A6
  mww 0xE000111C 0x00000007     ;# P1.7  = A7
  mww 0xE0001028 0x00000007     ;# P0.10 = A8
  mww 0xE000102C 0x00000007     ;# P0.11 = A9
  mww 0xE0001030 0x00000007     ;# P0.12 = A10
  mww 0xE0001034 0x00000007     ;# P0.13 = A11
  mww 0xE0001038 0x00000007     ;# P0.14 = A12
  mww 0xE000103C 0x00000007     ;# P0.15 = A13
  mww 0xE0001048 0x00000007     ;# P0.18 = A14
  mww 0xE000104C 0x00000007     ;# P0.19 = A15
  mww 0xE0001050 0x00000007     ;# P0.20 = A16
  mww 0xE0001054 0x00000007     ;# P0.21 = A17
  mww 0xE0001058 0x00000007     ;# P0.22 = A18
  mww 0xE000105C 0x00000007     ;# P0.23 = A19
  mww 0xE0001238 0x00000007     ;# P2.14 = BLS0
  mww 0xE000123C 0x00000007     ;# P2.15 = BLS1
  mww 0xE0001300 0x00000007     ;# P3.0  = CS6
  mww 0xE0001304 0x00000007     ;# P3.1  = CS7
  mww 0xE0001130 0x00000007     ;# P1.12 = OE_N
  mww 0xE0001134 0x00000007     ;# P1.13 = WE_N
  mww 0x600000BC 0x00000041     ;# Bank6 16-bit mode, RBLE=1
  mww 0x600000B4 0x00000000     ;# Bank6 WSTOEN=0
  mww 0x600000AC 0x00000005     ;# Bank6 WST1=5
  mww 0x600000B8 0x00000001     ;# Bank6 WSTWEN=1
  mww 0x600000B0 0x00000006     ;# Bank6 WST2=6
  mww 0x600000A8 0x00000002     ;# Bank6 IDCY=2
  mww 0x600000D8 0x00000041     ;# Bank7 16-bit mode, RBLE=1
  mww 0x600000D0 0x00000000     ;# Bank7 WSTOEN=0
  mww 0x600000C8 0x0000000A     ;# Bank7 WST1=10
  mww 0x600000D4 0x00000001     ;# Bank7 WSTWEN=1
  mww 0x600000CC 0x0000000C     ;# Bank7 WST2=8
  mww 0x600000C4 0x00000002     ;# Bank7 IDCY=2
}
# Hitex stm32 performance stick

reset_config trst_and_srst

source [find interface/ftdi/stm32-stick.cfg]

set  CHIPNAME stm32_hitex
source [find target/stm32f1x.cfg]

# configure str750 connected to jtag chain
# FIXME -- source [find target/str750.cfg] after cleaning that up
jtag newtap str750 cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id 0x4f1f0041

# for some reason this board like to startup @ 500kHz
adapter speed 500
# Hitex STR9-comStick
# http://www.hitex.com/index.php?id=383
# This works for the STR9-comStick revisions STR912CS-A1 and STR912CS-A2.

source [find interface/ftdi/hitex_str9-comstick.cfg]

# set jtag speed
adapter speed 3000

adapter srst delay 100
jtag_ntrst_delay 100
#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst

#
# FIXME use the standard str912 target config; that script might need
# updating to "-ignore-version" for the boundary scan TAP
#
#	source [find target/str912.cfg]
#

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME str912
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists FLASHTAPID] } {
   set _FLASHTAPID $FLASHTAPID
} else {
   set _FLASHTAPID 0x04570041
}
jtag newtap $_CHIPNAME flash -irlen 8 -ircapture 0x1 -irmask 0x1 -expected-id $_FLASHTAPID

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x25966041
}
jtag newtap $_CHIPNAME cpu   -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

if { [info exists BSTAPID] } {
   set _BSTAPID $BSTAPID
} else {
   # Found on STR9-comStick, revision STR912CS-A1
   set _BSTAPID1 0x1457f041
   # Found on STR9-comStick, revision STR912CS-A2
   set _BSTAPID2 0x2457f041
}
jtag newtap $_CHIPNAME bs -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID1 -expected-id $_BSTAPID2

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-init {
	# We can increase speed now that we know the target is halted.
	#jtag_rclk 3000

	# -- Enable 96K RAM
	# PFQBC enabled / DTCM & AHB wait-states disabled
	mww 0x5C002034 0x0191

	str9x flash_config 0 4 2 0 0x80000
	flash protect 0 0 7 off
}

$_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 0

#flash bank <driver> <base> <size> <chip_width> <bus_width>
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
# Board from IAR KickStart Kit for LPC1768
# See www.iar.com and also
# http://www.olimex.com/dev/lpc-1766stk.html
#

source [find target/lpc17xx.cfg]

# The chip has just been reset.
#
$_TARGETNAME configure -event reset-init {
	# FIXME update the core clock to run at 100 MHz;
	# and update JTAG clocking similarly; then
	# make CCLK match,

	flash probe 0
}
# The IAR str912-sk evaluation kick start board has an str912

source [find target/str912.cfg]
#################################################################################################
# Author: Benjamin Tietz <benjamin.tietz@in-circuit.de>                                        ;#
# based on work from: Wjatscheslaw Stoljarski (Slawa) <wjatscheslaw.stoljarski@kiwigrid.com>   ;#
# Kiwigrid GmbH                                                                                ;#
# Generated for In-Circuit i.MX53 SO-Dimm                                                      ;#
#################################################################################################

# The In-Circuit ICnova IMX53SODIMM board has a single IMX53 chip
source [find target/imx53.cfg]
# Helper for common memory read/modify/write procedures
source [find mem_helper.tcl]

echo "i.MX53 SO-Dimm board lodaded."

# Set reset type
#reset_config srst_only

adapter speed 3000

# Slow speed to be sure it will work
jtag_rclk 1000
$_TARGETNAME configure -event "reset-start" { jtag_rclk 1000 }

$_TARGETNAME configure -event "reset-assert" {
	echo "Resetting ...."
	#cortex_a dbginit
}

$_TARGETNAME configure -event reset-init { sodimm_init }

global AIPS1_BASE_ADDR
set AIPS1_BASE_ADDR     0x53F00000
global AIPS2_BASE_ADDR
set AIPS2_BASE_ADDR     0x63F00000

proc sodimm_init { } {
	echo "Reset-init..."
	; # halt the CPU
	halt

	echo "HW version [format %x [mrw 0x48]]"

	dap apsel 1
	DCD

	; # ARM errata ID #468414
	set tR [arm mrc 15 0 1 0 1]
	arm mcr 15 0 1 0 1 [expr $tR | (1<<5)]	; # enable L1NEON bit

	init_l2cc
	init_aips
	init_clock

	dap apsel 0

	; # Force ARM state
	; #reg cpsr 0x000001D3
	arm core_state arm

	jtag_rclk 3000
#	adapter speed 3000
}


# L2CC Cache setup/invalidation/disable
proc init_l2cc { } {
	; #/* explicitly disable L2 cache */
	; #mrc 15, 0, r0, c1, c0, 1
	set tR [arm mrc 15 0 1 0 1]
	; #bic r0, r0, #0x2
	; #mcr 15, 0, r0, c1, c0, 1
	arm mcr 15 0 1 0 1 [expr $tR & ~(1<<2)]

	; #/* reconfigure L2 cache aux control reg */
	; #mov r0, #0xC0                   /* tag RAM */
	; #add r0, r0, #0x4                /* data RAM */
	; #orr r0, r0, #(1 << 24)          /* disable write allocate delay */
	; #orr r0, r0, #(1 << 23)          /* disable write allocate combine */
	; #orr r0, r0, #(1 << 22)          /* disable write allocate */

	; #mcr 15, 1, r0, c9, c0, 2
	arm mcr 15 1 9 0 2 [expr 0xC4 | (1<<24) | (1<<23) | (1<22)]
}


# AIPS setup - Only setup MPROTx registers.
# The PACR default values are good.
proc init_aips { } {
	; # Set all MPROTx to be non-bufferable, trusted for R/W,
	; # not forced to user-mode.
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set VAL			0x77777777

#	dap apsel 1
	mww [expr $AIPS1_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS1_BASE_ADDR + 0x4] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x4] $VAL
#	dap apsel 0
}


proc init_clock { } {
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set CCM_BASE_ADDR	[expr $AIPS1_BASE_ADDR + 0x000D4000]
	set CLKCTL_CCSR         0x0C
	set CLKCTL_CBCDR	0x14
	set CLKCTL_CBCMR        0x18
	set PLL1_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00080000]
	set PLL2_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00084000]
	set PLL3_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00088000]
	set PLL4_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x0008C000]
	set CLKCTL_CSCMR1	0x1C
	set CLKCTL_CDHIPR	0x48
	set PLATFORM_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x000A0000]
	set CLKCTL_CSCDR1	0x24
	set CLKCTL_CCDR		0x04

	; # Switch ARM to step clock
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x4

	return
	echo "not returned"
	setup_pll $PLL1_BASE_ADDR 800
	setup_pll $PLL3_BASE_ADDR 400

	; # Switch peripheral to PLL3
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00015154
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x02888945 | (1<<16)]
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL2_BASE_ADDR 400

	; # Switch peripheral to PLL2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x00808145 | (2<<10) | (9<<16) | (1<<19)]

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00016154

	; # change uart clk parent to pll2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1]] & 0xfcffffff | 0x01000000]

	; # make sure change is effective
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL3_BASE_ADDR 216

	setup_pll $PLL4_BASE_ADDR 455

	; # Set the platform clock dividers
	mww [expr $PLATFORM_BASE_ADDR + 0x14] 0x00000124

	mww [expr $CCM_BASE_ADDR + 0x10] 0

	; # Switch ARM back to PLL 1.
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x0

	; # make uart div=6
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1]] & 0xffffffc0 | 0x0a]

	; # Restore the default values in the Gate registers
	mww [expr $CCM_BASE_ADDR + 0x68] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x6C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x70] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x74] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x78] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x7C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x80] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x84] 0xFFFFFFFF

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCDR] 0x00000

	; # for cko - for ARM div by 8
	mww [expr $CCM_BASE_ADDR + 0x60] [expr 0x000A0000 & 0x00000F0]
}


proc setup_pll { PLL_ADDR CLK } {
	set PLL_DP_CTL		0x00
	set PLL_DP_CONFIG   	0x04
	set PLL_DP_OP		0x08
	set PLL_DP_HFS_OP	0x1C
	set PLL_DP_MFD		0x0C
	set PLL_DP_HFS_MFD	0x20
	set PLL_DP_MFN		0x10
	set PLL_DP_HFS_MFN	0x24

	if {$CLK == 1000} {
		set DP_OP	[expr (10 << 4) + ((1 - 1) << 0)]
		set DP_MFD	[expr (12 - 1)]
		set DP_MFN	5
	} elseif {$CLK == 850} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	41
	} elseif {$CLK == 800} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 700} {
		set DP_OP	[expr (7 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	7
	} elseif {$CLK == 600} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 665} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (96 - 1)]
		set DP_MFN	89
	} elseif {$CLK == 532} {
		set DP_OP	[expr (5 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	13
	} elseif {$CLK == 455} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	71
	} elseif {$CLK == 400} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 216} {
		set DP_OP	[expr (6 << 4) + ((3 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	3
	} else {
		error "Error (setup_dll): clock not found!"
	}

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	mww [expr $PLL_ADDR + $PLL_DP_CONFIG] 0x2

	mww [expr $PLL_ADDR + $PLL_DP_OP] $DP_OP
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_OP

	mww [expr $PLL_ADDR + $PLL_DP_MFD] $DP_MFD
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_MFD

	mww [expr $PLL_ADDR + $PLL_DP_MFN] $DP_MFN
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFN] $DP_MFN

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	while {[expr [mrw [expr $PLL_ADDR + $PLL_DP_CTL]] & 0x1] == 0} { sleep 1 }
}


proc CPU_2_BE_32 { L } {
	return [expr (($L & 0x000000FF) << 24) | (($L & 0x0000FF00) << 8) | (($L & 0x00FF0000) >> 8)  | (($L & 0xFF000000) >> 24)]
}


# Device Configuration Data
proc DCD { } {
#	dap apsel 1
#*========================================================================================== ======
# Initialization script for 32 bit DDR3 (CS0+CS1)
#*========================================================================================== ======
# Remux D24/D25 to perform Flash-access
	mww 0x53fa818C 0x00000000 ; #EIM_RW
	mww 0x53fa8180 0x00000000 ; #EIM_CS0
	mww 0x53fa8188 0x00000000 ; #EIM_OE
	mww 0x53fa817C 0x00000000 ; #A16
	mww 0x53fa8178 0x00000000 ; #A17
	mww 0x53fa8174 0x00000000 ; #A18
	mww 0x53fa8170 0x00000000 ; #A19
	mww 0x53fa816C 0x00000000 ; #A20
	mww 0x53fa8168 0x00000000 ; #A21
	mww 0x53fa819C 0x00000000 ; #DA0
	mww 0x53fa81A0 0x00000000 ; #DA1
	mww 0x53fa81A4 0x00000000 ; #DA2
	mww 0x53fa81A8 0x00000000 ; #DA3
	mww 0x53fa81AC 0x00000000 ; #DA4
	mww 0x53fa81B0 0x00000000 ; #DA5
	mww 0x53fa81B4 0x00000000 ; #DA6
	mww 0x53fa81B8 0x00000000 ; #DA7
	mww 0x53fa81BC 0x00000000 ; #DA8
	mww 0x53fa81C0 0x00000000 ; #DA9
	mww 0x53fa81C4 0x00000000 ; #DA10
	mww 0x53fa81C8 0x00000000 ; #DA11
	mww 0x53fa81CC 0x00000000 ; #DA12
	mww 0x53fa81D0 0x00000000 ; #DA13
	mww 0x53fa81D4 0x00000000 ; #DA14
	mww 0x53fa81D8 0x00000000 ; #DA15
	mww 0x53fa8118 0x00000000 ; #D16
	mww 0x53fa811C 0x00000000 ; #D17
	mww 0x53fa8120 0x00000000 ; #D18
	mww 0x53fa8124 0x00000000 ; #D19
	mww 0x53fa8128 0x00000000 ; #D20
	mww 0x53fa812C 0x00000000 ; #D21
	mww 0x53fa8130 0x00000000 ; #D22
	mww 0x53fa8134 0x00000000 ; #D23
	mww 0x53fa813c 0x00000000 ; #IOMUXC_SW_PAD_CTL_PAD_EIM_D24
	mww 0x53fa8140 0x00000000 ; #IOMUXC_SW_PAD_CTL_PAD_EIM_D25
	mww 0x53fa8144 0x00000000 ; #D26
	mww 0x53fa8148 0x00000000 ; #D27
	mww 0x53fa814C 0x00000000 ; #D28
	mww 0x53fa8150 0x00000000 ; #D29
	mww 0x53fa8154 0x00000000 ; #D30
	mww 0x53fa8158 0x00000000 ; #D31

# DDR3 IOMUX configuration
#* Global pad control options */
	mww 0x53fa8554 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
	mww 0x53fa8558 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3
	mww 0x53fa8560 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
	mww 0x53fa8564 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
	mww 0x53fa8568 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2
	mww 0x53fa8570 0x00200000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - boazp: weaker sdclk EVK DDR max frequency
	mww 0x53fa8574 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
	mww 0x53fa8578 0x00200000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - boazp: weaker sdclk EVK DDR max frequency
	mww 0x53fa857c 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0
	mww 0x53fa8580 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
	mww 0x53fa8584 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
	mww 0x53fa8588 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
	mww 0x53fa8590 0x00380040 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1
	mww 0x53fa8594 0x00380000 ; #IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
	mww 0x53fa86f0 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_ADDDS
	mww 0x53fa86f4 0x00000200 ; #IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL
	mww 0x53fa86fc 0x00000000 ; #IOMUXC_SW_PAD_CTL_GRP_DDRPKE
#	mww 0x53fa8714 0x00000200 ; #IOMUXC_SW_PAD_CTL_GRP_DDRMODE - CMOS mode XXX
	mww 0x53fa8714 0x00000000 ; #IOMUXC_SW_PAD_CTL_GRP_DDRMODE - CMOS mode XXX
	mww 0x53fa8718 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_B0DS
	mww 0x53fa871c 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_B1DS
	mww 0x53fa8720 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_CTLDS
	mww 0x53fa8724 0x00000000 ; #IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=0 XXX
	mww 0x53fa8728 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_B2DS
	mww 0x53fa872c 0x00380000 ; #IOMUXC_SW_PAD_CTL_GRP_B3DS
#	mww 0x53fa86f4 0x00000000 ;IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL for sDQS[3:0], 1=DDR2, 0=CMOS mode
#	mww 0x53fa8714 0x00000000 ;IOMUXC_SW_PAD_CTL_GRP_DDRMODE for D[31:0], 1=DDR2, 0=CMOS mode
#	mww 0x53fa86fc 0x00000000 ;IOMUXC_SW_PAD_CTL_GRP_DDRPKE
#	mww 0x53fa8724 0x00000000 ;IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=00

#* Data bus byte lane pad drive strength control options */
#	mww 0x53fa872c 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_B3DS
#	mww 0x53fa8554 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
#	mww 0x53fa8558 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3
#	mww 0x53fa8728 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_B2DS
#	mww 0x53fa8560 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
#	mww 0x53fa8568 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2
#	mww 0x53fa871c 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_B1DS
#	mww 0x53fa8594 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
#	mww 0x53fa8590 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1
#	mww 0x53fa8718 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_B0DS
#	mww 0x53fa8584 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
#	mww 0x53fa857c 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0

#* SDCLK pad drive strength control options */
#	mww 0x53fa8578 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
#	mww 0x53fa8570 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1

#* Control and addr bus pad drive strength control options */
#	mww 0x53fa8574 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
#	mww 0x53fa8588 0x00300000 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
#	mww 0x53fa86f0 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_ADDDS for DDR addr bus
#	mww 0x53fa8720 0x00300000 ;IOMUXC_SW_PAD_CTL_GRP_CTLDS for CSD0, CSD1, SDCKE0, SDCKE1, SDWE

#	mww 0x53fa8564 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
#	mww 0x53fa8580 0x00300040 ;IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0

# Initialize DDR3 memory - Micron MT41J128M16-187Er
#** Keep for now, same setting as CPU3 board **#
	mww 0x63fd901c 0x00008000
#	mww 0x63fd904c 0x01680172 ; #write leveling reg 0
#	mww 0x63fd9050 0x0021017f ; #write leveling reg 1
	mww 0x63fd9088 0x32383535 ; #read delay lines
	mww 0x63fd9090 0x40383538 ; #write delay lines
#	mww 0x63fd90F8 0x00000800 ; #Measure unit
	mww 0x63fd907c 0x0136014d ; #DQS gating 0
	mww 0x63fd9080 0x01510141 ; #DQS gating 1
#* CPU3 Board settingr
# Enable bank interleaving, Address mirror on, WALAT 0x1, RALAT = 0x5, DDR2_EN = 0
#	mww 0x63fd9018 0x00091740 ; #Misc register:
#* Quick Silver board setting
# Enable bank interleaving, Address mirror off, WALAT 0x1, RALAT = 0x5, DDR2_EN = 0
	mww 0x63fd9018 0x00011740 ; #Misc register

# Enable CSD0 and CSD1, row width = 14, column width = 10, burst length = 8, data width = 32bit
#	mww 0x63fd9000 0xc3190000 ; #Main control register
# Enable CSD0 and CSD1, row width = 14, column width = 10, burst length = 8, data width = 32bit
	mww 0x63fd9000 0x83190000 ; #Main control register
# tRFC=64ck;tXS=68;tXP=3;tXPDLL=10;tFAW=15;CAS=6ck
	mww 0x63fd900C 0x555952E3 ; #timing configuration Reg 0
# tRCD=6;tRP=6;tRC=21;tRAS=15;tRPA=1;tWR=6;tMRD=4;tCWL=5ck
	mww 0x63fd9010 0xb68e8b63 ; #timing configuration Reg 1
# tDLLK(tXSRD)=512 cycles; tRTP=4;tWTR=4;tRRD=4
	mww 0x63fd9014 0x01ff00db ; #timing configuration Reg 2
	mww 0x63fd902c 0x000026d2 ; #command delay (default)
	mww 0x63fd9030 0x009f0e21 ; #out of reset delays
# Keep tAOFPD, tAONPD, tANPD, and tAXPD as default since they are bigger than calc values
	mww 0x63fd9008 0x12273030 ; #ODT timings
# tCKE=3; tCKSRX=5; tCKSRE=5
	mww 0x63fd9004 0x0002002d
#Power down control
#**********************************
#DDR device configuration:
#**********************************
#**********************************
# CS0:
#**********************************
	mww 0x63fd901c 0x00008032 ; #write mode reg MR2 with cs0 (see below for settings)
# Full array self refresh
# Rtt_WR disabled (no ODT at IO CMOS operation)
# Manual self refresh
# CWS=5
	mww 0x63fd901c 0x00008033 ; #write mode reg MR3 with cs0.
	mww 0x63fd901c 0x00028031 ; #write mode reg MR1 with cs0. ODS=01: out buff= RZQ/7 (see below for settings)
# out impedance = RZQ/7
# Rtt_nom disabled (no ODT at IO CMOS operation)
# Aditive latency off
# write leveling disabled
# tdqs (differential?) disabled

	mww 0x63fd901c 0x09208030 ; #write mode reg MR0 with cs0 , with dll_rst0
	mww 0x63fd901c 0x04008040 ; #ZQ calibration with cs0 (A10 high indicates ZQ cal long ZQCL)
#**********************************
# CS1:
#**********************************
#	mww 0x63fd901c 0x0000803a ; #write mode reg MR2 with cs1.
#	mww 0x63fd901c 0x0000803b ; #write mode reg MR3 with cs1.
#	mww 0x63fd901c 0x00028039 ; #write mode reg MR1 with cs1. ODS=01: out buff= RZQ/7
#	mww 0x63fd901c 0x09208138 ; #write mode reg MR0 with cs1.
#	mww 0x63fd901c 0x04008048 ; #ZQ calibration with cs1(A10 high indicates ZQ cal long ZQCL)
#**********************************


	mww 0x63fd9020 0x00001800 ; # Refresh control register
	mww 0x63fd9040 0x04b80003 ; # ZQ HW control
	mww 0x63fd9058 0x00022227 ; # ODT control register

	mww 0x63fd901c 0x00000000

# CLKO muxing (comment out for now till needed to avoid conflicts with intended usage of signals)
#	mww 0x53FA8314 = 0
#	mww 0x53FA8320 0x4
#	mww 0x53FD4060 0x01e900f0

#	dap apsel 0
}

# IRAM
$_TARGETNAME configure -work-area-phys 0xF8000000 -work-area-size 0x20000 -work-area-backup 1

flash bank mx535_nor cfi 0xf0000000 0x800000 2 2 $_TARGETNAME

# vim:filetype=tcl
#################################################################################################
#												                                                #
# Author: Lars Poeschel (larsi@wh2.tu-dresden.de)												#
# Generated for In-Circuit ICnova SAM9G45 SODIMM												#
# http://www.ic-board.de/product_info.php?info=p214_ICnova-SAM9G45-SODIMM.html|ICnova			#
#																								#
#################################################################################################

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

source [find target/at91sam9g45.cfg]

# Set reset type.
# reset_config trst_and_srst

# adapter srst delay 200
# jtag_ntrst_delay 200


# If you don't want to execute built-in boot rom code (and there are good reasons at times not to do that) in the
# AT91SAM9 family, the microcontroller is a lump on a log without initialization.  Because this family has
# some powerful features, we want to have a special function that handles "reset init".  To do this we declare
# an event handler where these special activities can take place.

scan_chain
$_TARGETNAME configure -event reset-init {at91sam9g45_init}

# Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).
# Slow-speed oscillator enabled at reset, so run jtag speed slow.
$_TARGETNAME configure -event reset-start {at91sam9g45_start}


# NandFlash configuration and definition
# Future TBD
# Flash configuration
# flash bank cfi <base> <size> <chip width> <bus width> <target#>
set _FLASHNAME $_CHIPNAME.flash
# set _NANDNAME $_CHIPNAME.nand
flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME
# nand device $_NANDNAME at91sam9 $_TARGETNAME 0x40000000 0xFFFFE800


proc read_register {register} {
        set result ""
        mem2array result 32 $register 1
        return $result(0)
}

proc at91sam9g45_start { } {

	# Make sure that the the jtag is running slow, since there are a number of different ways the board
	# can be configured coming into this state that can cause communication problems with the jtag
	# adapter.  Also since this call can be made following a "reset init" where fast memory accesses
	# are enabled, need to temporarily shut this down so that the RSTC_MR register can be written at slower
	# jtag speed without causing GDB keep alive problem.

	arm7_9 fast_memory_access disable
    # Slow-speed oscillator enabled at reset, so run jtag speed slow.
	adapter speed 4
    # Make sure processor is halted, or error will result in following steps.
	halt
	wait_halt 10000
    # RSTC_MR : enable user reset.
	mww 0xfffffd08 0xa5000501
}


proc at91sam9g45_init { } {

	# At reset AT91SAM9G45 chip runs on slow clock (32.768 kHz).  To shift over to a normal clock requires
	# a number of steps that must be carefully performed.  The process outline below follows the
	# recommended procedure outlined in the AT91SAM9G45 technical manual.
	#
	# Several key and very important things to keep in mind:
	# The SDRAM parts used currently on the board are -75 grade parts.  This
	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.

	# Make sure processor is halted, or error will result in following steps.
	halt
	# RSTC_MR : enable user reset.
	mww 0xfffffd08 0xa5000501
	# WDT_MR : disable watchdog.
	mww 0xfffffd44 0x00008000

	# Enable the main 15.000 MHz oscillator in CKGR_MOR register.
	# Wait for MOSCS in PMC_SR to assert indicating oscillator is again stable after change to CKGR_MOR.

	mww 0xfffffc20 0x00004001
	while { [expr [read_register 0xfffffc68] & 0x01] != 1 } { sleep 1 }

	# Set PLLA Register for 792.576 MHz (divider: bypass, multiplier: 43).
	# Wait for LOCKA signal in PMC_SR to assert indicating PLLA is stable.

	#mww 0xfffffc28 0x202a3f01
	mww 0xfffffc28 0x20c73f03
	while { [expr [read_register 0xfffffc68] & 0x02] != 2 } { sleep 1 }

	# Set master system clock prescaler divide by 6 and processor clock divide by 2 in PMC_MCKR.
	# Wait for MCKRDY signal from PMC_SR to assert.

	#mww 0xfffffc30 0x00000101
	mww 0xfffffc30 0x00001301
	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }

	# Now change PMC_MCKR register to select PLLA.
	# Wait for MCKRDY signal from PMC_SR to assert.

	mww 0xfffffc30 0x00001302
	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }

	# Processor and master clocks are now operating and stable at maximum frequency possible:
	#	-> MCLK = 132.096 MHz
	#	-> PCLK = 396.288 MHz

	# Switch over to adaptive clocking.

	adapter speed 6000

	# Enable faster DCC downloads.

	arm7_9 dcc_downloads enable

	# To be able to use external SDRAM, several peripheral configuration registers must
	# be modified.  The first change is made to PIO_ASR to select peripheral functions
	# for D15 through D31.  The second change is made to the PIO_PDR register to disable
	# this for D15 through D31.

#	mww 0xfffff870 0xffff0000
#	mww 0xfffff804 0xffff0000

	# The EBI chip select register EBI_CS must be specifically configured to enable the internal SDRAM controller
	# using CS1.  Additionally we want CS3 assigned to NandFlash.  Also VDDIO is connected physically on
	# the board to the 3.3 VDC power supply so set the appropriate register bit to notify the micrcontroller.

	# mww 0xffffef1c 0x000100a

	# The ICnova SAM9G45 SODIMM has built-in NandFlash.  The exact physical timing characteristics
	# for the memory type used on the current board (MT29F2G08AACWP) can be established by setting
	# four registers in order:  SMC_SETUP3, SMC_PULSE3, SMC_CYCLE3, and SMC_MODE3.

	# mww 0xffffec30 0x00020002
	# mww 0xffffec34 0x04040404
	# mww 0xffffec38 0x00070007
	# mww 0xffffec3c 0x00030003

	# Identify NandFlash bank 0.  Disabled at the moment because a memory driver is not yet complete.

#	nand probe 0

    # SMC_SETUP0 : Setup SMC for NOR Flash
	mww 0xffffe800 0x0012000a
    # SMC_PULSE0
	mww 0xffffe804 0x3b38343b
    # SMC_CYCLE0
	mww 0xffffe808 0x003f003f
    # SMC_MODE0
	mww 0xffffe80c 0x00001000
    # Identify flash bank 0
	flash probe 0

	# Now setup SDRAM.  This is tricky and configuration is very important for reliability!  The current calculations
	# are based on 2 x Samsung K4T51083QG memory.

	# 0. Enable DDR2 Clock
	mww 0xfffffc00 0x4
	# 1. Program memory device type
	# 1.1 configure the DDR controller
	mww 0xffffe620 0x16
	# 1.2 program the DDR controller
	mww 0xffffe608 0x3d

	# 2. program memory device features
	# 2.1 assume timings for 7.5ns min clock period
	mww 0xffffe60c 0x21128226
	# 2.2 pSDDRC->HDDRSDRC2_T1PR
	mww 0xffffe610 0x02c8100e
	# 2.3 pSDDRC->HDDRSDRC2_T2PR
	mww 0xffffe614 0x01000702
	# 3. NOP
	mww 0xffffe600 0x1
	mww 0x70000000 0x1
	# 3.1 delay 200us
	sleep 1
	# jim tcl alternative: after ms
	# after 0.2

	# 4. NOP
	mww 0xffffe600 0x1
	mww 0x70000000 0x1
	# 4.1 delay 400ns

	# 5. set all bank precharge
	mww 0xffffe600 0x2
	mww 0x70000000 0x1
	# 5.1 delay 400ns

	# 6. set EMR operation (EMRS2)
	mww 0xffffe600 0x5
	mww 0x74000000 0x1
	# 6.1 delay 2 cycles

	# 7. set EMR operation (EMRS3)
	mww 0xffffe600 0x5
	mww 0x76000000 0x1
	# 7.1 delay 2 cycles

	# 8. set EMR operation (EMRS1)
	mww 0xffffe600 0x5
	mww 0x72000000 0x1
	# 8.1 delay 200 cycles (400Mhz -> 5 * 10^-7s)
	sleep 1

	# 9. Enable DLL Reset (set DLL bit)
	set CR  [expr [read_register 0xffffe608] | 0x80]
	mww 0xffffe608 $CR

	# 10. mode register cycle to reset the DLL
	mww 0xffffe600 0x5
	mww 0x70000000 0x1
	# 10.1 delay 2 cycles

	# 11. set all bank precharge
	mww 0xffffe600 0x2
	mww 0x70000000 0x1
	# 11.1 delay 400 ns

	# 12. two auto-refresh (CBR) cycles are provided.
	mww 0xffffe600 0x4
	mww 0x70000000 0x1
	# 12.1 delay 10 cycles
	# 12.2 2nd cycle (schreiben des Mode Register sparen wir uns)
	mww 0x70000000 0x1
	# 12.3 delay 10 cycles

	# 13. disable DLL reset (clear DLL bit)
	set CR  [expr [read_register 0xffffe608] & 0xffffff7f]
	mww 0xffffe608 $CR

	# 14. mode register set cycle
	mww 0xffffe600 0x3
	mww 0x70000000 0x1

	# 15. program OCD field (set OCD bits)
	set CR  [expr [read_register 0xffffe608] | 0x7000]
	mww 0xffffe608 $CR

	# 16. (EMRS1)
	mww 0xffffe600 0x5
	mww 0x72000000 0x1
	# 16.1 delay 2 cycles

	# 17. disable OCD field (clear OCD bits)
	set CR  [expr [read_register 0xffffe608] & 0xffff8fff]
	mww 0xffffe608 $CR

	# 18. (EMRS1)
	mww 0xffffe600 0x5
	mww 0x76000000 0x1
	# 18.1 delay 2 cycles

	# 19. normal mode command
	mww 0xffffe600 0x0
	mww 0x70000000 0x1

	# 20. perform write to any address
	#mww 0x70000000 0x1

	# 21. write refresh rate into the count field of the refresh rate register
	mww 0xffffe604 0x24b
	# 21.1 delay (500 * 6 cycles)

	arm7_9 fast_memory_access enable
}
# The IMX27 ADS eval board has a single IMX27 chip
# Note: tested on IMX27ADS Board REV-2.6 and REV-2.8
source [find target/imx27.cfg]
$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { imx27ads_init }

# The IMX27 ADS board has a NOR flash on CS0
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xc0000000 0x00200000 2 2 $_TARGETNAME

proc imx27ads_init { } {
	# This setup puts RAM at 0xA0000000

	# reset the board correctly
	reset run
	reset halt

	mww 0x10000000 0x20040304
	mww 0x10020000 0x00000000
	mww 0x10000004 0xDFFBFCFB
	mww 0x10020004 0xFFFFFFFF

	sleep 100

	# ========================================
	#  Configure DDR on CSD0 -- initial reset
	# ========================================
	mww 0xD8001010 0x00000008

	# ========================================
	#  Configure PSRAM on CS5
	# ========================================
	mww 0xd8002050 0x0000dcf6
	mww 0xd8002054 0x444a4541
	mww 0xd8002058 0x44443302

	#  ========================================
	#         Configure16 bit NorFlash on CS0
	#  ========================================
	mww 0xd8002000 0x0000CC03
	mww 0xd8002004 0xa0330D01
	mww 0xd8002008 0x00220800

	# ========================================
	#  Configure CPLD on CS4
	# ========================================
	mww 0xd8002040 0x0000DCF6
	mww 0xd8002044 0x444A4541
	mww 0xd8002048 0x44443302

	# ========================================
	#  Configure DDR on CSD0 -- wait 5000 cycle
	# ========================================
	mww 0x10027828 0x55555555
	mww 0x10027830 0x55555555
	mww 0x10027834 0x55555555
	mww 0x10027838 0x00005005
	mww 0x1002783C 0x15555555

	mww 0xD8001010 0x00000004

	mww 0xD8001004 0x00795729

	mww 0xD8001000 0x92200000
	mww 0xA0000F00 0x0

	mww 0xD8001000 0xA2200000
	mww 0xA0000F00 0x0
	mww 0xA0000F00 0x0

	mww 0xD8001000 0xB2200000
	mwb 0xA0000033 0xFF
	mwb 0xA1000000 0xAA

	mww 0xD8001000 0x82228085
}
# The Linuxstamp-mx27 is board has a single IMX27 chip
# For further info see http://opencircuits.com/Linuxstamp_mx27#OpenOCD
source [find target/imx27.cfg]
$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { imx27lnst_init }

proc imx27lnst_init { } {
	# This setup puts RAM at 0xA0000000

	# reset the board correctly
	adapter speed 500
	reset run
	reset halt

	mww 0x10000000 0x20040304
	mww 0x10020000 0x00000000
	mww 0x10000004 0xDFFBFCFB
	mww 0x10020004 0xFFFFFFFF

	sleep 100

	# ========================================
	#  Configure DDR on CSD0 -- initial reset
	# ========================================
	mww 0xD8001010 0x00000008

	sleep 100

	# ========================================
	#  Configure DDR on CSD0 -- wait 5000 cycle
	# ========================================
	mww 0x10027828 0x55555555
	mww 0x10027830 0x55555555
	mww 0x10027834 0x55555555
	mww 0x10027838 0x00005005
	mww 0x1002783C 0x15555555

	mww 0xD8001010 0x00000004

	mww 0xD8001004 0x00795729

	#mww 0xD8001000 0x92200000
	mww 0xD8001000 0x91120000
	mww 0xA0000F00 0x0

	#mww 0xD8001000 0xA2200000
	mww 0xD8001000 0xA1120000
	mww 0xA0000F00 0x0
	mww 0xA0000F00 0x0

	#mww 0xD8001000 0xB2200000
	mww 0xD8001000 0xB1120000
	mwb 0xA0000033 0xFF
	mwb 0xA1000000 0xAA

	#mww 0xD8001000 0x82228085
	mww 0xD8001000 0x81128080

}
# The IMX28EVK eval board has a IMX28 chip
# Tested on SCH-26241 Rev D board with Olimex ARM-USB-OCD
# Date:	201-02-01
# Authors: James Robinson & Fabio Estevam

source [find target/imx28.cfg]
$_TARGETNAME configure -event gdb-attach { imx28evk_init }
$_TARGETNAME configure -event reset-init { imx28evk_init }

proc imx28evk_init { } {

	halt

	#****************************
	# VDDD setting
	#****************************
	# set VDDD =1.55V =(0.8v + TRIG x 0.025v), TRIG=0x1e
	mww 0x80044010 0x0003F503
	mww 0x80044040 0x0002041E

	#****************************
	# CLOCK set up
	#****************************
	# Power up PLL0 HW_CLKCTRL_PLL0CTRL0
	mww 0x80040000 0x00020000
	# Set up fractional dividers for CPU and EMI - HW_CLKCTRL_FRAC0
	# EMI - first set DIV_EMI to div-by-2 before programming frac divider
	mww 0x800400F0 0x80000002


	# CPU: CPUFRAC=19 480*18/29=454.7MHz, EMI: EMIFRAC=22, (480/2)*18/22=196.4MHz
	mww 0x800401B0 0x92921613
	# Clear the bypass bits for CPU and EMI clocks in HW_CLKCTRL_CLKSEQ_CLR
	mww 0x800401D8 0x00040080
	# HCLK = 227MHz,HW_CLKCTRL_HBUS DIV =0x2
	mww 0x80040060 0x00000002

	#****************************
	# POWER up DCDD_VDDA (DDR2)
	#****************************
	# Now set the voltage level to 1.8V HW_POWER_VDDACTRL bits TRC=0xC
	mww 0x80044050 0x0000270C

	#****************************
	# DDR2 DCDD_VDDA
	#****************************
	# First set up pin muxing and drive strength
	# Ungate module clock and bring out of reset HW_PINCTRL_CTRL_CLR
	mww 0x80018008 0xC0000000

	#****************************
	# EMI PAD setting
	#****************************
	# Set up drive strength for EMI pins
	mww 0x80019B80 0x00030000
	#IOMUXC_SW_PAD_CTL_GRP_CTLDS

	# Set up pin muxing for EMI, HW_PINCTRL_MUXSEL10, 11, 12, 13
	mww 0x800181A8 0xFFFFFFFF
	mww 0x800181B8 0xFFFFFFFF
	mww 0x800181C8 0xFFFFFFFF
	mww 0x800181D8 0xFFFFFFFF

	#** Ungate EMI clock in CCM
	mww 0x800400F0 0x00000002

	#============================================================================
	# DDR Controller Registers
	#============================================================================
	# Manufacturer:    Elpida
	# Device Part Number:    EDE1116AEBG
	# Clock Freq.:     200MHz
	# Density:         1Gb
	# Chip Selects:    1
	# Number of Banks: 8
	# Row address:     13
	# Column address:  10
	#============================================================================
	mww 0x800E0000 0x00000000
	mww 0x800E0040 0x00000000
	mww 0x800E0054 0x00000000
	mww 0x800E0058 0x00000000
	mww 0x800E005C 0x00000000
	mww 0x800E0060 0x00000000
	mww 0x800E0064 0x00000000
	mww 0x800E0068 0x00010101
	mww 0x800E006C 0x01010101
	mww 0x800E0070 0x000f0f01
	mww 0x800E0074 0x0102020A
	mww 0x800E007C 0x00010101
	mww 0x800E0080 0x00000100
	mww 0x800E0084 0x00000100
	mww 0x800E0088 0x00000000
	mww 0x800E008C 0x00000002
	mww 0x800E0090 0x01010000
	mww 0x800E0094 0x07080403
	mww 0x800E0098 0x06005003
	mww 0x800E009C 0x0A0000C8
	mww 0x800E00A0 0x02009C40
	mww 0x800E00A4 0x0002030C
	mww 0x800E00A8 0x0036B009
	mww 0x800E00AC 0x031A0612
	mww 0x800E00B0 0x02030202
	mww 0x800E00B4 0x00C8001C
	mww 0x800E00C0 0x00011900
	mww 0x800E00C4 0xffff0303
	mww 0x800E00C8 0x00012100
	mww 0x800E00CC 0xffff0303
	mww 0x800E00D0 0x00012100
	mww 0x800E00D4 0xffff0303
	mww 0x800E00D8 0x00012100
	mww 0x800E00DC 0xffff0303
	mww 0x800E00E0 0x00000003
	mww 0x800E00E8 0x00000000
	mww 0x800E0108 0x00000612
	mww 0x800E010C 0x01000f02
	mww 0x800E0114 0x00000200
	mww 0x800E0118 0x00020007
	mww 0x800E011C 0xf4004a27
	mww 0x800E0120 0xf4004a27
	mww 0x800E012C 0x07400300
	mww 0x800E0130 0x07400300
	mww 0x800E013C 0x00000005
	mww 0x800E0140 0x00000000
	mww 0x800E0144 0x00000000
	mww 0x800E0148 0x01000000
	mww 0x800E014C 0x01020408
	mww 0x800E0150 0x08040201
	mww 0x800E0154 0x000f1133
	mww 0x800E015C 0x00001f04
	mww 0x800E0160 0x00001f04
	mww 0x800E016C 0x00001f04
	mww 0x800E0170 0x00001f04
	mww 0x800E0288 0x00010000
	mww 0x800E028C 0x00030404
	mww 0x800E0290 0x00000003
	mww 0x800E02AC 0x01010000
	mww 0x800E02B0 0x01000000
	mww 0x800E02B4 0x03030000
	mww 0x800E02B8 0x00010303
	mww 0x800E02BC 0x01020202
	mww 0x800E02C0 0x00000000
	mww 0x800E02C4 0x02030303
	mww 0x800E02C8 0x21002103
	mww 0x800E02CC 0x00061200
	mww 0x800E02D0 0x06120612
	mww 0x800E02D4 0x04420442
	# Mode register 0 for CS1 and CS0, ok to program CS1 even if not used
	mww 0x800E02D8 0x00000000
	# Mode register 0 for CS2 and CS3, not supported in this processor
	mww 0x800E02DC 0x00040004
	# Mode register 1 for CS1 and CS0, ok to program CS1 even if not used
	mww 0x800E02E0 0x00000000
	# Mode register 1 for CS2 and CS3, not supported in this processor
	mww 0x800E02E4 0x00000000
	# Mode register 2 for CS1 and CS0, ok to program CS1 even if not used
	mww 0x800E02E8 0x00000000
	# Mode register 2 for CS2 and CS3, not supported in this processor
	mww 0x800E02EC 0x00000000
	# Mode register 3 for CS1 and CS0, ok to program CS1 even if not used
	mww 0x800E02F0 0x00000000
	# Mode register 3 for CS2 and CS3, not supported in this processor
	mww 0x800E02F4 0xffffffff

	#**  start controller **#
	mww 0x800E0040 0x00000001
	# bit[0]: start
}
# The IMX31PDK eval board has a single IMX31 chip
source [find target/imx31.cfg]
source [find target/imx.cfg]
$_TARGETNAME configure -event reset-init { imx31pdk_init }

proc self_test {} {
	echo "Running 100 iterations of test."
	dump_image /ram/test 0x80000000 0x40000
	for {set i 0} {$i < 100} {set i [expr $i+1]} {
		echo "Iteration $i"
		reset init
		mww 0x80000000 0x12345678 0x10000
		load_image /ram/test 0x80000000 bin
		verify_image /ram/test 0x80000000 bin
	}
}


# Slow fallback frequency
# measure_clk indicates ca. 3-4MHz.
jtag_rclk 1000

proc imx31pdk_init { } {

	imx3x_reset

	# This setup puts RAM at 0x80000000

	mww 0x53FC0000 0x040
	mww 0x53F80000 0x074B0B7D

	# 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
	#mww 0x53F80004 0xFF871D50
	#mww 0x53F80010 0x00271C1B

	# Start 16 bit NorFlash Initialization on CS0
	mww 0xb8002000 0x0000CC03
	mww 0xb8002004 0xa0330D01
	mww 0xb8002008 0x00220800

	# Configure CPLD on CS4
	mww 0xb8002040 0x0000DCF6
	mww 0xb8002044 0x444A4541
	mww 0xb8002048 0x44443302

	# SDCLK
	mww 0x43FAC26C 0

	# CAS
	mww 0x43FAC270 0

	# RAS
	mww 0x43FAC274 0

	# CS2 (CSD0)
	mww 0x43FAC27C 0x1000

	# DQM3
	mww 0x43FAC284 0

	# DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
	mww 0x43FAC288 0
	mww 0x43FAC28C 0
	mww 0x43FAC290 0
	mww 0x43FAC294 0
	mww 0x43FAC298 0
	mww 0x43FAC29C 0
	mww 0x43FAC2A0 0
	mww 0x43FAC2A4 0
	mww 0x43FAC2A8 0
	mww 0x43FAC2AC 0
	mww 0x43FAC2B0 0
	mww 0x43FAC2B4 0
	mww 0x43FAC2B8 0
	mww 0x43FAC2BC 0
	mww 0x43FAC2C0 0
	mww 0x43FAC2C4 0
	mww 0x43FAC2C8 0
	mww 0x43FAC2CC 0
	mww 0x43FAC2D0 0
	mww 0x43FAC2D4 0
	mww 0x43FAC2D8 0
	mww 0x43FAC2DC 0

	# Initialization script for 32 bit DDR on MX31 ADS
	mww 0xB8001010 0x00000004
	mww 0xB8001004 0x006ac73a
	mww 0xB8001000 0x92100000
	mww 0x80000f00 0x12344321
	mww 0xB8001000 0xa2100000
	mww 0x80000000 0x12344321
	mww 0x80000000 0x12344321
	mww 0xB8001000 0xb2100000
	mwb 0x80000033 0xda
	mwb 0x81000000 0xff
	mww 0xB8001000 0x82226080
	mww 0x80000000 0xDEADBEEF
	mww 0xB8001010 0x0000000c
}
# The IMX35PDK eval board has a single IMX35 chip
source [find target/imx35.cfg]
source [find target/imx.cfg]
$_TARGETNAME configure -event reset-init { imx35pdk_init }

# Stick to *really* low clock rate or reset will fail
# without RTCK / RCLK
jtag_rclk 10

proc imx35pdk_init { } {

	imx3x_reset

	mww 0x43f00040 0x00000000
	mww 0x43f00044 0x00000000
	mww 0x43f00048 0x00000000
	mww 0x43f0004C 0x00000000
	mww 0x43f00050 0x00000000
	mww 0x43f00000 0x77777777
	mww 0x43f00004 0x77777777
	mww 0x53f00040 0x00000000
	mww 0x53f00044 0x00000000
	mww 0x53f00048 0x00000000
	mww 0x53f0004C 0x00000000
	mww 0x53f00050 0x00000000
	mww 0x53f00000 0x77777777
	mww 0x53f00004 0x77777777

	# clock setup
	mww 0x53F80004 0x00821000 ;# first need to set IPU_HND_BYP
	mww 0x53F80004 0x00821000 ;#arm clock is 399Mhz and ahb clock is 133Mhz.

	#=================================================
	# WEIM config
	#=================================================
	# CS0U
	mww 0xB8002000 0x0000CC03
	# CS0L
	mww 0xB8002004 0xA0330D01
	# CS0A
	mww 0xB8002008 0x00220800
	# CS5U
	mww 0xB8002050 0x0000dcf6
	# CS5L
	mww 0xB8002054 0x444a4541
	# CS5A
	mww 0xB8002058 0x44443302

	# IO SW PAD Control registers - setting of 0x0002 is high drive, mDDR
	mww 0x43FAC368 0x00000006
	mww 0x43FAC36C 0x00000006
	mww 0x43FAC370 0x00000006
	mww 0x43FAC374 0x00000006
	mww 0x43FAC378 0x00000006
	mww 0x43FAC37C 0x00000006
	mww 0x43FAC380 0x00000006
	mww 0x43FAC384 0x00000006
	mww 0x43FAC388 0x00000006
	mww 0x43FAC38C 0x00000006
	mww 0x43FAC390 0x00000006
	mww 0x43FAC394 0x00000006
	mww 0x43FAC398 0x00000006
	mww 0x43FAC39C 0x00000006
	mww 0x43FAC3A0 0x00000006
	mww 0x43FAC3A4 0x00000006
	mww 0x43FAC3A8 0x00000006
	mww 0x43FAC3AC 0x00000006
	mww 0x43FAC3B0 0x00000006
	mww 0x43FAC3B4 0x00000006
	mww 0x43FAC3B8 0x00000006
	mww 0x43FAC3BC 0x00000006
	mww 0x43FAC3C0 0x00000006
	mww 0x43FAC3C4 0x00000006
	mww 0x43FAC3C8 0x00000006
	mww 0x43FAC3CC 0x00000006
	mww 0x43FAC3D0 0x00000006
	mww 0x43FAC3D4 0x00000006
	mww 0x43FAC3D8 0x00000006

	# DDR data bus SD 0 through 31
	mww 0x43FAC3DC 0x00000082
	mww 0x43FAC3E0 0x00000082
	mww 0x43FAC3E4 0x00000082
	mww 0x43FAC3E8 0x00000082
	mww 0x43FAC3EC 0x00000082
	mww 0x43FAC3F0 0x00000082
	mww 0x43FAC3F4 0x00000082
	mww 0x43FAC3F8 0x00000082
	mww 0x43FAC3FC 0x00000082
	mww 0x43FAC400 0x00000082
	mww 0x43FAC404 0x00000082
	mww 0x43FAC408 0x00000082
	mww 0x43FAC40C 0x00000082
	mww 0x43FAC410 0x00000082
	mww 0x43FAC414 0x00000082
	mww 0x43FAC418 0x00000082
	mww 0x43FAC41c 0x00000082
	mww 0x43FAC420 0x00000082
	mww 0x43FAC424 0x00000082
	mww 0x43FAC428 0x00000082
	mww 0x43FAC42c 0x00000082
	mww 0x43FAC430 0x00000082
	mww 0x43FAC434 0x00000082
	mww 0x43FAC438 0x00000082
	mww 0x43FAC43c 0x00000082
	mww 0x43FAC440 0x00000082
	mww 0x43FAC444 0x00000082
	mww 0x43FAC448 0x00000082
	mww 0x43FAC44c 0x00000082
	mww 0x43FAC450 0x00000082
	mww 0x43FAC454 0x00000082
	mww 0x43FAC458 0x00000082

	# DQM setup
	mww 0x43FAC45c 0x00000082
	mww 0x43FAC460 0x00000082
	mww 0x43FAC464 0x00000082
	mww 0x43FAC468 0x00000082

	mww 0x43FAC46c 0x00000006
	mww 0x43FAC470 0x00000006
	mww 0x43FAC474 0x00000006
	mww 0x43FAC478 0x00000006
	mww 0x43FAC47c 0x00000006
	mww 0x43FAC480 0x00000006	;# CSD0
	mww 0x43FAC484 0x00000006	;# CSD1
	mww 0x43FAC488 0x00000006
	mww 0x43FAC48c 0x00000006
	mww 0x43FAC490 0x00000006
	mww 0x43FAC494 0x00000006
	mww 0x43FAC498 0x00000006
	mww 0x43FAC49c 0x00000006
	mww 0x43FAC4A0 0x00000006
	mww 0x43FAC4A4 0x00000006	;# RAS
	mww 0x43FAC4A8 0x00000006	;# CAS
	mww 0x43FAC4Ac 0x00000006	;# SDWE
	mww 0x43FAC4B0 0x00000006 	;# SDCKE0
	mww 0x43FAC4B4 0x00000006  ;# SDCKE1
	mww 0x43FAC4B8 0x00000002  ;# SDCLK

	# SDQS0 through SDQS3
	mww 0x43FAC4Bc 0x00000082
	mww 0x43FAC4C0 0x00000082
	mww 0x43FAC4C4 0x00000082
	mww 0x43FAC4C8 0x00000082


	# *==================================================
	#  Initialization script for 32 bit DDR2 on RINGO 3DS
	# *==================================================

	#--------------------------------------------
	# Init CCM
	#--------------------------------------------
	mww 0x53F80028 0x7D000028

	#--------------------------------------------
	# Init IOMUX for JTAG
	#--------------------------------------------
	mww 0x43FAC5EC 0x000000C3
	mww 0x43FAC5F0 0x000000C3
	mww 0x43FAC5F4 0x000000F3
	mww 0x43FAC5F8 0x000000F3
	mww 0x43FAC5FC 0x000000F3
	mww 0x43FAC600 0x000000F3
	mww 0x43FAC604 0x000000F3


	# ESD_MISC : enable DDR2
	mww 0xB8001010 0x00000304

	#--------------------------------------------
	# Init 32-bit DDR2 memory on CSD0
	# COL=10-bit, ROW=13-bit, BA[1:0]=Addr[26:25]
	#--------------------------------------------

	# ESD_ESDCFG0 : set timing parameters
	mww 0xB8001004 0x007ffC2f

	# ESD_ESDCTL0 : select Prechare-All mode
	mww 0xB8001000 0x92220000
	# DDR2 : Prechare-All
	mww 0x80000400 0x12345678

	# ESD_ESDCTL0 : select Load-Mode-Register mode
	mww 0xB8001000 0xB2220000
	# DDR2 : Load reg EMR2
	mwb 0x84000000 0xda
	# DDR2 : Load reg EMR3
	mwb 0x86000000 0xda
	# DDR2 : Load reg EMR1 -- enable DLL
	mwb 0x82000400 0xda
	# DDR2 : Load reg MR -- reset DLL
	mwb 0x80000333 0xda

	# ESD_ESDCTL0 : select Prechare-All mode
	mww 0xB8001000 0x92220000
	# DDR2 : Prechare-All
	mwb 0x80000400 0x12345678

	# ESD_ESDCTL0 : select Manual-Refresh mode
	mww 0xB8001000 0xA2220000
	# DDR2 : Manual-Refresh 2 times
	mww 0x80000000 0x87654321
	mww 0x80000000 0x87654321

	# ESD_ESDCTL0 : select Load-Mode-Register mode
	mww 0xB8001000 0xB2220000
	# DDR2 : Load reg MR -- CL=3, BL=8, end DLL reset
	mwb 0x80000233 0xda
	# DDR2 : Load reg EMR1 -- OCD default
	mwb 0x82000780 0xda
	# DDR2 : Load reg EMR1 -- OCD exit
	mwb 0x82000400 0xda	;# ODT disabled

	# ESD_ESDCTL0 : select normal-operation mode
	# DSIZ=32-bit, BL=8, COL=10-bit, ROW=13-bit
	# disable PWT & PRCT
	# disable Auto-Refresh
	mww 0xB8001000 0x82220080

	## ESD_ESDCTL0 : enable Auto-Refresh
	mww 0xB8001000 0x82228080
	## ESD_ESDCTL1 : enable Auto-Refresh
	mww 0xB8001008 0x00002000


	#***********************************************
	# Adjust the ESDCDLY5 register
	#***********************************************
	# Vary DQS_ABS_OFFSET5 for writes
	mww 0xB8001020 0x00F48000	;# this is the default value
	mww 0xB8001024 0x00F48000	;# this is the default value
	mww 0xB8001028 0x00F48000	;# this is the default value
	mww 0xB800102c 0x00F48000	;# this is the default value


	#Then you can make force measure with the dedicated bit (Bit 7 at ESDMISC)
	mww 0xB8001010 0x00000384
	# wait a while
	sleep 1000
	# now clear the force measurement bit
	mww 0xB8001010 0x00000304

	# dummy write to DDR memory to set DQS low
	mww 0x80000000 0x00000000

	mww 0x30000100 0x0
	mww 0x30000104 0x31024


}
#######################################
# DENX M53EVK                         #
# http://www.denx-cs.de/?q=M53EVK     #
# Author: Marek Vasut <marex@denx.de> #
# Based on imx53loco.cfg              #
#######################################

# The DENX M53EVK has on-board JTAG adapter
source [find interface/ftdi/m53evk.cfg]
# The DENX M53EVK board has a single i.MX53 chip
source [find target/imx53.cfg]
# Helper for common memory read/modify/write procedures
source [find mem_helper.tcl]

echo "iMX53 M53EVK board lodaded."

# Set reset type
reset_config trst_and_srst separate trst_open_drain srst_open_drain

# Run at 6 MHz
adapter speed 6000

$_TARGETNAME configure -event "reset-assert" {
	echo "Resetting ...."
	#cortex_a dbginit
}

$_TARGETNAME configure -event reset-init { m53evk_init }

global AIPS1_BASE_ADDR
set AIPS1_BASE_ADDR     0x53F00000
global AIPS2_BASE_ADDR
set AIPS2_BASE_ADDR     0x63F00000

proc m53evk_init { } {
	echo "Reset-init..."
	; # halt the CPU
	halt

	echo "HW version [format %x [mrw 0x48]]"

	dap apsel 1
	DCD

	; # ARM errata ID #468414
	set tR [arm mrc 15 0 1 0 1]
	arm mcr 15 0 1 0 1 [expr $tR | (1<<5)]	; # enable L1NEON bit

	init_l2cc
	init_aips
	init_clock

	dap apsel 0

	; # Force ARM state
	; #reg cpsr 0x000001D3
	arm core_state arm
}


# L2CC Cache setup/invalidation/disable
proc init_l2cc { } {
	; #/* explicitly disable L2 cache */
	; #mrc 15, 0, r0, c1, c0, 1
	set tR [arm mrc 15 0 1 0 1]
	; #bic r0, r0, #0x2
	; #mcr 15, 0, r0, c1, c0, 1
	arm mcr 15 0 1 0 1 [expr $tR & ~(1<<2)]

	; #/* reconfigure L2 cache aux control reg */
	; #mov r0, #0xC0                   /* tag RAM */
	; #add r0, r0, #0x4                /* data RAM */
	; #orr r0, r0, #(1 << 24)          /* disable write allocate delay */
	; #orr r0, r0, #(1 << 23)          /* disable write allocate combine */
	; #orr r0, r0, #(1 << 22)          /* disable write allocate */

	; #mcr 15, 1, r0, c9, c0, 2
	arm mcr 15 1 9 0 2 [expr 0xC4 | (1<<24) | (1<<23) | (1<22)]
}


# AIPS setup - Only setup MPROTx registers.
# The PACR default values are good.
proc init_aips { } {
	; # Set all MPROTx to be non-bufferable, trusted for R/W,
	; # not forced to user-mode.
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set VAL			0x77777777

#	dap apsel 1
	mww [expr $AIPS1_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS1_BASE_ADDR + 0x4] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x4] $VAL
#	dap apsel 0
}


proc init_clock { } {
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set CCM_BASE_ADDR	[expr $AIPS1_BASE_ADDR + 0x000D4000]
	set CLKCTL_CCSR         0x0C
	set CLKCTL_CBCDR	0x14
	set CLKCTL_CBCMR        0x18
	set PLL1_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00080000]
	set PLL2_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00084000]
	set PLL3_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00088000]
	set PLL4_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x0008C000]
	set CLKCTL_CSCMR1	0x1C
	set CLKCTL_CDHIPR	0x48
	set PLATFORM_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x000A0000]
	set CLKCTL_CSCDR1	0x24
	set CLKCTL_CCDR		0x04

	; # Switch ARM to step clock
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x4

	return
	echo "not returned"
	setup_pll $PLL1_BASE_ADDR 800
	setup_pll $PLL3_BASE_ADDR 400

	; # Switch peripheral to PLL3
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00015154
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x02888945 | (1<<16)]
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL2_BASE_ADDR 400

	; # Switch peripheral to PLL2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x00808145 | (2<<10) | (9<<16) | (1<<19)]

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00016154

	; # change uart clk parent to pll2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1]] & 0xfcffffff | 0x01000000]

	; # make sure change is effective
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL3_BASE_ADDR 216

	setup_pll $PLL4_BASE_ADDR 455

	; # Set the platform clock dividers
	mww [expr $PLATFORM_BASE_ADDR + 0x14] 0x00000124

	mww [expr $CCM_BASE_ADDR + 0x10] 0

	; # Switch ARM back to PLL 1.
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x0

	; # make uart div=6
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1]] & 0xffffffc0 | 0x0a]

	; # Restore the default values in the Gate registers
	mww [expr $CCM_BASE_ADDR + 0x68] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x6C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x70] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x74] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x78] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x7C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x80] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x84] 0xFFFFFFFF

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCDR] 0x00000

	; # for cko - for ARM div by 8
	mww [expr $CCM_BASE_ADDR + 0x60] [expr 0x000A0000 & 0x00000F0]
}


proc setup_pll { PLL_ADDR CLK } {
	set PLL_DP_CTL		0x00
	set PLL_DP_CONFIG   	0x04
	set PLL_DP_OP		0x08
	set PLL_DP_HFS_OP	0x1C
	set PLL_DP_MFD		0x0C
	set PLL_DP_HFS_MFD	0x20
	set PLL_DP_MFN		0x10
	set PLL_DP_HFS_MFN	0x24

	if {$CLK == 1000} {
		set DP_OP	[expr (10 << 4) + ((1 - 1) << 0)]
		set DP_MFD	[expr (12 - 1)]
		set DP_MFN	5
	} elseif {$CLK == 850} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	41
	} elseif {$CLK == 800} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 700} {
		set DP_OP	[expr (7 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	7
	} elseif {$CLK == 600} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 665} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (96 - 1)]
		set DP_MFN	89
	} elseif {$CLK == 532} {
		set DP_OP	[expr (5 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	13
	} elseif {$CLK == 455} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	71
	} elseif {$CLK == 400} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 216} {
		set DP_OP	[expr (6 << 4) + ((3 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	3
	} else {
		error "Error (setup_dll): clock not found!"
	}

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	mww [expr $PLL_ADDR + $PLL_DP_CONFIG] 0x2

	mww [expr $PLL_ADDR + $PLL_DP_OP] $DP_OP
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_OP

	mww [expr $PLL_ADDR + $PLL_DP_MFD] $DP_MFD
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_MFD

	mww [expr $PLL_ADDR + $PLL_DP_MFN] $DP_MFN
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFN] $DP_MFN

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	while {[expr [mrw [expr $PLL_ADDR + $PLL_DP_CTL]] & 0x1] == 0} { sleep 1 }
}


proc CPU_2_BE_32 { L } {
	return [expr (($L & 0x000000FF) << 24) | (($L & 0x0000FF00) << 8) | (($L & 0x00FF0000) >> 8)  | (($L & 0xFF000000) >> 24)]
}


# Device Configuration Data
proc DCD { } {
#	dap apsel 1
	mww 0x53fa86f4 0x00000000	 ;# GRP_DDRMODE_CTL
	mww 0x53fa8714 0x00000000	 ;# GRP_DDRMODE
	mww 0x53fa86fc 0x00000000	 ;# GRP_DDRPKE
	mww 0x53fa8724 0x04000000	 ;# GRP_DDR_TYPE

	mww 0x53fa872c 0x00300000	 ;# GRP_B3DS
	mww 0x53fa8554 0x00300000	 ;# DRAM_DQM3
	mww 0x53fa8558 0x00300040	 ;# DRAM_SDQS3

	mww 0x53fa8728 0x00300000	 ;# GRP_B2DS
	mww 0x53fa8560 0x00300000	 ;# DRAM_DQM2
	mww 0x53fa8568 0x00300040	 ;# DRAM_SDQS2

	mww 0x53fa871c 0x00300000	 ;# GRP_B1DS
	mww 0x53fa8594 0x00300000	 ;# DRAM_DQM1
	mww 0x53fa8590 0x00300040	 ;# DRAM_SDQS1

	mww 0x53fa8718 0x00300000	 ;# GRP_B0DS
	mww 0x53fa8584 0x00300000	 ;# DRAM_DQM0
	mww 0x53fa857c 0x00300040	 ;# DRAM_SDQS0

	mww 0x53fa8578 0x00300000	 ;# DRAM_SDCLK_0
	mww 0x53fa8570 0x00300000	 ;# DRAM_SDCLK_1

	mww 0x53fa8574 0x00300000	 ;# DRAM_CAS
	mww 0x53fa8588 0x00300000	 ;# DRAM_RAS
	mww 0x53fa86f0 0x00300000	 ;# GRP_ADDDS
	mww 0x53fa8720 0x00300000	 ;# GRP_CTLDS

	mww 0x53fa8564 0x00300040	 ;# DRAM_SDODT1
	mww 0x53fa8580 0x00300040	 ;# DRAM_SDODT0

	# Initialize DDR2 memory
	mww 0x63fd9088 0x32383535
	mww 0x63fd9090 0x40383538
	mww 0x63fd907c 0x0136014d
	mww 0x63fd9080 0x01510141

	mww 0x63fd9018 0x00011740
	mww 0x63fd9000 0xc3190000
	mww 0x63fd900c 0x555952e3
	mww 0x63fd9010 0xb68e8b63
	mww 0x63fd9014 0x01ff00db
	mww 0x63fd902c 0x000026d2
	mww 0x63fd9030 0x009f0e21
	mww 0x63fd9008 0x12273030
	mww 0x63fd9004 0x0002002d
	mww 0x63fd901c 0x00008032
	mww 0x63fd901c 0x00008033
	mww 0x63fd901c 0x00028031
	mww 0x63fd901c 0x092080b0
	mww 0x63fd901c 0x04008040
	mww 0x63fd901c 0x0000803a
	mww 0x63fd901c 0x0000803b
	mww 0x63fd901c 0x00028039
	mww 0x63fd901c 0x09208138
	mww 0x63fd901c 0x04008048
	mww 0x63fd9020 0x00001800
	mww 0x63fd9040 0x04b80003
	mww 0x63fd9058 0x00022227
	mww 0x63fd901c 0x00000000
#	dap apsel 0
}

# vim:filetype=tcl
##################################################################################
# Author: Wjatscheslaw Stoljarski (Slawa) <wjatscheslaw.stoljarski@kiwigrid.com> #
# Kiwigrid GmbH                                                                  #
##################################################################################

# The IMX53LOCO (QSB) board has a single IMX53 chip
source [find target/imx53.cfg]
# Helper for common memory read/modify/write procedures
source [find mem_helper.tcl]

echo "iMX53 Loco board lodaded."

# Set reset type
#reset_config srst_only

adapter speed 3000

# Slow speed to be sure it will work
jtag_rclk 1000
$_TARGETNAME configure -event "reset-start" { jtag_rclk 1000 }

#jtag_nsrst_delay 200
#jtag_ntrst_delay 200

$_TARGETNAME configure -event "reset-assert" {
	echo "Resetting ...."
	#cortex_a dbginit
}

$_TARGETNAME configure -event reset-init { loco_init }

global AIPS1_BASE_ADDR
set AIPS1_BASE_ADDR     0x53F00000
global AIPS2_BASE_ADDR
set AIPS2_BASE_ADDR     0x63F00000

proc loco_init { } {
	echo "Reset-init..."
	; # halt the CPU
	halt

	echo "HW version [format %x [mrw 0x48]]"

	dap apsel 1
	DCD

	; # ARM errata ID #468414
	set tR [arm mrc 15 0 1 0 1]
	arm mcr 15 0 1 0 1 [expr $tR | (1<<5)]	; # enable L1NEON bit

	init_l2cc
	init_aips
	init_clock

	dap apsel 0

	; # Force ARM state
	; #reg cpsr 0x000001D3
	arm core_state arm

	jtag_rclk 3000
#	adapter speed 3000
}


# L2CC Cache setup/invalidation/disable
proc init_l2cc { } {
	; #/* explicitly disable L2 cache */
	; #mrc 15, 0, r0, c1, c0, 1
	set tR [arm mrc 15 0 1 0 1]
	; #bic r0, r0, #0x2
	; #mcr 15, 0, r0, c1, c0, 1
	arm mcr 15 0 1 0 1 [expr $tR & ~(1<<2)]

	; #/* reconfigure L2 cache aux control reg */
	; #mov r0, #0xC0                   /* tag RAM */
	; #add r0, r0, #0x4                /* data RAM */
	; #orr r0, r0, #(1 << 24)          /* disable write allocate delay */
	; #orr r0, r0, #(1 << 23)          /* disable write allocate combine */
	; #orr r0, r0, #(1 << 22)          /* disable write allocate */

	; #mcr 15, 1, r0, c9, c0, 2
	arm mcr 15 1 9 0 2 [expr 0xC4 | (1<<24) | (1<<23) | (1<22)]
}


# AIPS setup - Only setup MPROTx registers.
# The PACR default values are good.
proc init_aips { } {
	; # Set all MPROTx to be non-bufferable, trusted for R/W,
	; # not forced to user-mode.
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set VAL			0x77777777

#	dap apsel 1
	mww [expr $AIPS1_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS1_BASE_ADDR + 0x4] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x0] $VAL
	mww [expr $AIPS2_BASE_ADDR + 0x4] $VAL
#	dap apsel 0
}


proc init_clock { } {
	global AIPS1_BASE_ADDR
	global AIPS2_BASE_ADDR
	set CCM_BASE_ADDR	[expr $AIPS1_BASE_ADDR + 0x000D4000]
	set CLKCTL_CCSR         0x0C
	set CLKCTL_CBCDR	0x14
	set CLKCTL_CBCMR        0x18
	set PLL1_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00080000]
	set PLL2_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00084000]
	set PLL3_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x00088000]
	set PLL4_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x0008C000]
	set CLKCTL_CSCMR1	0x1C
	set CLKCTL_CDHIPR	0x48
	set PLATFORM_BASE_ADDR	[expr $AIPS2_BASE_ADDR + 0x000A0000]
	set CLKCTL_CSCDR1	0x24
	set CLKCTL_CCDR		0x04

	; # Switch ARM to step clock
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x4

	return
	echo "not returned"
	setup_pll $PLL1_BASE_ADDR 800
	setup_pll $PLL3_BASE_ADDR 400

	; # Switch peripheral to PLL3
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00015154
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x02888945 | (1<<16)]
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL2_BASE_ADDR 400

	; # Switch peripheral to PLL2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCDR] [expr 0x00808145 | (2<<10) | (9<<16) | (1<<19)]

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CBCMR] 0x00016154

	; # change uart clk parent to pll2
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCMR1]] & 0xfcffffff | 0x01000000]

	; # make sure change is effective
	while {[mrw [expr $CCM_BASE_ADDR + $CLKCTL_CDHIPR]] != 0} { sleep 1 }

	setup_pll $PLL3_BASE_ADDR 216

	setup_pll $PLL4_BASE_ADDR 455

	; # Set the platform clock dividers
	mww [expr $PLATFORM_BASE_ADDR + 0x14] 0x00000124

	mww [expr $CCM_BASE_ADDR + 0x10] 0

	; # Switch ARM back to PLL 1.
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCSR] 0x0

	; # make uart div=6
	mww [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1] [expr [mrw [expr $CCM_BASE_ADDR + $CLKCTL_CSCDR1]] & 0xffffffc0 | 0x0a]

	; # Restore the default values in the Gate registers
	mww [expr $CCM_BASE_ADDR + 0x68] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x6C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x70] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x74] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x78] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x7C] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x80] 0xFFFFFFFF
	mww [expr $CCM_BASE_ADDR + 0x84] 0xFFFFFFFF

	mww [expr $CCM_BASE_ADDR + $CLKCTL_CCDR] 0x00000

	; # for cko - for ARM div by 8
	mww [expr $CCM_BASE_ADDR + 0x60] [expr 0x000A0000 & 0x00000F0]
}


proc setup_pll { PLL_ADDR CLK } {
	set PLL_DP_CTL		0x00
	set PLL_DP_CONFIG   	0x04
	set PLL_DP_OP		0x08
	set PLL_DP_HFS_OP	0x1C
	set PLL_DP_MFD		0x0C
	set PLL_DP_HFS_MFD	0x20
	set PLL_DP_MFN		0x10
	set PLL_DP_HFS_MFN	0x24

	if {$CLK == 1000} {
		set DP_OP	[expr (10 << 4) + ((1 - 1) << 0)]
		set DP_MFD	[expr (12 - 1)]
		set DP_MFN	5
	} elseif {$CLK == 850} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	41
	} elseif {$CLK == 800} {
		set DP_OP	[expr (8 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 700} {
		set DP_OP	[expr (7 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	7
	} elseif {$CLK == 600} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 665} {
		set DP_OP	[expr (6 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (96 - 1)]
		set DP_MFN	89
	} elseif {$CLK == 532} {
		set DP_OP	[expr (5 << 4) + ((1 - 1)  << 0)]
		set DP_MFD	[expr (24 - 1)]
		set DP_MFN	13
	} elseif {$CLK == 455} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (48 - 1)]
		set DP_MFN	71
	} elseif {$CLK == 400} {
		set DP_OP	[expr (8 << 4) + ((2 - 1)  << 0)]
		set DP_MFD	[expr (3 - 1)]
		set DP_MFN	1
	} elseif {$CLK == 216} {
		set DP_OP	[expr (6 << 4) + ((3 - 1)  << 0)]
		set DP_MFD	[expr (4 - 1)]
		set DP_MFN	3
	} else {
		error "Error (setup_dll): clock not found!"
	}

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	mww [expr $PLL_ADDR + $PLL_DP_CONFIG] 0x2

	mww [expr $PLL_ADDR + $PLL_DP_OP] $DP_OP
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_OP

	mww [expr $PLL_ADDR + $PLL_DP_MFD] $DP_MFD
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFD] $DP_MFD

	mww [expr $PLL_ADDR + $PLL_DP_MFN] $DP_MFN
	mww [expr $PLL_ADDR + $PLL_DP_HFS_MFN] $DP_MFN

	mww [expr $PLL_ADDR + $PLL_DP_CTL] 0x00001232
	while {[expr [mrw [expr $PLL_ADDR + $PLL_DP_CTL]] & 0x1] == 0} { sleep 1 }
}


proc CPU_2_BE_32 { L } {
	return [expr (($L & 0x000000FF) << 24) | (($L & 0x0000FF00) << 8) | (($L & 0x00FF0000) >> 8)  | (($L & 0xFF000000) >> 24)]
}


# Device Configuration Data
proc DCD { } {
#	dap apsel 1
	mww 0x53FA8554 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
	mww 0x53FA8558 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3
	mww 0x53FA8560 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
	mww 0x53FA8564 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT
	mww 0x53FA8568 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2
	mww 0x53FA8570 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1
	mww 0x53FA8574 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
	mww 0x53FA8578 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
	mww 0x53FA857c 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0
	mww 0x53FA8580 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
	mww 0x53FA8584 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
	mww 0x53FA8588 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
	mww 0x53FA8590 0x00300040	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1
	mww 0x53FA8594 0x00300000	;# IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
	mww 0x53FA86f0 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_ADDDS
	mww 0x53FA86f4 0x00000000	;# IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL
	mww 0x53FA86fc 0x00000000	;# IOMUXC_SW_PAD_CTL_GRP_DDRPKE
	mww 0x53FA8714 0x00000000	;# IOMUXC_SW_PAD_CTL_GRP_DDRMODE - CMOS mode
	mww 0x53FA8718 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_B0DS
	mww 0x53FA871c 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_B1DS
	mww 0x53FA8720 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_CTLDS
	mww 0x53FA8724 0x04000000	;# IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL0=
	mww 0x53FA8728 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_B2DS
	mww 0x53FA872c 0x00300000	;# IOMUXC_SW_PAD_CTL_GRP_B3DS

	# Initialize DDR2 memory
	mww 0x63FD9088 0x35343535	;# ESDCTL_RDDLCTL
	mww 0x63FD9090 0x4d444c44	;# ESDCTL_WRDLCTL
	mww 0x63FD907c 0x01370138	;# ESDCTL_DGCTRL0
	mww 0x63FD9080 0x013b013c	;# ESDCTL_DGCTRL1
	mww 0x63FD9018 0x00011740	;# ESDCTL_ESDMISC
	mww 0x63FD9000 0xc3190000	;# ESDCTL_ESDCTL
	mww 0x63FD900c 0x9f5152e3	;# ESDCTL_ESDCFG0
	mww 0x63FD9010 0xb68e8a63	;# ESDCTL_ESDCFG1
	mww 0x63FD9014 0x01ff00db	;# ESDCTL_ESDCFG2
	mww 0x63FD902c 0x000026d2	;# ESDCTL_ESDRWD
	mww 0x63FD9030 0x009f0e21	;# ESDCTL_ESDOR
	mww 0x63FD9008 0x12273030	;# ESDCTL_ESDOTC
	mww 0x63FD9004 0x0002002d	;# ESDCTL_ESDPDC
	mww 0x63FD901c 0x00008032	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x00008033	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x00028031	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x052080b0	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x04008040	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x0000803a	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x0000803b	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x00028039	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x05208138	;# ESDCTL_ESDSCR
	mww 0x63FD901c 0x04008048	;# ESDCTL_ESDSCR
	mww 0x63FD9020 0x00005800	;# ESDCTL_ESDREF
	mww 0x63FD9040 0x04b80003	;# ESDCTL_ZQHWCTRL
	mww 0x63FD9058 0x00022227	;# ESDCTL_ODTCTRL
	mww 0x63FD901C 0x00000000	;# ESDCTL_ESDSCR
#	dap apsel 0
}

# vim:filetype=tcl
#
# configuration file for NXP MC-IMX8MP-EVK
#
# Board includes FTDI-based JTAG adapter: interface/ftdi/imx8mp-evk.cfg
#

transport select jtag
adapter speed 1000
reset_config srst_only
adapter srst delay 100

set CHIPNAME imx8mp
set CHIPCORES 4

source [find target/imx8m.cfg]
#
# InSignal Arndale board
#

source [find target/exynos5250.cfg]

# Experimentally determined highest working speed
adapter speed 200
adapter driver ftdi
ftdi_device_desc "Quad RS232-HS"
ftdi_vid_pid 0x0403 0x6011
ftdi_channel 0
ftdi_layout_init 0x0008 0x000b
# ftdi_location 1:8

reset_config none
transport select jtag
adapter speed 25000

source [find cpld/xilinx-xc7.cfg]
source [find cpld/jtagspi.cfg]
source [find fpga/xilinx-xadc.cfg]
source [find fpga/xilinx-dna.cfg]
# Knovative KC-100 cable modem

# TNETC4401PYP, 208-QFP U3
source [find target/tnetc4401.cfg]

# 14-pin EJTAG on JP1. Standard pinout, 1-3-5-7-9-11 = nTRST-TDI-TDO-TMS-TCK-nSRST. Use 2 for GND.
# Was initially disabled in hardware; had to add a solder bridge reenabling R124, R125 on back.
reset_config trst_and_srst separate

# 16Mb Intel CFI flash. Note this CPU has an internal ROM at 0x1FC0000 (phys) for cold boot.
# All that really does is some minimal checks before jumping to external flash at 0x00000000 phys.
# That is remapped to 0xB0000000 uncached, 0x90000000 cached.
flash bank intel cfi 0xB0000000 0x200000 2 2 $_TARGETNAME

# Perform this after a clean reboot, halt, and reset init (which should also leave it halted).
proc kc100_dump_flash {} {
	echo "Probing 48 TSOP Intel CFI flash chip (2MB)..."
	flash probe intel
	echo "Dumping 2MB flash chip to flashdump.bin.
	flash read_bank 0 flashdump.bin 0 0x200000
}

#TODO figure out memory init sequence to be able to dump from cached segment instead

# There is also a serial console on JP2, 3-5-6 = TX-RX-GND. 9600/8/N/1.

# Possibly of note, this modem's ancient ethernet port does not support Auto-MDIX.

# This modem in many ways appears to be essentially a clone of the SB5120. See usbjtag.com.
# The firmware/OS is also susceptible to many of the same procedures in "Hacking the Cable Modem"
# by DerEngel (Ryan Harris), available from No Starch Press.
# http://www.xilinx.com/products/boards-and-kits/ek-k7-kc705-g.html

source [find interface/ftdi/digilent-hs1.cfg]
source [find cpld/xilinx-xc7.cfg]
source [find cpld/jtagspi.cfg]
source [find fpga/xilinx-xadc.cfg]
source [find fpga/xilinx-dna.cfg]
adapter speed 25000

# example command to write bitstream, soft-cpu bios and runtime:
# openocd -f board/kc705.cfg -c "init;\
# jtagspi_init 0 bscan_spi_xc7k325t.bit;\
# jtagspi_program bitstream-kc705.bin 0;\
# jtagspi_program bios.bin 0xaf0000;\
# jtagspi_program runtime.fbi 0xb00000;\
# xc7_program xc7.tap;\
# exit"
# xilinx ultrascale
# http://www.xilinx.com/support/documentation/user_guides/ug570-ultrascale-configuration.pdf

source [find interface/ftdi/digilent_jtag_smt2_nc.cfg]

set CHIP XCKU040
source [find cpld/xilinx-xcu.cfg]

source [find cpld/jtagspi.cfg]

adapter speed 25000
#
# Keil MCB1700 eval board
#
# http://www.keil.com/mcb1700/picture.asp
#

source [find target/lpc17xx.cfg]
#
# Keil MCB2140 eval board
#
# http://www.keil.com/mcb2140/picture.asp
#

source [find target/lpc2148.cfg]
# Board configuration file for Amazon Kindle Model No. D00701 and D00801
# AKA Kindle 2nd generation and Kindle DX
# using a Freescale MCIMX31LDVKN5D i.MX31 processor
#
# Pins at J9 40-Pin FFC-A:
#  1 - GND
# 16 - TRSTB
# 17 - TDI
# 18 - TMS
# 19 - TCK
# 20 - RTCK
# 21 - TDO
# 22 - DE
# 25 - BOOT_MODE4
# 27 - BOOT_MODE2

source [find target/imx31.cfg]
source [find target/imx.cfg]

$_TARGETNAME configure -event reset-init { kindle2_init }
$_TARGETNAME configure -event reset-start { adapter speed 1000 }

# 8MiB NOR Flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xa0000000 0x800000 2 2 $_TARGETNAME

# 16kiB internal SRAM
$_TARGETNAME configure -work-area-phys 0x1fffc000 \
	-work-area-size 0x4000 -work-area-backup 0

# FIXME: currently SRST is not wired to the system
reset_config trst_only
jtag_ntrst_assert_width 10
jtag_ntrst_delay 30

# this is broken but enabled by default
arm11 memwrite burst disable

adapter speed 1000
ftdi_tdo_sample_edge falling

proc kindle2_init {} {
	imx3x_reset
	kindle2_clock_setup
	disable_mmu_and_cache
	kindle2_misc_init
	kindle2_sdram_init
	arm core_state arm
}

proc kindle2_clock_setup {} {
	# CCMR: clock from FPM/CKIL
	mww 0x53f80000  0x074b0b7b
	# IPU_CONF
	mww 0x53fc0000  0x040
	# 398MHz
	mww 0x53f80004 0xff871650
	mww 0x53f80010 0x00331c23
}

proc kindle2_misc_init { } {
	# AIPS1
	mww 0x43f00040 0x0
	mww 0x43f00044 0x0
	mww 0x43f00048 0x0
	mww 0x43f0004c 0x0
	mww 0x43f00050 0x0
	mww 0x43f00000 0x77777777
	mww 0x43f00004 0x77777777

	# AIPS2
	mww 0x53f00040 0x0
	mww 0x53f00044 0x0
	mww 0x53f00048 0x0
	mww 0x53f0004c 0x0
	mww 0x53f00050 0x0
	mww 0x53f00000 0x77777777
	mww 0x53f00004 0x77777777

	# Start 16 bit NorFlash Initialization on CS0
	mww 0xb8002000 0x0000cc03
	mww 0xb8002004 0xa0330d01
	mww 0xb8002008 0x00220800
}

proc disable_mmu_and_cache {} {
	# Mode Supervisor, disable FIQ, IRQ and imprecise data aborts
	reg cpsr 0x1d3

	# flush entire BTAC
	arm mcr 15 0 7 5 6 0
	# invalidate instruction and data cache
	# MCR CP15, 0, R1, C7, C7, 0
	arm mcr 15 0 7 7 0

	# clean and invalidate cache
	arm mcr 15 0 7 15 0

	# disable MMU and caches
	arm mcr 15 0 1 0 0 0

	arm mcr 15 0 15 2 4 0

	# invalidate TLBs
	arm mcr 15 0 8 7 0 0

	# Drain the write buffer
	arm mcr 15 0 7 10 4 0

	# start from AIPS 2GB region
	arm mcr 15 0 15 2 4 0x40000015
}

proc kindle2_sdram_init {} {
	#--------------------------------------------
	# Samsung K4X1G323PC-8GC3 32Mx32 Mobile DDR SDRAM
	#--------------------------------------------
	# SDCLK
	mww 0x43fac26c 0

	# CAS
	mww 0x43fac270 0

	# RAS
	mww 0x43fac274 0

	# CS2 (CSD0)
	mww 0x43fac27c 0x1000

	# DQM3
	mww 0x43fac284 0

	# DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2dc)
	mww 0x43fac288 0
	mww 0x43fac28c 0
	mww 0x43fac290 0
	mww 0x43fac294 0
	mww 0x43fac298 0
	mww 0x43fac29c 0
	mww 0x43fac2a0 0
	mww 0x43fac2a4 0
	mww 0x43fac2a8 0
	mww 0x43fac2ac 0
	mww 0x43fac2b0 0
	mww 0x43fac2b4 0
	mww 0x43fac2b8 0
	mww 0x43fac2bc 0
	mww 0x43fac2c0 0
	mww 0x43fac2c4 0
	mww 0x43fac2c8 0
	mww 0x43fac2cc 0
	mww 0x43fac2d0 0
	mww 0x43fac2d4 0
	mww 0x43fac2d8 0
	mww 0x43fac2dc 0

	# ?
	mww 0xb8002000 0x00006602
	mww 0xb8002004 0x00000501
	mww 0xb8002008 0x00000000

	# LPDDR1 Initialization script
	mww 0xb8001010 0x00000002
	mww 0xb8001010 0x00000004
	# ESDCFG0: set timing parameters
	mww 0xb8001004 0x007fff7f
	# ESDCTL0: select Prechare-All mode
	mww 0xb8001000 0x92100000
	mww 0x80000f00 0x12344321
	# ESDCTL0: Auto Refresh
	mww 0xb8001000 0xa2100000
	mww 0x80000000 0x12344321
	mww 0x80000000 0x12344321
	# ESDCTL0: Load Mode Register
	mww 0xb8001000 0xb2100000
	mwb 0x80000033 0xda
	mwb 0x81000000 0xff
	# ESDCTL0: enable Auto-Refresh
	mww 0xb8001000 0x82226080
	mww 0x80000000 0xdeadbeef
}
#
# Freescale KwikStik development board
#

#
# JLINK interface is onboard
#
source [find interface/jlink.cfg]

source [find target/k40.cfg]

reset_config trst_and_srst
source [find target/atheros_ar2315.cfg]

reset_config trst_and_srst
#
# board configuration for LeMaker Hikey
#

# board does not feature anything but JTAG
transport select jtag

# SRST-only reset configuration
reset_config srst_only srst_push_pull

source [find target/hi6220.cfg]

# make sure the default target is the boot core
targets ${_TARGETNAME}0

proc core_up { args } {
	global _TARGETNAME

	# examine remaining cores
	foreach _core [set args] {
		${_TARGETNAME}$_core arp_examine
	}
}
#
# Linksys WAG200G Router
#
# The stock firmware Flash layout is organized as follow:
#
#   Start       End         Device
#   0x90000000  0x90020000  /dev/mtdblock/2
#   0x90020000  0x900d0000  /dev/mtdblock/1
#   0x900d0000  0x903a0000  /dev/mtdblock/0
#   0x903a0000  0x903e0000  /dev/mtdblock/5
#   0x903e0000  0x903f0000  /dev/mtdblock/3
#   0x903f0000  0x90400000  /dev/mtdblock/4

set partition_list {
    adam2	{ "Adam2 bootloader"		0x90000000 0x00020000 }
    kernel	{ "Kernel"			0x90020000 0x000b0000 }
    rootfs	{ "Root FS"			0x900d0000 0x002d0000 }
    lang	{ "Minix language part"		0x903a0000 0x00040000 }
    config	{ "Firmware config"		0x903e0000 0x00010000 }
    adam2env	{ "Adam2 environment"		0x903f0000 0x00010000 }
}

source [find target/ti-ar7.cfg]

# External 4MB MXIC 29LV320MBTC Flash (Manufacturer/Device: 0x00c2 0x227e)
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x90000000 0x00400000 2 2 $_TARGETNAME
#
# Linksys WRT54GL v1.1
#

source [find target/bcm5352e.cfg]

set partition_list {
    CFE		{ Bootloader			0x1c000000 0x00040000 }
    firmware	{ "Kernel+rootfs"		0x1c040000 0x003b0000 }
    nvram	{ "Config space"		0x1c3f0000 0x00010000 }
}

# External 4MB NOR Flash (Intel TE28F320C3BD90 or similar)
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x1c000000 0x00400000 2 2 $_TARGETNAME
# This is for the LinkSys (CISCO) NSLU2 board
# It is an Intel XSCALE IXP420 CPU.

source [find target/ixp42x.cfg]
# The _TARGETNAME is set by the above.

$_TARGETNAME configure -work-area-phys 0x00020000 -work-area-size 0x10000 -work-area-backup 0
# the Lost Illusions Serendipitous Autopilot
# http://paparazzi.enac.fr/wiki/Lisa

# Work-area size (RAM size) = 20kB for STM32F103RB device
set WORKAREASIZE 0x5000

source [find target/stm32f1x.cfg]
# The LogicPD Eval IMX27 eval board has a single IMX27 chip
source [find target/imx27.cfg]

# The Logic PD board has a NOR flash on CS0
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xc0000000 0x00200000 2 2 $_TARGETNAME

#
# FIX ME, Add support to
#
# (A) hard reset the board.
# (B) Initialize the SDRAM on the board
#
#
# Generic LPC1850 board w/ SPIFI flash.
# This config file is intended as an example of how to
# use the lpcspifi flash driver, but it should be functional
# for most LPC1850 boards utilizing SPIFI flash.

set CHIPNAME lpc1850

source [find target/lpc1850.cfg]

#A large working area greatly reduces flash write times
set _WORKAREASIZE 0x4000

$_CHIPNAME.m3 configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE

#Configure the flash bank; 0x14000000 is the base address for
#lpc43xx/lpc18xx family micros.
flash bank SPIFI_FLASH lpcspifi 0x14000000 0 0 0 $_CHIPNAME.m3
#
# Generic LPC4350 board w/ SPIFI flash.
# This config file is intended as an example of how to
# use the lpcspifi flash driver, but it should be functional
# for most LPC4350 boards utilizing SPIFI flash.

set CHIPNAME lpc4350

source [find target/lpc4350.cfg]

#Configure the flash bank; 0x14000000 is the base address for
#lpc43xx/lpc18xx family micros.
flash bank SPIFI_FLASH lpcspifi 0x14000000 0 0 0 $_CHIPNAME.m4
# Intel "Lubbock" Development Board with PXA255 (dbpxa255)
#  Obsolete; this was Intel's original PXA255 development system
#  Board also had CPU cards for SA1100, PXA210, PXA250, and more.

source [find target/pxa255.cfg]

adapter srst delay 250
jtag_ntrst_delay 250

# NOTE: until after pinmux and such are set up, only CS0 is
# available ... not 2nd bank of CFI, or FPGA, SRAM, ENET, etc.

# CS0, CS1 -- two banks of CFI flash, 32 MBytes each
# each bank is 32-bits wide, two 16-bit chips in parallel
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME cfi 0x00000000 0x02000000 2 4 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME cfi 0x04000000 0x02000000 2 4 $_TARGETNAME

# CS2 low -- FPGA registers
# CS2 high -- 1 MByte SRAM at 0x0a00.0000 ... last 64K for scratch
$_TARGETNAME configure -work-area-phys 0x0a0f0000

$_TARGETNAME configure -event reset-assert-pre \
	"$_TARGETNAME configure -work-area-size 0"

# Make the hex led display a number, assuming CS2 is set up
# and all digits have been enabled through the FPGA.
proc hexled {u32} {
	mww 0x08000010 $u32
}

# CS3 -- Ethernet
# CS4 -- SA1111
# CS5 -- PCMCIA

# NOTE:  system console normally uses the FF UART connector

proc lubbock_init {target} {

	echo "Initialize PXA255 Lubbock board"

	# (1) pinmux

	# GPSR0..GPSR2
	mww 0x40e00018 0x00008000
	mww 0x40e0001c 0x00FC0382
	mww 0x40e00020 0x0001FFFF
	# GPDR0..GPDR2
	mww 0x40e0000c 0x0060A800
	mww 0x40e00010 0x00FF0382
	mww 0x40e00014 0x0001C000
	# GAFR0_[LU]..GAFR2_[LU]
	mww 0x40e00054 0x98400000
	mww 0x40e00058 0x00002950
	mww 0x40e0005c 0x000A9558
	mww 0x40e00060 0x0005AAAA
	mww 0x40e00064 0xA0000000
	mww 0x40e00068 0x00000002

	# write PSSR, enable GPIOs
	mww 0x40f00000 0x00000020

	# write LED ctrl register ... ones disable
	# high byte, 8 hex leds; low byte, 8 discretes
	mwh 0x08000040 0xf0ff

	hexled 0x0000

	# (2) Address space setup

	# MSC0/MSC1/MSC2
	mww 0x48000008 0x23f223f2
	mww 0x4800000c 0x3ff1a441
	mww 0x48000010 0x7ff97ff1
	# pcmcia/cf
	mww 0x48000014 0x00000000
	mww 0x48000028 0x00010504
	mww 0x4800002c 0x00010504
	mww 0x48000030 0x00010504
	mww 0x48000034 0x00010504
	mww 0x48000038 0x00004715
	mww 0x4800003c 0x00004715

	hexled 0x1111

	# (3) SDRAM setup
	# REVISIT this looks dubious ... no refresh cycles
	mww 0x48000004 0x03CA4018
	mww 0x48000004 0x004B4018
	mww 0x48000004 0x000B4018
	mww 0x48000004 0x000BC018
	mww 0x48000000 0x00001AC8
	mww 0x48000000 0x00001AC9

	mww 0x48000040 0x00000000

	# FIXME -- setup:
	#  CLOCKS (and faster JTAG)
	#  enable icache

	# FIXME SRAM isn't working
	# $target configure -work-area-size 0x10000

	hexled 0x2222

	flash probe 0
	flash probe 1

	hexled 0xcafe
}
$_TARGETNAME configure -event reset-init "lubbock_init $_TARGETNAME"
#
# Marsohod CPLD Development and Education board
#
# http://marsohod.org/howtostart/plata
#

# Recommended MBFTDI programmer
source [find interface/ftdi/mbftdi.cfg]
adapter speed 2000
transport select jtag

# Altera MAXII EPM240T100C CPLD
source [find cpld/altera-epm240.cfg]
#
# Marsohod2 FPGA Development and Education board
#
# http://www.marsohod.org/prodmarsohod2
#

# Built-in MBFTDI programmer
source [find interface/ftdi/mbftdi.cfg]
adapter speed 2000
transport select jtag

# Cyclone III EP3C10E144 FPGA
source [find fpga/altera-ep3c10.cfg]
#
# Marsohod3 FPGA Development and Education board
#
# http://www.marsohod.org/plata-marsokhod3
#

# Built-in MBFTDI programmer
source [find interface/ftdi/mbftdi.cfg]
adapter speed 2000
transport select jtag

# MAX10 10M50SAE144C8GES FPGA
source [find fpga/altera-10m50.cfg]
# This is an mbed eval board with a single NXP LPC11U24 chip.
# http://mbed.org/handbook/mbed-NXP-LPC11U24
#

source [find interface/cmsis-dap.cfg]

# NXP LPC11U24 Cortex-M0 with 32kB Flash and 8kB SRAM
set WORKAREASIZE 0x2000

source [find target/lpc11xx.cfg]
# This is an mbed eval board with a single NXP LPC1768 chip.
# http://mbed.org/handbook/mbed-NXP-LPC1768
#

source [find interface/cmsis-dap.cfg]

source [find target/lpc17xx.cfg]
# Keil MCB1700 PCB with 1768
#
# Reset init script sets it to 100MHz
set CCLK 100000

source [find target/lpc17xx.cfg]

global MCB1700_CCLK
set MCB1700_CCLK $CCLK

$_TARGETNAME configure -event reset-start {
	# Start *real slow* as we do not know the
    # state the boot rom left the clock in
	adapter speed 10
}

# Set up 100MHz clock to CPU
$_TARGETNAME configure -event reset-init {
    # PLL0CON: Disable PLL
	mww 0x400FC080 0x00000000
    # PLLFEED
	mww 0x400FC08C 0x000000AA
    # PLLFEED
	mww 0x400FC08C 0x00000055

    # CCLK=PLL/4 (=100 MHz)
	mww 0x400FC104 0x00000003
    # CLKSRCSEL: Clock source = internal RC oscillator
	mww 0x400FC10C 0x00000000

    # PLL0CFG: M=50,N=1 -> PLL=400 MHz
	mww 0x400FC084 0x00000031
    # PLLFEED
	mww 0x400FC08C 0x000000AA
    # PLLFEED
	mww 0x400FC08C 0x00000055

	# PLL0CON: Enable PLL
	mww 0x400FC080 0x00000001
    # PLLFEED
	mww 0x400FC08C 0x000000AA
    # PLLFEED
	mww 0x400FC08C 0x00000055

	sleep 50

    # PLL0CON: Connect PLL
	mww 0x400FC080 0x00000003
    # PLLFEED
	mww 0x400FC08C 0x000000AA
    # PLLFEED
	mww 0x400FC08C 0x00000055

	# Dividing CPU clock by 8 should be pretty conservative
	#
	#
	global MCB1700_CCLK
	adapter speed [expr $MCB1700_CCLK / 8]

	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
	# "User Flash Mode" where interrupt vectors are _not_ remapped,
	# and reside in flash instead).
	#
	# See Table 612. Memory Mapping Control register (MEMMAP - 0x400F C040) bit description
	# Bit Symbol Value Description Reset
	# value
	# 0 MAP Memory map control. 0
	# 0 Boot mode. A portion of the Boot ROM is mapped to address 0.
	# 1 User mode. The on-chip Flash memory is mapped to address 0.
	# 31:1 - Reserved. The value read from a reserved bit is not defined. NA
	#
	# http://ics.nxp.com/support/documents/microcontrollers/?scope=LPC1768&type=user

	mww 0x400FC040 0x01
}
# Microchip Explorer 16 with PIC32MX360F512L PIM module.
# http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=1406&dDocName=en024858

# TAPID for PIC32MX360F512L
set CPUTAPID 0x30938053

# use 32k working area
set WORKAREASIZE 32768

source [find target/pic32mx.cfg]
#
# Microchip (former Atmel) SAM E54 Xplained Pro evaluation kit.
# http://www.microchip.com/developmenttools/productdetails.aspx?partno=atsame54-xpro
#

source [find interface/cmsis-dap.cfg]

set CHIPNAME same54

source [find target/atsame5x.cfg]

reset_config srst_only
#
# Microchip (formerly Atmel) SAM L11 Xplained Pro Evaluation Kit.
# https://www.microchip.com/DevelopmentTools/ProductDetails/dm320205
#

source [find interface/cmsis-dap.cfg]
adapter speed 1000

set CHIPNAME saml11
source [find target/atsaml1x.cfg]
#-------------------------------------------------------------------------
# Mini2440 Samsung s3c2440A Processor with 64MB DRAM, 64MB NAND, 2 MB N0R
# NOTE: Configured for NAND boot (switch S2 in NANDBOOT)
# 64 MB NAND (Samsung K9D1208V0M)
# B Findlay  08/09
#
#   ----------- Important notes to help you on your way ----------
# README:
#     NOR/NAND Boot Switch - I have not read the vivi source, but from
#     what I could tell from reading the registers it appears that vivi
#     loads itself into DRAM and then flips NFCONT (0x4E000004) bits
#     Mode (bit 0 = 1), and REG_nCE (bit 1 = 0) which maps the NAND
#     FLASH at the bottom 64MB of memory. This essentially takes the
#     NOR Flash out of the circuit so you can't trash it.
#
#     I adapted the samsung_s3c2440.cfg file which is why I did not
#     include "source [find target/samsung_s3c2440.cfg]".  I believe
#     the -work-area-phys 0x200000 is incorrect, but also had to pad
#     some additional resets.  I didn't modify it as if it is working
#     for someone, the work-area-phys is not used by most.
#
#     JTAG ADAPTER SPECIFIC
#     IMPORTANT! Any JTAG device that uses ADAPTIVE CLOCKING will likely
#     FAIL as the pin RTCK on the mini2440 10 pin JTAG Conn doesn't exist.
#     This is Pin 11 (RTCK) on 20 pin JTAG connector. Therefore it is
#     necessary to FORCE setting the clock. Normally this should be configured
#     in the openocd.cfg file, but was placed here as it can be a tough
#     problem to figure out.  THIS MAY NOT FIX YOUR PROBLEM.. I modified
#     the openOCD driver jlink.c and posted it here. It may eventually end
#     up changed in openOCD, but its a hack in the driver and really should
#     be in the jtag layer (core.c me thinks), but haven't done it yet. My
#     hack for jlink.c may be found here.
#
#     http://forum.sparkfun.com/viewtopic.php?t=16763&sid=946e65abdd3bab39cc7d90dee33ff135
#
#     Note: Also if you have a USB JTAG, you will need the USB library installed
#     on your system "libusb-dev" or the make of openocd will fail. I *think*
#     it's apt-get install libusb-dev.  When I made my config I only included
#     --enable-jlink and --enable-usbdevs
#
#     I HAVE NOT Tested this throughly, so there could still be problems.
#     But it should get you way ahead of the game from where I started.
#     If you find problems (and fixes) please post them to
#     openocd-development@lists.berlios.de and join the developers and
#     check in fixes to this and anything else you find.  I do not
#     provide support, but if you ask really nice and I see anything
#     obvious I will tell you.. mostly just dig, fix, and submit to openocd.
#
#     best!   brfindla@yahoo.com   Nashua, NH USA
#
#     Recommended resources:
#       - first two are the best Mini2440 resources anywhere
#       - maintained by buserror... thanks guy!
#
#       http://bliterness.blogspot.com/
#       http://code.google.com/p/mini2440/
#
#       others....
#
#       http://forum.sparkfun.com/viewforum.php?f=18
#       http://labs.kernelconcepts.de/Publications/Micro24401/
#       http://www.friendlyarm.net/home
#       http://www.amontec.com/jtag_pinout.shtml
#
#-------------------------------------------------------------------------
#
#
# Your openocd.cfg file should contain:
# source [find interface/<yourjtag>.cfg]
# source [find board/mini2440.cfg]
#
#
#

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

#-------------------------------------------------------------------------
# Target configuration for the Samsung 2440 system on chip
# Tested on a S3C2440 Evaluation board by keesj
# Processor : ARM920Tid(wb) rev 0 (v4l)
# Info: JTAG tap: s3c2440.cpu tap/device found: 0x0032409d
#  (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
#-------------------------------------------------------------------------

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME s3c2440
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
  # this defaults to a bigendian
   set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0032409d
}

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x40000000  -work-area-size 0x4000 -work-area-backup 1

#reset configuration
adapter srst delay 100
jtag_ntrst_delay 100
reset_config trst_and_srst

#-------------------------------------------------------------------------
# JTAG ADAPTER SPECIFIC
# IMPORTANT! See README at top of this file.
#-------------------------------------------------------------------------

    adapter speed 12000
    jtag interface

#-------------------------------------------------------------------------
# GDB Setup
#-------------------------------------------------------------------------

    gdb_breakpoint_override hard

#------------------------------------------------
# ARM SPECIFIC
#------------------------------------------------

    targets
  #  arm7_9 dcc_downloads enable
  #  arm7_9 fast_memory_access enable


    nand device s3c2440 0

    adapter srst delay 100
    jtag_ntrst_delay 100
    reset_config trst_and_srst
    init

    echo " "
    echo "-------------------------------------------"
    echo "--- login with - telnet localhost 4444  ---"
    echo "--- then type help_2440                 ---"
    echo "-------------------------------------------"
    echo " "



#------------------------------------------------
# Processor Initialialization
# Note: Processor writes can only occur when
# the state is in SYSTEM. When you call init_2440
# one of the first lines will tell you what state
# you are in. If a linux image is booting
# when you run this, it will not work
# a vivi boot loader will run with this just
# fine. The reg values were obtained by a combination
# of figuring them out fromt the manual, and looking
# at post vivi values with the debugger. Don't
# place too much faith in them, but seem to work.
#------------------------------------------------

proc init_2440 { } {

    halt
    s3c2440.cpu curstate

    #-----------------------------------------------
    # Set Processor Clocks - mini2440 xtal=12mHz
    # we set main clock for 405mHZ
    # we set the USB Clock for 48mHz
    # OM2 OM3 pulled to ground so main clock and
    # usb clock are off 12mHz xtal
    #-----------------------------------------------

    mww phys 0x4C000014 0x00000005 ;#  Clock Divider control Reg
    mww phys 0x4C000000 0xFFFFFFFF ;#  LOCKTIME count register
    mww phys 0x4C000008 0x00038022 ;#  UPPLCON  USB clock config Reg
    mww phys 0x4C000004 0x0007F021 ;#  MPPLCON  Proc clock config Reg

    #-----------------------------------------------
    # Configure Memory controller
    # BWSCON configures all banks, NAND, NOR, DRAM
    # DRAM - 64MB - 32 bit bus, uses BANKCON6 BANKCON7
    #-----------------------------------------------

    mww phys 0x48000000 0x22111112 ;#  BWSCON - Bank and Bus Width
    mww phys 0x48000010 0x00001112 ;#  BANKCON4 - ?
    mww phys 0x4800001c 0x00018009 ;#  BANKCON6 - DRAM
    mww phys 0x48000020 0x00018009 ;#  BANKCON7 - DRAM
    mww phys 0x48000024 0x008E04EB ;#  REFRESH  - DRAM
    mww phys 0x48000028 0x000000B2 ;#  BANKSIZE - DRAM
    mww phys 0x4800002C 0x00000030 ;#  MRSRB6 - DRAM
    mww phys 0x48000030 0x00000030 ;#  MRSRB7 - DRAM

    #-----------------------------------------------
    # Now port configuration for enables for memory
    # and other stuff.
    #-----------------------------------------------

    mww phys 0x56000000	0x007FFFFF ;#  GPACON

    mww phys 0x56000010	0x00295559 ;#  GPBCON
    mww phys 0x56000018	0x000003FF ;#  GPBUP (PULLUP ENABLE)
    mww phys 0x56000014	0x000007C2 ;#  GPBDAT

    mww phys 0x56000020	0xAAAAA6AA ;#  GPCCON
    mww phys 0x56000028	0x0000FFFF ;#  GPCUP
    mww phys 0x56000024	0x00000020 ;#  GPCDAT

    mww phys 0x56000030	0xAAAAAAAA ;#  GPDCON
    mww phys 0x56000038	0x0000FFFF ;#  GPDUP

    mww phys 0x56000040	0xAAAAAAAA ;#  GPECON
    mww phys 0x56000048	0x0000FFFF ;#  GPEUP

    mww phys 0x56000050	0x00001555 ;#  GPFCON
    mww phys 0x56000058	0x0000007F ;#  GPFUP
    mww phys 0x56000054	0x00000000 ;#  GPFDAT

    mww phys 0x56000060	0x00150114 ;#  GPGCON
    mww phys 0x56000068	0x0000007F ;#  GPGUP

    mww phys 0x56000070	0x0015AAAA ;#  GPHCON
    mww phys 0x56000078	0x000003FF ;#  GPGUP

}



proc flash_config { } {

    #-----------------------------------------
    # Finish Flash Configuration
    #-----------------------------------------

    halt

    #flash configuration (K9D1208V0M: 512Mbit, x8, 3.3V, Mode: Normal, 1st gen)
    nand probe 0
    nand list
}

proc flash_uboot { } {

	# flash the u-Boot binary and reboot into it
	init_2440
	flash_config
	nand erase 0 0x0 0x40000
	nand write 0 /tftpboot/u-boot-nand512.bin 0 oob_softecc_kw
	resume
}


proc load_uboot { } {
        echo " "
        echo " "
        echo "----------------------------------------------------------"
        echo "---- Load U-Boot into RAM and execute it.              ---"
        echo "---- NOTE: loads, partially runs, and hangs            ---"
        echo "---- U-Boot is fine, this image runs from vivi.        ---"
        echo "---- I burned u-boot into NAND so I didn't finish      ---"
        echo "---- debugging it. I am leaving this here as it is     ---"
        echo "---- part of the way there if you want to fix it.      ---"
        echo "----                                                   ---"
        echo "---- mini2440 U-boot here:                             ---"
        echo "---- http://repo.or.cz/w/u-boot-openmoko/mini2440.git  ---"
        echo "---- Also this:                                        ---"
        echo "---- http://code.google.com/p/mini2440/wiki/MiniBringup --"
        echo "----------------------------------------------------------"

	init_2440
	echo "Loading /tftpboot/u-boot-nand512.bin"
	load_image /tftpboot/u-boot-nand512.bin 0x33f80000 bin
	echo "Verifying image...."
	verify_image /tftpboot/u-boot-nand512.bin 0x33f80000 bin
	echo "jumping to u-boot"
        #bp 0x33f80068 4 hw
        reg 0 0
        reg 1 0
        reg 2 0
        reg 3 0
        reg 4 0x33f80000
      	resume 0x33f80000
}

       # this may help a little bit debugging the load_uboot
proc s {} {
        step
        reg
        arm disassemble 0x33F80068 0x10
}

proc help_2440 {} {
    echo " "
    echo " "
    echo "-----------------------------------------------------------"
    echo "---- The following mini2440 funcs are supported        ----"
    echo "----   init_2440 - initialize clocks, DRAM, IO         ----"
    echo "----   flash_config - configures nand flash            ----"
    echo "----   load_uboot - loads uboot into ram               ----"
    echo "----   flash_uboot - flashes uboot to nand (untested)  ----"
    echo "----   help_2440 - this help display                   ----"
    echo "-----------------------------------------------------------"
    echo " "
    echo " "
}


#----------------------------------------------------------------------------
#----------------------------------- END ------------------------------------
#----------------------------------------------------------------------------
# Target configuration for the Samsung s3c6410 system on chip
# Tested on a tiny6410
# Processor       : ARM1176
# Info : JTAG tap: s3c6410.etb tap/device found: 0x2b900f0f (mfg: 0x787, part: 0xb900, ver: 0x2)
# Info : JTAG tap: s3c6410.cpu tap/device found: 0x07b76f0f (mfg: 0x787, part: 0x7b76, ver: 0x0)

source [find target/samsung_s3c6410.cfg]

proc init_6410 {} {
	halt
	reg cpsr 0x1D3
	arm mcr 15 0 15 2 4 0x70000013

	#-----------------------------------------------
	# Clock and Timer Setting
	#-----------------------------------------------
	mww 0x7e004000 0		;# WATCHDOG 	- Disable
	mww 0x7E00F120 0x0003		;# MEM_SYS_CFG	- CS0:8 bit, Mem1:32bit, CS2=NAND
	#mww 0x7E00F120 0x1000		;# MEM_SYS_CFG	- CS0:16bit, Mem1:32bit, CS2=SROMC
	#mww 0x7E00F120 0x1002		;# MEM_SYS_CFG	- CS0:16bit, Mem1:32bit, CS2=OND
	mww 0x7E00F900 0x805e		;# OTHERS	- Change SYNCMUX[6] to 1
	sleep 1000
	mww 0x7E00F900 0x80de		;# OTHERS	- Assert SYNCREQ&VICSYNCEN to 1(rb1004modify)
	sleep 1000			;#		- Others[11:8] to 0xF
	mww 0x7E00F000 0xffff		;# APLL_LOCK	- APLL LockTime
	mww 0x7E00F004 0xffff		;# MPLL_LOCK	- MPLL LockTime
	mww 0x7E00F020 0x1047310	;# CLK_DIV0 	- ARMCLK:HCLK:PCLK = 1:4:16
	mww 0x7E00F00c 0x81900302	;# APLL_CON 	- A:400, P:3, S:2 => 400MHz
	mww 0x7E00F010 0x81900303	;# MPLL_CON 	- M:400, P:3, S:3 => 200MHz
	mww 0x7E00F01c 0x3		;# CLK_SRC 	- APLL,MPLL Clock Select

	#-----------------------------------------------
	# DRAM initialization
	#-----------------------------------------------
	mww 0x7e001004 0x4		;# P1MEMCCMD	- Enter the config state
	mww 0x7e001010 0x30C		;# P1REFRESH	- Refresh Period register (7800ns), 100MHz
#	mww 0x7e001010 0x40e		;# P1REFRESH	- Refresh Period register (7800ns), 133MHz
	mww 0x7e001014 0x6		;# P1CASLAT	- CAS Latency = 3
	mww 0x7e001018 0x1		;# P1T_DQSS
	mww 0x7e00101c 0x2		;# P1T_MRD
	mww 0x7e001020 0x7		;# P1T_RAS	- 45 ns
	mww 0x7e001024 0xA		;# P1T_RC	- 67.5 ns
	mww 0x7e001028 0xC		;# P1T_RCD	- 22.5 ns
	mww 0x7e00102C 0x10B		;# P1T_RFC	- 80 ns
	mww 0x7e001030 0xC		;# P1T_RP	- 22.5 ns
	mww 0x7e001034 0x3		;# P1T_RRD	- 15 ns
	mww 0x7e001038 0x3		;# P1T_WR	- 15 ns
	mww 0x7e00103C 0x2		;# P1T_WTR
	mww 0x7e001040 0x2		;# P1T_XP
	mww 0x7e001044 0x11		;# P1T_XSR	- 120 ns
	mww 0x7e001048 0x11		;# P1T_ESR

	#-----------------------------------------------
	# Memory Configuration Registers
	#-----------------------------------------------
	mww 0x7e00100C 0x00010012 	;# P1MEMCFG	- 1 CKE, 1Chip, 4burst, Alw, AP[10],ROW/Column bit
	mww 0x7e00104C 0x0B41 		;# P1MEMCFG2	- Read delay 1 Cycle, mDDR, 32bit, Sync.
	mww 0x7e001200 0x150F0 		;# CHIP_N_CFG	- 0x150F0 for 256M, 0x150F8 for 128M

	#-----------------------------------------------
	# Memory Direct Commands
	#-----------------------------------------------
	mww 0x7e001008 0xc0000		;# Chip0 Direct Command :NOP5
	mww 0x7e001008 0x0		;# Chip0 Direct Command :PreCharge al
	mww 0x7e001008 0x40000		;# Chip0 Direct Command :AutoRefresh
	mww 0x7e001008 0x40000		;# Chip0 Direct Command :AutoRefresh
	mww 0x7e001008 0xA0000		;# EMRS, DS:Full, PASR:Full
	mww 0x7e001008 0x80032		;# MRS, CAS3, BL4
	mww 0x7e001004 0x0		;# Enable DMC1
}

proc install_6410_uboot {} {
	# write U-boot magic number
	mww 0x50000000 0x24564236
	mww 0x50000004 0x20764316
	load_image u-boot_nand-ram256.bin 0x50008000 bin
	load_image u-boot_nand-ram256.bin 0x57E00000 bin

	#Kick in
	reg pc 0x57E00000
	resume
}

proc init_6410_flash {} {
	halt
	nand probe 0
	nand list
}


adapter speed 1000
adapter srst delay 100
jtag_ntrst_delay 100
reset_config trst_and_srst

gdb_breakpoint_override hard

targets
nand device $_CHIPNAME.flash s3c6400 $_CHIPNAME.cpu

init
echo " "
echo " "
echo "-------------------------------------------------------------------"
echo "---- The following mini6410/tiny6410 functions are available:  ----"
echo "----   init_6410 - initialize clock, timer, DRAM               ----"
echo "----   init_6410_flash - initializes NAND flash support        ----"
echo "----   install_6410_uboot - copies u-boot image into RAM and   ----"
echo "----                        runs it                            ----"
echo "-------------------------------------------------------------------"
echo " "
echo " "
# https://www.scarabhardware.com/minispartan6/

source [find interface/ftdi/minispartan6.cfg]
source [find cpld/xilinx-xc6s.cfg]
source [find cpld/jtagspi.cfg]

# example command to read the device dna of the FPGA on the board;
# openocd -f board/minispartan6.cfg -c "init;xc6s_print_dna xc6s.tap;shutdown"

# example command to write bitstream
# openocd -f board/minispartan6.cfg -c "init;\
# jtagspi_init 0 bscan_spi_xc6slx??.bit;\
# jtagspi_program bitstream.bin 0;\
# xc6s_program xc6s.tap;\
# shutdown"
#
# jtagspi flash procies can be found in the contrib/loaders/flash/fpga/
# directory, with prebuilt versions available at
# https://github.com/jordens/bscan_spi_bitstreams
#
# For the SLX25 variant, use
#  - https://github.com/jordens/bscan_spi_bitstreams/raw/master/bscan_spi_xc6slx25.bit
# For the SLX9 variant, use
#  - https://github.com/jordens/bscan_spi_bitstreams/raw/master/bscan_spi_xc6slx9.bit
# SPDX-License-Identifier: GPL-2.0-or-later
# ADP-Corvette-F1 R1.0
# http://www.andestech.com/en/products-solutions/andeshape-platforms/corvette-f1-r1/
# ADP-Corvette-F1 R2.0
# http://www.andestech.com/en/products-solutions/andeshape-platforms/corvette-f1-r2/

adapter_khz     10000

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
reset_config srst_only

source [find target/nds32v5.cfg]
set _CPUTAPID 0x1000063d
set _CHIPNAME nds32
source [find target/nds32v3.cfg]

jtag init
# SPDX-License-Identifier: GPL-2.0-or-later
# ADP-XC7K160/410
# http://www.andestech.com/en/products-solutions/andeshape-platforms/adp-xc7k160-410/

source [find target/nds32v5.cfg]
#
# Netgear DG834v3 Router
# Internal 4Kb RAM (@0x80000000)
# Flash is located at 0x90000000 (CS0) and RAM is located at 0x94000000 (CS1)
#

set partition_list {
    loader	{ "Bootloader (ADAM2)"		0x90000000 0x00020000 }
    firmware	{ "Kernel+rootfs"		0x90020000 0x003d0000 }
    config	{ "Bootloader config space"	0x903f0000 0x00010000 }
}

source [find target/ti-ar7.cfg]

# External 16MB SDRAM - disabled as we use internal sram
#$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x00001000

# External 4MB NOR Flash
set _FLASHNAME $_CHIPNAME.norflash
flash bank $_FLASHNAME cfi 0x90000000 0x00400000 2 2 $_TARGETNAME
source [find target/atheros_ar2313.cfg]

reset_config trst_and_srst

$_TARGETNAME configure -event reset-init {
	mips32 cp0 12 0 0x10400000

	# configure sdram controller
	mww 0xb8300004 0x0e03
	sleep 100
	mww 0xb8300004 0x0e01
	mww 0xb8300008 0x10
	sleep 500
	mww 0xb8300004 0x0e02

	mww 0xb8300000 0x6c0088
	mww 0xb8300008 0x57e
	mww 0xb8300004 0x0e00
	mww 0xb8300004 0xb00

	# configure flash
	#                 0x00000001 - 0x01 << FLASHCTL_IDCY_S
	#                 0x000000e0 - 0x07 << FLASHCTL_WST1_S
	# FLASHCTL_RBLE   0x00000400 - Read byte lane enable
	#                 0x00003800 - 0x07 << FLASHCTL_WST2_S
	# FLASHCTL_AC_8M  0x00060000 - Size of flash
	# FLASHCTL_E      0x00080000 - Flash bank enable (added)
	# FLASHCTL_WP     0x04000000 - write protect. If used, CFI mode wont work!!
	# FLASHCTL_MWx16  0x10000000 - 16bit mode. Do not use it!!
	# FLASHCTL_MWx8   0x00000000 - 8bit mode.
	mww 0xb8400000 0x000d3ce1
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xbe000000 0x00400000 1 1 $_TARGETNAME x16_as_x8
#
# Nordic Semiconductor PCA10024 board (aka nRF51822-mKIT)
#

source [find interface/cmsis-dap.cfg]
source [find target/nrf51.cfg]
#
# Nordic Semiconductor NRF51 Development Kit (nRF6824)
#

source [find interface/jlink.cfg]

transport select swd

source [find target/nrf51.cfg]
#
# Nordic Semiconductor NRF52 Development Kit (nRF52832)
#

source [find interface/jlink.cfg]

transport select swd

source [find target/nrf52.cfg]
#
# nordic module NRF52 (nRF52832/52840) attached to an adafruit ft232h module
# or any FT232H/FT2232H/FT4232H based board/module
#

source [find interface/ftdi/ft232h-module-swd.cfg]
#source [find interface/ftdi/minimodule-swd.cfg]

transport select swd

source [find target/nrf52.cfg]
#
# Novena open hardware and F/OSS-friendly computing platform
#
# Design documentation:
# http://www.kosagi.com/w/index.php?title=Novena_PVT_Design_Source
#
# +-------------+--------------+------+-------+---------+
# | Pad name    | Schematic    | GPIO | sysfs | JTAG    |
# +-------------+--------------+------+-------+---------+
# | DISP0_DAT13 | FPGA_RESET_N | 5-07 |  135  | RESET_N |
# | DISP0_DAT14 | FPGA_TCK     | 5-08 |  136  | TCK     |
# | DISP0_DAT15 | FPGA_TDI     | 5-09 |  137  | TDI     |
# | DISP0_DAT16 | FPGA_TDO     | 5-10 |  138  | TDO     |
# | DISP0_DAT17 | FPGA_TMS     | 5-11 |  139  | TMS     |
# +-------------+--------------+------+-------+---------+

adapter driver sysfsgpio

transport select jtag

# TCK TMS TDI TDO
sysfsgpio_jtag_nums 136 139 137 138

source [find cpld/xilinx-xc6s.cfg]
#
# Numato Mimas A7 - Artix 7 FPGA Board
#
# https://numato.com/product/mimas-a7-artix-7-fpga-development-board-with-ddr-sdram-and-gigabit-ethernet
#
# Note: Connect external DC power supply if programming a heavy design onto FPGA.
#       Programming while powering via USB may lead to programming failure.
#       Therefore, prefer external power supply.

adapter driver ftdi
ftdi_device_desc "Mimas Artix 7 FPGA Module"
ftdi_vid_pid 0x2a19 0x1009

# channel 0 is for custom purpose by users (like uart, fifo etc)
# channel 1 is reserved for JTAG (by-default) or SPI (possible via changing solder jumpers)
ftdi_channel 1
ftdi_tdo_sample_edge falling


# FTDI Pin Layout
#
# +--------+-------+-------+-------+-------+-------+-------+-------+
# | DBUS7  | DBUS6 | DBUS5 | DBUS4 | DBUS3 | DBUS2 | DBUS1 | DBUS0 |
# +--------+-------+-------+-------+-------+-------+-------+-------+
# | PROG_B | OE_N  |  NC   |  NC   |  TMS  |  TDO  |  TDI  |  TCK  |
# +--------+-------+-------+-------+-------+-------+-------+-------+
#
# OE_N is JTAG buffer output enable signal (active-low)
# PROG_B is not used, so left as input to FTDI.
#
ftdi_layout_init 0x0008 0x004b
reset_config none
adapter speed 30000

source [find cpld/xilinx-xc7.cfg]
source [find cpld/jtagspi.cfg]
# http://opsis.hdmi2usb.tv
#
# The Numato Opsis is an FPGA based, open video platform.
#
# The board is supported via ixo-usb-jtag project. See the
# interface/usb-jtag.cfg for more information.

source [find interface/usb-jtag.cfg]
source [find cpld/xilinx-xc6s.cfg]
source [find cpld/jtagspi.cfg]
#
# NXP FRDM-LS1012A (Freedom)
#

#
# NXP Kinetis K20
#
source [find interface/cmsis-dap.cfg]
transport select jtag

# Also offers a 10-pin 0.05" CoreSight JTAG connector.

source [find target/ls1012a.cfg]

reset_config srst_only
# NXP IMX7SABRE board
# use on-board JTAG header
transport select jtag

# set a safe speed, can be overridden
adapter speed 1000

# reset configuration has TRST and SRST support
reset_config trst_and_srst srst_push_pull
# need at least 100ms delay after SRST release for JTAG
adapter srst delay 100

# source the target file
source [find target/imx7.cfg]
# import mrw proc
source [find mem_helper.tcl]

# function to disable the on-chip watchdog
proc imx7_disable_wdog { } {
        # echo "disable watchdog power-down counter"
        mwh phys 0x30280008 0x00
}

proc imx7_uart_dbgconf { } {
	# disable response to debug_req signal for uart1
	mww phys 0x308600b4 0x0a60
}

proc check_bits_set_32 { addr mask } {
    while { [expr [mrw $addr] & $mask == 0] } { }
}

proc apply_dcd { } {
    # echo "apply dcd"

    mww phys 0x30340004 0x4F400005
    # Clear then set bit30 to ensure exit from DDR retention
    mww phys 0x30360388 0x40000000
    mww phys 0x30360384 0x40000000

    mww phys 0x30391000 0x00000002
    mww phys 0x307a0000 0x01040001
    mww phys 0x307a01a0 0x80400003
    mww phys 0x307a01a4 0x00100020
    mww phys 0x307a01a8 0x80100004
    mww phys 0x307a0064 0x00400046
    mww phys 0x307a0490 0x00000001
    mww phys 0x307a00d0 0x00020083
    mww phys 0x307a00d4 0x00690000
    mww phys 0x307a00dc 0x09300004
    mww phys 0x307a00e0 0x04080000
    mww phys 0x307a00e4 0x00100004
    mww phys 0x307a00f4 0x0000033f
    mww phys 0x307a0100 0x09081109
    mww phys 0x307a0104 0x0007020d
    mww phys 0x307a0108 0x03040407
    mww phys 0x307a010c 0x00002006
    mww phys 0x307a0110 0x04020205
    mww phys 0x307a0114 0x03030202
    mww phys 0x307a0120 0x00000803
    mww phys 0x307a0180 0x00800020
    mww phys 0x307a0184 0x02000100
    mww phys 0x307a0190 0x02098204
    mww phys 0x307a0194 0x00030303
    mww phys 0x307a0200 0x00000016
    mww phys 0x307a0204 0x00171717
    mww phys 0x307a0214 0x04040404
    mww phys 0x307a0218 0x0f040404
    mww phys 0x307a0240 0x06000604
    mww phys 0x307a0244 0x00000001
    mww phys 0x30391000 0x00000000
    mww phys 0x30790000 0x17420f40
    mww phys 0x30790004 0x10210100
    mww phys 0x30790010 0x00060807
    mww phys 0x307900b0 0x1010007e
    mww phys 0x3079009c 0x00000d6e
    mww phys 0x30790020 0x08080808
    mww phys 0x30790030 0x08080808
    mww phys 0x30790050 0x01000010
    mww phys 0x30790050 0x00000010

    mww phys 0x307900c0 0x0e407304
    mww phys 0x307900c0 0x0e447304
    mww phys 0x307900c0 0x0e447306

    check_bits_set_32 0x307900c4 0x1

    mww phys 0x307900c0 0x0e447304
    mww phys 0x307900c0 0x0e407304


    mww phys 0x30384130 0x00000000
    mww phys 0x30340020 0x00000178
    mww phys 0x30384130 0x00000002
    mww phys 0x30790018 0x0000000f

    check_bits_set_32 0x307a0004 0x1
}

# disable internal reset-assert handling to
# allow reset-init to work
$_TARGETNAME.0 configure -event reset-assert ""
$_TARGETNAME.1 configure -event reset-assert ""
$_TARGETNAME_2 configure -event reset-assert ""

$_TARGETNAME.0 configure -event reset-init {
    global _CHIPNAME
    imx7_disable_wdog
    imx7_uart_dbgconf
    apply_dcd
    $_CHIPNAME.dap memaccess 0
}

target smp $_TARGETNAME.0 $_TARGETNAME.1
#
# NXP LPC-Link2
#
# http://www.nxp.com/board/OM13054.html
# https://www.lpcware.com/lpclink2
# http://embeddedartists.com/products/lpcxpresso/lpclink2.php
#

source [find target/lpc4370.cfg]

# W25Q80BVSSIG w/ 1 MB flash
flash bank SPIFI_FLASH lpcspifi 0x14000000 0 0 0 $_CHIPNAME.m4
#
# configuration file for NXP MC-IMX8M-EVK
#

# only JTAG supported
transport select jtag

# set a safe JTAG clock speed, can be overridden
adapter speed 1000

# default JTAG configuration has only SRST and no TRST
reset_config srst_only srst_push_pull

# delay after SRST goes inactive
adapter srst delay 70

# board has an i.MX8MQ with 4 Cortex-A53 cores
set CHIPNAME imx8mq
set CHIPCORES 4

# source SoC configuration
source [find target/imx8m.cfg]
#####################################################
# Olimex LPC2378STK eval board
#
# http://olimex.com/dev/lpc-2378stk.html
#
# Author: Sten, debian@sansys-electronic.com
#####################################################
#

source [find target/lpc2378.cfg]
#
# Olimex LPC-H2148 eval board
#
# http://www.olimex.com/dev/lpc-h2148.html
#

source [find target/lpc2148.cfg]
# Olimex SAM7-EX256 has a single Atmel at91sam7ex256 on it.

source [find target/at91sam7x256.cfg]
source [find target/at91sam7a2.cfg]

# delays needed to get stable reads of cpu state
jtag_ntrst_delay 10
adapter srst delay 200

# board uses pullup and connects only srst
reset_config srst_open_drain

# srst is connected to NRESET of CPU and fully resets everything...
reset_config srst_only srst_pulls_trst

adapter speed 1
$_TARGETNAME configure -event reset-start {
	adapter speed 1
}

$_TARGETNAME configure -event reset-init {
	# init script from http://www.mikrocontroller.net/topic/107462
	# AT91SAM7A2
	# AMC (advanced memory controller)

	echo "setting up AMC"
	# AMC_CS0 - FLASH 1MB (0x40000000-0x400FFFFF) + DM9000E (0x40100000)
	mww 0xFFE00000 0x40003EBD

	# AMC_CS1 - RAM low 2MB (0x40400000-0x405FFFFF)
	mww 0xFFE00004 0x404030A9

	# AMC_CS2 - RAM high 2MB (0x40800000-0x405FFFFF)
	#mww 0xFFE00008 0x404030A9
	# changed to  0x40_8_
	mww 0xFFE00008 0x408030A9

	# AMC_MCR
	mww 0xFFE00024 0x00000004

	# AMC_RCR force remap
	mww 0xFFE00020 0x00000001

	echo "set up AMC"
	sleep 100

	# the following base addresses from the original script did not correspond to those from datasheet
	# changed bases from 0xFF000000 to 0xFFF00000

	# disable watchdog, to prevent unwanted resets
	mww 0xFFFA0068 0x00000000
	echo "disabled watchdog"

	sleep 50

	# disable PLL
	mww 0xFFFEC004 0x18070004

	# PLL = 10 ==> Coreclock = 6Mhz*10/2 = 30 Mhz
	mww 0xFFFEC010 0x762D800A

	# enable PLL
	mww 0xFFFEC000 0x23050004
	echo "set up pll"

	sleep 100
	adapter speed 5000
}

$_TARGETNAME arm7_9 dcc_downloads enable
$_TARGETNAME arm7_9 fast_memory_access enable

# remap:  ram at 0, flash at 0x40000000, like reset-init above does
$_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x4000 -work-area-backup 1
flash bank onboard.flash cfi 0x40000000 0x00100000 2 2 at91sam7a2.cpu

# boot: ram at 0x300000, flash at 0x0, useful if board is in funny configuration
#$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
#flash bank onboard1.flash cfi 0x00000000 0x00100000 2 2 at91sam7a2.cpu
################################################################################
# Olimex SAM9-L9260 Development Board
#
# http://www.olimex.com/dev/sam9-L9260.html
#
# Atmel AT91SAM9260 : PLLA = 198.656 MHz, MCK = 99.328 MHz
#                     PMC configured for external 18.432 MHz crystal
#
# 32-bit SDRAM : 2 x Samsung K4S561632J-UC75, 4M x 16Bit x 4 Banks
# 8-bit NAND Flash : 1 x Samsung K9F4G08U0M, 512M x 8Bit
# Dataflash : 1 x Atmel AT45DB161D, 16Mbit
#
################################################################################

source [find target/at91sam9260.cfg]

# NTRST_E jumper is enabled by default, so we don't need to override the reset
# config.
#reset_config srst_only

$_TARGETNAME configure -event reset-start {
	# At reset, CPU runs at 32.768 kHz.  JTAG frequency must be 6 times slower if
	# RCLK is not supported.
	jtag_rclk 5
	halt

	# RSTC_MR : enable user reset, reset length is 64 slow clock cycles.  MMU may
	# be enabled... use physical address.
	mww phys 0xfffffd08 0xa5000501
}

$_TARGETNAME configure -event reset-init {
	mww 0xfffffd44 0x00008000 ;# WDT_MR : disable watchdog

	##
	# Clock configuration for 99.328 MHz main clock.
	##
    echo "Setting up clock"
	mww 0xfffffc20 0x00004001 ;# CKGR_MOR : enable main oscillator, 512 slow clock startup
	sleep 20                  ;# wait 20 ms (need 15.6 ms for startup)
	mww 0xfffffc30 0x00000001 ;# PMC_MCKR : switch to main oscillator (18.432 MHz)
	sleep 10                  ;# wait 10 ms
	mww 0xfffffc28 0x2060bf09 ;# CKGR_PLLAR : 18.432 MHz / 9 * 97 = 198.656 MHz, 63 slow clock startup
	sleep 20                  ;# wait 20 ms (need 1.9 ms for startup)
	mww 0xfffffc30 0x00000101 ;# PMC_MCKR : no scale on proc clock, master is proc / 2
	sleep 10                  ;# wait 10 ms
	mww 0xfffffc30 0x00000102 ;# PMC_MCKR : switch to PLLA (99.328 MHz)

	# Increase JTAG speed to 6 MHz if RCLK is not supported.
	jtag_rclk 6000

	arm7_9 dcc_downloads enable ;# Enable faster DCC downloads.

	##
	# SDRAM configuration for 2 x Samsung K4S561632J-UC75, 4M x 16Bit x 4 Banks.
	##
    echo "Configuring SDRAM"
	mww 0xfffff870 0xffff0000 ;# PIOC_ASR : select peripheral function for D15..D31
	mww 0xfffff804 0xffff0000 ;# PIOC_PDR : disable PIO function for D15..D31

	mww 0xffffef1c 0x00010002 ;# EBI_CSA : assign EBI CS1 to SDRAM, VDDIOMSEL set for +3V3 memory

	mww 0xffffea08 0x85237259 ;# SDRAMC_CR : configure SDRAM for Samsung chips

	mww 0xffffea00 0x1        ;# SDRAMC_MR : issue NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2        ;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4        ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' command
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x3        ;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0        ;# SDRAMC_MR : normal mode
	mww 0x20000000 0

	mww 0xffffea04 0x2b6      ;# SDRAMC_TR : set refresh timer count to 7 us

    ##
    # NAND Flash Configuration for 1 x Samsung K9F4G08U0M, 512M x 8Bit.
    ##
    echo "Configuring NAND flash"
    mww 0xfffffc10 0x00000010 ;# PMC_PCER : enable PIOC clock
    mww 0xfffff800 0x00006000 ;# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
    mww 0xfffff810 0x00004000 ;# PIOC_OER : enable output on 14
    mww 0xfffff814 0x00002000 ;# PIOC_ODR : disable output on 13
    mww 0xfffff830 0x00004000 ;# PIOC_SODR : set 14 to disable NAND
    mww 0xfffff864 0x00002000 ;# PIOC_PUER : enable pull-up on 13

    mww 0xffffef1c 0x0001000A ;# EBI_CSA : assign EBI CS3 to NAND, same settings as before

    mww 0xffffec30 0x00010001 ;# SMC_SETUP3 : 1 clock cycle setup for NRD and NWE
    mww 0xffffec34 0x03030303 ;# SMC_PULSE3 : 3 clock cycle pulse for all signals
    mww 0xffffec38 0x00050005 ;# SMC_CYCLE3 : 5 clock cycle NRD and NWE cycle
    mww 0xffffec3C 0x00020003 ;# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW,
                               #             3 TDF cycles, no optimization

    mww 0xffffe800 0x00000001 ;# ECC_CR : reset the ECC parity registers
    mww 0xffffe804 0x00000002 ;# ECC_MR : page size is 2112 words (word is 8 bits)

    nand probe at91sam9260.flash

    ##
    # Dataflash configuration for 1 x Atmel AT45DB161D, 16Mbit
    ##
    echo "Setting up dataflash"
    mww 0xfffff404 0x00000807 ;# PIOA_PDR : disable PIO function for 0(SPI0_MISO), 1(SPI0_MOSI),
                               #            2(SPI0_SPCK), and 11(SPI0_NPCS1)
    mww 0xfffff470 0x00000007 ;# PIOA_ASR : select peripheral A function for 0, 1, and 2
    mww 0xfffff474 0x00000800 ;# PIOA_BSR : select peripheral B function for 11
    mww 0xfffffc10 0x00001000 ;# PMC_PCER : enable SPI0 clock

    mww 0xfffc8000 0x00000080 ;# SPI0_CR : software reset SPI0
    mww 0xfffc8000 0x00000080 ;# SPI0_CR : again to be sure
    mww 0xfffc8004 0x000F0011 ;# SPI0_MR : master mode with nothing selected

    mww 0xfffc8034 0x011a0302 ;# SPI0_CSR1 : capture on leading edge, 8-bits/tx. 33MHz baud,
                               #             250ns delay before SPCK, 250ns b/n tx

    mww 0xfffc8004 0x000D0011 ;# SPI0_MR : same config, select NPCS1
    mww 0xfffc8000 0x00000001 ;# SPI0_CR : enable SPI0
}

nand device at91sam9260.flash at91sam9 at91sam9260.cpu 0x40000000 0xffffe800
at91sam9 cle 0 22
at91sam9 ale 0 21
at91sam9 rdy_busy 0 0xfffff800 13
at91sam9 ce 0 0xfffff800 14
# Olimex STM32-H103 eval board
# http://olimex.com/dev/stm32-h103.html

# Work-area size (RAM size) = 20kB for STM32F103RB device
set WORKAREASIZE 0x5000

source [find target/stm32f1x.cfg]
#
# Olimex STM32-H107
#
# http://olimex.com/dev/stm32-h107.html
#

# Work-area size (RAM size) = 64kB for STM32F107VC device
set WORKAREASIZE 0x10000

source [find target/stm32f1x.cfg]
#
# Olimex STM32-P107
#
# http://olimex.com/dev/stm32-p107.html
#

# Work-area size (RAM size) = 64kB for STM32F107VC device
set WORKAREASIZE 0x10000

source [find target/stm32f1x.cfg]
# OMAP2420 SDP board ("H4")

source [find target/omap2420.cfg]

# NOTE: this assumes you're *NOT* using a TI-14 connector.
reset_config trst_and_srst separate

# Board configs can vary a *LOT* ... parts, jumpers, etc.
# This GP board boots from cs0 using NOR (2x32M), and also
# has 64M NAND on cs6.
flash bank h4.u10 cfi 0x04000000 0x02000000 2 2 $_TARGETNAME
flash bank h4.u11 cfi 0x06000000 0x02000000 2 2 $_TARGETNAME
# Marvell OpenRD

source [find interface/ftdi/openrd.cfg]
source [find target/feroceon.cfg]

adapter speed 2000

$_TARGETNAME configure \
	-work-area-phys 0x10000000 \
	-work-area-size 65536 \
	-work-area-backup 0

arm7_9 dcc_downloads enable

# this assumes the hardware default peripherals location before u-Boot moves it
set _FLASHNAME $_CHIPNAME.flash
nand device $_FLASHNAME orion 0 0xd8000000

proc openrd_init { } {

	# We need to assert DBGRQ while holding nSRST down.
	# However DBGACK will be set only when nSRST is released.
	# Furthermore, the JTAG interface doesn't respond at all when
	# the CPU is in the WFI (wait for interrupts) state, so it is
	# possible that initial tap examination failed.  So let's
	# re-examine the target again here when nSRST is asserted which
	# should then succeed.
	adapter assert srst
	feroceon.cpu arp_examine
	halt 0
	adapter deassert srst
	wait_halt

	arm mcr 15 0 0 1 0 0x00052078

	mww 0xD0001400 0x43000C30 ;#  DDR SDRAM Configuration Register
	mww 0xD0001404 0x37543000 ;#  Dunit Control Low Register
	mww 0xD0001408 0x22125451 ;#  DDR SDRAM Timing (Low) Register
	mww 0xD000140C 0x00000A33 ;#  DDR SDRAM Timing (High) Register
	mww 0xD0001410 0x000000CC ;#  DDR SDRAM Address Control Register
	mww 0xD0001414 0x00000000 ;#  DDR SDRAM Open Pages Control Register
	mww 0xD0001418 0x00000000 ;#  DDR SDRAM Operation Register
	mww 0xD000141C 0x00000C52 ;#  DDR SDRAM Mode Register
	mww 0xD0001420 0x00000004 ;#  DDR SDRAM Extended Mode Register
	mww 0xD0001424 0x0000F17F ;#  Dunit Control High Register
	mww 0xD0001428 0x00085520 ;#  Dunit Control High Register
	mww 0xD000147c 0x00008552 ;#  Dunit Control High Register
	mww 0xD0001504 0x0FFFFFF1 ;#  CS0n Size Register
	mww 0xD0001508 0x10000000 ;#  CS1n Base Register
	mww 0xD000150C 0x0FFFFFF5 ;#  CS1n Size Register
	mww 0xD0001514 0x00000000 ;#  CS2n Size Register
	mww 0xD000151C 0x00000000 ;#  CS3n Size Register
	mww 0xD0001494 0x00120012 ;#  DDR2 SDRAM ODT Control (Low) Register
	mww 0xD0001498 0x00000000 ;#  DDR2 SDRAM ODT Control (High) REgister
	mww 0xD000149C 0x0000E40F ;#  DDR2 Dunit ODT Control Register
	mww 0xD0001480 0x00000001 ;#  DDR SDRAM Initialization Control Register
	mww 0xD0020204 0x00000000 ;#  Main IRQ Interrupt Mask Register
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "

	mww 0xD0010000 0x01111111 ;#  MPP  0 to 7
	mww 0xD0010004 0x11113322 ;#  MPP  8 to 15
	mww 0xD0010008 0x00001111 ;#  MPP 16 to 23

	mww 0xD0010418 0x003E07CF ;#  NAND Read Parameters REgister
	mww 0xD001041C 0x000F0F0F ;#  NAND Write Parameters Register
	mww 0xD0010470 0x01C7D943 ;#  NAND Flash Control Register

}

proc openrd_reflash_uboot { } {

	# reflash the u-Boot binary and reboot into it
	openrd_init
	nand probe 0
	nand erase 0 0x0 0xa0000
	nand write 0 uboot.bin 0 oob_softecc_kw
	resume

}

proc openrd_load_uboot { } {

	# load u-Boot into RAM and execute it
	openrd_init
	load_image uboot.elf
	verify_image uboot.elf
	resume 0x00600000

}
# If you want to use the VJTAG TAP or the XILINX BSCAN,
# you must set your FPGA TAP ID here

set FPGATAPID 0x020b30dd

# Choose your TAP core (VJTAG , MOHOR or XILINX_BSCAN)
if { [info exists TAP_TYPE] == 0} {
   set TAP_TYPE VJTAG
}

# Set your chip name
set CHIPNAME or1200

source [find target/or1k.cfg]

# Set the servers polling period to 1ms (needed to JSP Server)
poll_period 1

# Set the adapter speed
adapter speed 3000

# Enable the target description feature
gdb_target_description enable

# Add a new register in the cpu register list. This register will be
# included in the generated target descriptor file.
# format is addreg [name] [address] [feature] [reg_group]
addreg rtest 0x1234 org.gnu.gdb.or1k.group0 system

# Override default init_reset
proc init_reset {mode} {
	soft_reset_halt
	resume
}

# Target initialization
init
echo "Halting processor"
halt

foreach name [target names] {
	set y [$name cget -endian]
	set z [$name cget -type]
	puts [format "Chip is %s, Endian: %s, type: %s" \
	      $name $y $z]
}

set c_blue  "\033\[01;34m"
set c_reset "\033\[0m"

puts [format "%sTarget ready...%s" $c_blue $c_reset]
# http://omap.spectrumdigital.com/osk5912/

source [find target/omap5912.cfg]

# NOTE: this assumes you're using the ARM 20-pin ("Multi-ICE")
# JTAG connector, and accordingly have J1 connecting pins 1 & 2.
# The TI-14 pin needs "trst_only", and J1 connecting 2 & 3.
reset_config trst_and_srst separate

# NOTE:  boards with XOMAP parts wire nSRST to nPWRON_RESET.
# That resets everything -- including JTAG and EmbeddedICE.
# So they must use "reset_config srst_pulls_trst".

# NOTE:  an expansion board could add a trace connector ... if
# it does, change this appropriately.  And reset_config too,
# assuming JTAG_DIS reroutes JTAG to that connector.
etm config $_TARGETNAME 8 demultiplexed full dummy
etm_dummy config $_TARGETNAME

# standard boards populate two 16 MB chips, but manufacturing
# options or an expansion board could change this config.
flash bank osk.u1 cfi 0x00000000 0x01000000 2 2 $_TARGETNAME
flash bank osk.u2 cfi 0x01000000 0x01000000 2 2 $_TARGETNAME

proc osk5912_init {} {
	omap5912_reset

	# detect flash
	flash probe 0
	flash probe 1
}
$_TARGETNAME configure -event reset-init { osk5912_init }

arm7_9 dcc_downloads enable
#
# Sony Ericsson J100I Phone
#
# more information can be found on
# http://bb.osmocom.org/trac/wiki/SonyEricssonJ100i
#
source [find target/ti_calypso.cfg]

# external flash

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x400000 2 2 $_TARGETNAME
source [find target/lpc3250.cfg]

adapter srst delay 200
jtag_ntrst_delay 1
adapter speed 200
reset_config trst_and_srst separate

arm7_9 dcc_downloads enable

$_TARGETNAME configure -event gdb-attach { reset init }

$_TARGETNAME configure -event reset-start {
             arm7_9 fast_memory_access disable
             adapter speed 200
}

$_TARGETNAME configure -event reset-end {
             adapter speed 6000
             arm7_9 fast_memory_access enable
}

$_TARGETNAME configure -event reset-init { phytec_lpc3250_init }

# Bare-bones initialization of core clocks and SDRAM
proc phytec_lpc3250_init { } {
        # Set clock dividers
        #   ARMCLK = 266.5 MHz
        #   HCLK   = 133.25 MHz
        #   PERIPHCLK = 13.325 MHz
        mww 0x400040BC 0
        mww 0x40004050 0x140
        mww 0x40004040 0x4D
        mww 0x40004058 0x16250

        # Init PLLs
        mww 0x40004044 0x006
        sleep 1 busy
        mww 0x40004044 0x106
        sleep 1 busy
        mww 0x40004044 0x006
        sleep 1 busy
        mww 0x40004048 0x2

        # Init SDRAM with 133 MHz timings
        mww 0x40028134 0x00FFFFFF
        mww 0x4002802C 0x00000008

        mww 0x31080000 1
        mww 0x31080008 0
        mww 0x40004068 0x1C000
        mww 0x31080028 0x11

        mww 0x31080400 0
        mww 0x31080440 0
        mww 0x31080460 0
        mww 0x31080480 0

        # Delays
        mww 0x31080030 1
        mww 0x31080034 6
        mww 0x31080038 10
        mww 0x31080044 1
        mww 0x31080048 9
        mww 0x3108004C 12
        mww 0x31080050 10
        mww 0x31080054 1
        mww 0x31080058 1
        mww 0x3108005C 0

        mww 0x31080100 0x5680
        mww 0x31080104 0x302

        # Init sequence
        mww 0x31080020 0x193
        sleep 1 busy
        mww 0x31080024 1
        mww 0x31080020 0x113
        sleep 1 busy
        mww 0x31080020 0x013
        sleep 1 busy
        mww 0x31080024 65
        mww 0x31080020 0x093
        mdw 0x80020000
        mww 0x31080020 0x013

        # SYS_CTRL remapping
        mww 0x40004014 1
}
# The Olimex PIC-P32MX has a PIC32MX

set CPUTAPID 0x40916053
source [find target/pic32mx.cfg]
# http://pipistrello.saanlima.com/

source [find interface/ftdi/pipistrello.cfg]
source [find cpld/xilinx-xc6s.cfg]
source [find cpld/jtagspi.cfg]

# example command to write bitstream, soft-cpu bios and runtime:
# openocd -f board/pipistrello.cfg -c "init;\
# jtagspi_init 0 bscan_spi_xc6slx45.bit;\
# jtagspi_program bitstream-pistrello.bin 0;\
# jtagspi_program bios.bin 0x170000;\
# jtagspi_program runtime.fbi 0x180000;\
# xc6s_program xc6s.tap;\
# exit"

## Chip:
set CHIPNAME at91sam9260
set CPUTAPID 0x0792603f
set ENDIAN little
source [find target/at91sam9260.cfg]

$_TARGETNAME configure -event reset-init {at91sam_init}


proc at91sam_init { } {

	# at reset chip runs at 32 kHz => 1/8 * 32 kHz = 4 kHz
	jtag_rclk 4

	# Enable user reset and disable watchdog
	mww 0xfffffd08 0xa5000501         ;# RSTC_MR : enable user reset
	mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog

	# Oscillator setup
	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator (18.432 MHz)
	sleep 20                          ;# wait 20 ms
	mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
	sleep 10                          ;# wait 10 ms

	# now we are running at 18.432 MHz kHz => 1/8 * 18.432 MHz = 2.304 MHz
	jtag_rclk 2000

	mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198,656MHz
	sleep 20                          ;# wait 20 ms
	mww 0xfffffc2c 0x207c3f0c         ;# CKGR_PLLBR: Set PLLB Register for USB usage (USB_CLK = 48 MHz)
	sleep 10                          ;# wait 10 ms
	mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler
	sleep 10                          ;# wait 10 ms
	mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected
	sleep 10                          ;# wait 10 ms

	# now we are running at 198.656 MHz kHz => full speed jtag
	jtag_rclk 30000

	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads

	# Configure PIO Controller for SDRAM data-lines D16-D31
	# PC16-PC31 = Peripheral A: D16-D32
	mww 0xfffff844 0xffff0000	;# Interrupt Disable
	mww 0xfffff854 0xffff0000	;# Multi-Drive Disable
	mww 0xfffff860 0xffff0000	;# Pull-Up Disable
	mww 0xfffff870 0xffff0000	;# PIO_ASR : Select peripheral A function for D15..D31
	mww 0xfffff804 0xffff0000	;# PIO_PDR : Disable PIO function for D15..D31 (Peripheral function enable)
	mww 0xfffffc10 0x00000010	;# Enable PIO-C Clock in PMC (PID=4)

	# SD-Ram setup
	mww 0xffffef1c 0x2			;# EBI_CSA : Assign EBI Chip Select 1 to SDRAM
	mww 0xffffea08 0x85227259	;# SDRAMC_CR : Configure SDRAM (IS42S32160A: 4M Words x 32 Bits x 4 Banks (512-Mbit))
	mww 0xffffea00 0x1			;# SDRAMC_MR : issue a NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2			;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (1st)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (2nd)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (3th)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (4th)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (5th)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (6th)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (7th)
	mww 0x20000000 0
	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (8th)
	mww 0x20000000 0
	mww 0xffffea00 0x3			;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0			;# SDRAMC_MR : Normal Mode
	mww 0x20000000 0
	mww 0xFFFFEA04 0x30d		;# SDRAM Refresh Time Register
								 #  datasheet: 8k refresh cycles / 64 ms
								 #  MCLK / (8*1024 / 64e-3) = 100e6 / 128000 = 781 = 0x30d

}
# A PXA255 test board with SST 39LF400A flash
#
# At reset the memory map is as follows. Note that
# the memory map changes later on as the application
# starts...
#
# RAM at 0x4000000
# Flash at 0x00000000
#
source [find target/pxa255.cfg]

# Target name is set by above
$_TARGETNAME configure -work-area-phys 0x4000000 -work-area-size 0x4000 -work-area-backup 0

# flash bank <driver> <base> <size> <chip_width> <bus_width> <target> [options]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x80000 2 2 $_TARGETNAME jedec_probe

proc pxa255_sst_init {} {
	xscale cp15   15      0x00002001  ;#Enable CP0 and CP13 access
	#
	# setup GPIO
	#
	mww    0x40E00018  0x00008000  ;#CPSR0
	sleep   20
	mww    0x40E0001C  0x00000002  ;#GPSR1
	sleep   20
	mww    0x40E00020  0x00000008  ;#GPSR2
	sleep   20
	mww    0x40E0000C  0x00008000  ;#GPDR0
	sleep   20
	mww    0x40E00054  0x80000000  ;#GAFR0_L
	sleep   20
	mww    0x40E00058  0x00188010  ;#GAFR0_H
	sleep   20
	mww    0x40E0005C  0x60908018  ;#GAFR1_L
	sleep   20
	mww    0x40E0000C  0x0280E000  ;#GPDR0
	sleep   20
	mww    0x40E00010  0x821C88B2  ;#GPDR1
	sleep   20
	mww    0x40E00014  0x000F03DB  ;#GPDR2
	sleep   20
	mww    0x40E00000  0x000F03DB  ;#GPLR0
	sleep   20


	mww    0x40F00004  0x00000020  ;#PSSR
	sleep   20

	#
	# setup memory controller
	#
	mww    0x48000008  0x01111998  ;#MSC0
	sleep   20
	mww    0x48000010  0x00047ff0  ;#MSC2
	sleep   20
	mww    0x48000014  0x00000000  ;#MECR
	sleep   20
	mww    0x48000028  0x00010504  ;#MCMEM0
	sleep   20
	mww    0x4800002C  0x00010504  ;#MCMEM1
	sleep   20
	mww    0x48000030  0x00010504  ;#MCATT0
	sleep   20
	mww    0x48000034  0x00010504  ;#MCATT1
	sleep   20
	mww    0x48000038  0x00004715  ;#MCIO0
	sleep   20
	mww    0x4800003C  0x00004715  ;#MCIO1
	sleep   20
	#
	mww    0x48000004  0x03CA4018  ;#MDREF
	sleep   20
	mww    0x48000004  0x004B4018  ;#MDREF
	sleep   20
	mww    0x48000004  0x000B4018  ;#MDREF
	sleep   20
	mww    0x48000004  0x000BC018  ;#MDREF
	sleep   20
	mww    0x48000000  0x00001AC8  ;#MDCNFG
	sleep   20

	sleep   20

	mww    0x48000000  0x00001AC9  ;#MDCNFG
	sleep   20
	mww    0x48000040  0x00000000  ;#MDMRS
	sleep   20
}

$_TARGETNAME configure -event reset-init {pxa255_sst_init}

reset_config trst_and_srst

adapter srst delay 200
jtag_ntrst_delay 200

#xscale debug_handler 0  0xFFFF0800      ;# debug handler base address
# Intel Quark microcontroller D2000 Reference Board (web search for doc num 333582)

# the board has an onboard FTDI FT232H chip
adapter driver ftdi
ftdi_vid_pid 0x0403 0x6014
ftdi_channel 0

ftdi_layout_init 0x0000 0x030b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0100

source [find target/quark_d20xx.cfg]

adapter speed 1000

reset_config trst_only
# There are many Quark boards that can host the quark_x10xx SoC
# Galileo is an example board

source [find target/quark_x10xx.cfg]

#default frequency but this can be adjusted at runtime
adapter speed 4000

reset_config trst_only
# SPDX-License-Identifier: GPL-2.0-or-later
# QuickLogic EOS S3 QuickFeather
# https://www.quicklogic.com/products/eos-s3/quickfeather-development-kit/

source [find target/eos_s3.cfg]

reset_config srst_only

transport select swd
source [find target/mc13224v.cfg]
# Achilles Instant-Development Kit Arria 10 SoC SoM
# https://www.reflexces.com/products-solutions/achilles-instant-development-kit-arria-10-soc-som
#

if { [info exists USE_EXTERNAL_DEBUGGER] } {
	echo "Using external debugger"
} else {
	source [find interface/altera-usb-blaster2.cfg]
	usb_blaster_device_desc "Arria10 IDK"
}

source [find fpga/altera-10m50.cfg]
source [find target/altera_fpgasoc_arria10.cfg]
#
# Renesas Synergy DK-S7G2
#

source [find interface/jlink.cfg]
transport select swd

# XXX 19-pin SWD+TRACE connector also available

# Synergy R7FS7G27H2A01CBD
source [find target/renesas_s7g2.cfg]

# 32 MB QSPI flash (Micron N25Q256A13EF840E)
# Renesas RZ/A1H GR-Peach board

reset_config srst_only

source [find target/renesas_r7s72100.cfg]
# Renesas R-Car M2 Evaluation Board

set SOC M2
source [find target/renesas_rcar_gen2.cfg]
# Renesas R-Car Gen3 Salvator-X(S) Board Config

# The Salvator-X(S) boards come with either an H3, M3W, or M3N SOC.

echo "\nSalvator-X(S):"
if { ![info exists SOC] } {
	set SOC H3
}
source [find target/renesas_rcar_gen3.cfg]
# Renesas R-Car E2 Evaluation Board

set SOC E2
source [find target/renesas_rcar_gen2.cfg]
# Renesas R-Car H2 Evaluation Board

set SOC H2
source [find target/renesas_rcar_gen2.cfg]
#
# Rigado BMD-300 Evaluation Kit
#
# https://www.rigado.com/products/modules/bmd-300/
#

source [find interface/jlink.cfg]
transport select swd
adapter speed 1000

source [find target/nrf52.cfg]
# Avalue RSC-W8910 sbc
# http://www.avalue.com.tw/products/RSC-W910.cfm
# 2MB NOR Flash
# 64MB SDRAM
# 128MB NAND Flash

# Based on Nuvoton nuc910
source [find target/nuc910.cfg]

#
# reset only behaves correctly if we use srst_pulls_trst
#
reset_config trst_and_srst srst_pulls_trst

adapter speed 1000
adapter srst delay 100
jtag_ntrst_delay 100

$_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x04000000 -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x20000000 0x00200000 2 2 $_TARGETNAME

set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME nuc910 $_TARGETNAME

#
# Target events
#

$_TARGETNAME configure -event reset-start {adapter speed 1000}

$_TARGETNAME configure -event reset-init {
	# switch on PLL for 200MHz operation
	# running from 15MHz input clock

	mww 0xB0000200 0x00000030 ;# CLKEN
	mww 0xB0000204 0x00000f3c ;# CLKSEL
	mww 0xB0000208 0x05007000 ;# CLKDIV
	mww 0xB000020C 0x00004f24 ;# PLLCON0
	mww 0xB0000210 0x00002b63 ;# PLLCON1
	mww 0xB000000C 0x08817fa6 ;# MFSEL
	sleep 10

	# we are now running @ 200MHz
	# enable all openocd speed tweaks

	arm7_9 dcc_downloads enable
	arm7_9 fast_memory_access enable
	adapter speed 15000

	# map nor flash to 0x20000000
	# map sdram to 0x00000000

	mww 0xb0001000 0x000530c1 ;# EBICON
	mww 0xb0001004 0x40030084 ;# ROMCON
	mww 0xb0001008 0x000010ee ;# SDCONF0
	mww 0xb000100C 0x00000000 ;# SDCONF1
	mww 0xb0001010 0x0000015b ;# SDTIME0
	mww 0xb0001014 0x0000015b ;# SDTIME1
	mww 0xb0001018 0x00000000 ;# EXT0CON
	mww 0xb000101C 0x00000000 ;# EXT1CON
	mww 0xb0001020 0x00000000 ;# EXT2CON
	mww 0xb0001024 0x00000000 ;# EXT3CON
	mww 0xb000102c 0x00ff0048 ;# CKSKEW
}
# Sayma AMC is an FPGA board for the TCA AMC format
# The board is open hardware (CERN OHL) and the gateware and software
# running on it are open source (ARTIQ, LGPLv3+).
#
# https://github.com/m-labs/sinara/wiki/Sayma
#
# It contains a Xilinx Kintex Ultrascale 040 FPGA (xcku040).
# There is a SCANSTA112SM JTAG router on the board which is configured to
# automatically add devices to the JTAG svcan chain when they are added.
# Sayma AMC is usually combined with Sayma RTM (rear transition module)
# which features an Artix 7 FPGA.

adapter driver ftdi
ftdi_device_desc "Quad RS232-HS"
ftdi_vid_pid 0x0403 0x6011
ftdi_channel 0
# Use this to distinguish multiple boards by topology
#ftdi_location 5:1
# sampling on falling edge generally seems to work and accelerates things but
# is not fully tested
#ftdi_tdo_sample_edge falling
# EN_USB_JTAG on ADBUS7: out, high
# USB_nTRST on ADBUS4: out, high, but R46 is DNP
ftdi_layout_init 0x0098 0x008b
#ftdi_layout_signal EN_USB -data 0x0080
#ftdi_layout_signal nTRST -data 0x0010
reset_config none

adapter speed 5000

transport select jtag

# Add the RTM Artix to the chain. Note that this changes the PLD numbering.
# Unfortunately openocd TAPs can't be disabled after they have been added and
# before `init`.
#source [find cpld/xilinx-xc7.cfg]

set CHIP XCKU040
source [find cpld/xilinx-xcu.cfg]

set XILINX_USER1 0x02
set XILINX_USER2 0x03
set JTAGSPI_IR $XILINX_USER1
source [find cpld/jtagspi.cfg]
flash bank xcu.spi1 jtagspi 0 0 0 0 xcu.proxy $XILINX_USER2
# Marvell SheevaPlug

source [find interface/ftdi/sheevaplug.cfg]
source [find target/feroceon.cfg]

adapter speed 2000

$_TARGETNAME configure \
	-work-area-phys 0x10000000 \
	-work-area-size 65536 \
	-work-area-backup 0

arm7_9 dcc_downloads enable

# this assumes the hardware default peripherals location before u-Boot moves it
set _FLASHNAME $_CHIPNAME.flash
nand device $_FLASHNAME orion 0 0xd8000000

proc sheevaplug_init { } {

	# We need to assert DBGRQ while holding nSRST down.
	# However DBGACK will be set only when nSRST is released.
	# Furthermore, the JTAG interface doesn't respond at all when
	# the CPU is in the WFI (wait for interrupts) state, so it is
	# possible that initial tap examination failed.  So let's
	# re-examine the target again here when nSRST is asserted which
	# should then succeed.
	adapter assert srst
	feroceon.cpu arp_examine
	halt 0
	adapter deassert srst
	wait_halt

	arm mcr 15 0 0 1 0 0x00052078

	mww 0xD0001400 0x43000C30 ;#  DDR SDRAM Configuration Register
	mww 0xD0001404 0x39543000 ;#  Dunit Control Low Register
	mww 0xD0001408 0x22125451 ;#  DDR SDRAM Timing (Low) Register
	mww 0xD000140C 0x00000833 ;#  DDR SDRAM Timing (High) Register
	mww 0xD0001410 0x000000CC ;#  DDR SDRAM Address Control Register
	mww 0xD0001414 0x00000000 ;#  DDR SDRAM Open Pages Control Register
	mww 0xD0001418 0x00000000 ;#  DDR SDRAM Operation Register
	mww 0xD000141C 0x00000C52 ;#  DDR SDRAM Mode Register
	mww 0xD0001420 0x00000042 ;#  DDR SDRAM Extended Mode Register
	mww 0xD0001424 0x0000F17F ;#  Dunit Control High Register
	mww 0xD0001428 0x00085520 ;#  Dunit Control High Register
	mww 0xD000147c 0x00008552 ;#  Dunit Control High Register
	mww 0xD0001504 0x0FFFFFF1 ;#  CS0n Size Register
	mww 0xD0001508 0x10000000 ;#  CS1n Base Register
	mww 0xD000150C 0x0FFFFFF5 ;#  CS1n Size Register
	mww 0xD0001514 0x00000000 ;#  CS2n Size Register
	mww 0xD000151C 0x00000000 ;#  CS3n Size Register
	mww 0xD0001494 0x003C0000 ;#  DDR2 SDRAM ODT Control (Low) Register
	mww 0xD0001498 0x00000000 ;#  DDR2 SDRAM ODT Control (High) REgister
	mww 0xD000149C 0x0000F80F ;#  DDR2 Dunit ODT Control Register
	mww 0xD0001480 0x00000001 ;#  DDR SDRAM Initialization Control Register
	mww 0xD0020204 0x00000000 ;#  Main IRQ Interrupt Mask Register
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "
	mww 0xD0020204 0x00000000 ;#              "

	mww 0xD0010000 0x01111111 ;#  MPP  0 to 7
	mww 0xD0010004 0x11113322 ;#  MPP  8 to 15
	mww 0xD0010008 0x00001111 ;#  MPP 16 to 23

	mww 0xD0010418 0x003E07CF ;#  NAND Read Parameters REgister
	mww 0xD001041C 0x000F0F0F ;#  NAND Write Parameters Register
	mww 0xD0010470 0x01C7D943 ;#  NAND Flash Control Register

}

proc sheevaplug_reflash_uboot { } {

	# reflash the u-Boot binary and reboot into it
	sheevaplug_init
	nand probe 0
	nand erase 0 0x0 0xa0000
	nand write 0 uboot.bin 0 oob_softecc_kw
	resume

}

proc sheevaplug_reflash_uboot_env { } {

	# reflash the u-Boot environment variables area
	sheevaplug_init
	nand probe 0
	nand erase 0 0xa0000 0x40000
	nand write 0 uboot-env.bin 0xa0000 oob_softecc_kw
	resume

}

proc sheevaplug_load_uboot { } {

	# load u-Boot into RAM and execute it
	sheevaplug_init
	load_image uboot.elf
	verify_image uboot.elf
	resume 0x00600000

}
#
# Be sure you include the speed and interface before this file
# Example:
# -c "adapter speed 5000" -f "interface/ftdi/olimex-arm-usb-tiny-h.cfg" -f "board/sifive-e31arty.cfg"

set _CHIPNAME riscv
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x20000001

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME.0 riscv -chain-position $_TARGETNAME
$_TARGETNAME.0 configure -work-area-phys 0x80000000 -work-area-size 10000 -work-area-backup 1

flash bank spi0 fespi 0x40000000 0 0 0 $_TARGETNAME.0 0x20004000
init
if {[ info exists pulse_srst]} {
  ftdi_set_signal nSRST 0
  ftdi_set_signal nSRST z
}
halt
flash protect 0 64 last off
echo "Ready for Remote Connections"
#
# Be sure you include the speed and interface before this file
# Example:
# -c "adapter speed 5000" -f "interface/ftdi/olimex-arm-usb-tiny-h.cfg" -f "board/sifive-e51arty.cfg"

set _CHIPNAME riscv
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x20000001

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME.0 riscv -chain-position $_TARGETNAME
$_TARGETNAME.0 configure -work-area-phys 0x80000000 -work-area-size 10000 -work-area-backup 1

flash bank spi0 fespi 0x40000000 0 0 0 $_TARGETNAME.0 0x20004000
init
if {[ info exists pulse_srst]} {
  ftdi_set_signal nSRST 0
  ftdi_set_signal nSRST z
}
halt
flash protect 0 64 last off
echo "Ready for Remote Connections"
adapter speed 4000

adapter driver jlink
transport select jtag

set _CHIPNAME riscv
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x20000913

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME.0 riscv -chain-position $_TARGETNAME
$_TARGETNAME.0 configure -work-area-phys 0x80000000 -work-area-size 0x4000 -work-area-backup 0

flash bank onboard_spi_flash fespi 0x20000000 0 0 0 $_TARGETNAME.0

init

jlink jtag 3

halt
flash protect 0 1 last off
echo "Ready for Remote Connections"
adapter speed     10000

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0008 0x001b
ftdi_layout_signal nSRST -oe 0x0020 -data 0x0020

#Reset Stretcher logic on FE310 is ~1 second long
#This doesn't apply if you use
# ftdi_set_signal, but still good to document
#adapter srst delay 1500

set _CHIPNAME riscv
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x10e31913

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME riscv -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 10000 -work-area-backup 1

flash bank onboard_spi_flash fespi 0x20000000 0 0 0 $_TARGETNAME
init
#reset -- This type of reset is not implemented yet
if {[ info exists pulse_srst]} {
  ftdi_set_signal nSRST 0
  ftdi_set_signal nSRST z
  #Wait for the reset stretcher
  #It will work without this, but
  #will incur lots of delays for later commands.
  sleep 1500
}
halt
flash protect 0 64 last off
# Target configuration for the Samsung s3c6410 system on chip
# Tested on a SMDK6410
# Processor       : ARM1176
# Info:   JTAG device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)

source [find target/samsung_s3c6410.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x00000000 0x00100000 2 2 $_TARGETNAME jedec_probe
#  Copyright (C) 2014-2016,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys DesignWare ARC EM Starter Kit v2.x
#

# Configure JTAG cable
# EM Starter Kit has built-in FT2232 chip, which is similar to Digilent HS-1.
source [find interface/ftdi/digilent-hs1.cfg]

# 5MHz seems to work good with all cores that might happen in 2.x
adapter speed 5000

# ARCs support only JTAG.
transport select jtag

# Configure FPGA. This script supports both LX45 and LX150.
source [find target/snps_em_sk_fpga.cfg]
#  Copyright (C) 2014-2016,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys DesignWare ARC EM Starter Kit v1.0 and v1.1
#

# Configure JTAG cable
# EM Starter Kit has built-in FT2232 chip, which is similar to Digilent HS-1.
source [find interface/ftdi/digilent-hs1.cfg]
adapter speed 10000

# ARCs support only JTAG.
transport select jtag

# Configure FPGA. This script supports both LX45 and LX150.
source [find target/snps_em_sk_fpga.cfg]
#  Copyright (C) 2014-2016,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys DesignWare ARC EM Starter Kit v2.1
#

# Configure JTAG cable
# EM Starter Kit has built-in FT2232 chip, which is similar to Digilent HS-1.
source [find interface/ftdi/digilent-hs1.cfg]

# JTAG 10MHz is too fast for EM7D FPU in EM SK 2.1 which has core frequency
# 20MHz. 7.5 MHz seems to work fine.
adapter speed 7500

# ARCs support only JTAG.
transport select jtag

# Configure FPGA. This script supports both LX45 and LX150.
source [find target/snps_em_sk_fpga.cfg]
#  Copyright (C) 2016,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys DesignWare ARC EM Starter Kit v2.2
#

# Configure JTAG cable
# EM Starter Kit has built-in FT2232 chip, which is similar to Digilent HS-1.
source [find interface/ftdi/digilent-hs1.cfg]

# EM11D reportedly requires 5 MHz. Other cores and board can work faster.
adapter speed 5000

# ARCs support only JTAG.
transport select jtag

# Configure FPGA. This script supports both LX45 and LX150.
source [find target/snps_em_sk_fpga.cfg]
#  Copyright (C) 2019, 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys DesignWare ARC HSDK Software Development Platform (HS38 cores)
#

source [find interface/ftdi/snps_sdp.cfg]
adapter_khz 10000

# ARCs supports only JTAG.
transport select jtag

# Configure SoC
source [find target/snps_hsdk.cfg]
#
# Spansion SK-FM4-176L-S6E2CC
#

#
# FM3 MB9AF312K
#
source [find interface/cmsis-dap.cfg]

# There's also an unpopulated 10-pin 0.05" pinout.

#
# FM4 S6E2CCAJ0A w/ 192 KB SRAM0
#
set CHIPNAME s6e2cc
set CHIPSERIES S6E2CCAJ0A
set WORKAREASIZE 0x30000
source [find target/fm4_s6e2cc.cfg]

reset_config srst_only
#
# Spansion SK-FM4-U120-9B560
#

#
# FM3 MB9AF312K
#
# source [find interface/cmsis-dap.cfg]

#
# FM4 MB9BF568R w/ 64 KB SRAM0
#
set CHIPNAME mb9bf568
set CHIPSERIES MB9BF568R
set WORKAREASIZE 0x10000
source [find target/fm4_mb9bf.cfg]

reset_config srst_only
# Configuration for the ST SPEAr300 Evaluation board
# EVALSPEAr300 Rev. 1.0
# http://www.st.com/spear
#
# Date:      2010-11-27
# Author:    Antonio Borneo <borneo.antonio@gmail.com>

# The standard board has JTAG SRST not connected.
# This script targets such boards using quirky code to bypass the issue.


source [find mem_helper.tcl]
source [find target/spear3xx.cfg]
source [find chip/st/spear/spear3xx_ddr.tcl]
source [find chip/st/spear/spear3xx.tcl]

arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable


# Serial NOR on SMI CS0. 8Mbyte.
set _FLASHNAME1 $_CHIPNAME.snor
flash bank $_FLASHNAME1 stmsmi 0xf8000000 0 0 0 $_TARGETNAME

if { [info exists BOARD_HAS_SRST] } {
	# Modified board has SRST on JTAG connector
	reset_config trst_and_srst separate srst_gates_jtag \
		trst_push_pull srst_open_drain
} else {
	# Standard board has no SRST on JTAG connector
	reset_config trst_only separate srst_gates_jtag trst_push_pull
	source [find chip/st/spear/quirk_no_srst.tcl]
}

$_TARGETNAME configure -event reset-init { spear300evb_init }

proc spear300evb_init {} {
	reg pc 0xffff0020;	# loop forever

	sp3xx_clock_default
	sp3xx_common_init
	sp3xx_ddr_init "mt47h64m16_3_333_cl5_async"
	sp300_init
}
# Configuration for the ST SPEAr300 Evaluation board
# EVALSPEAr300 Rev. 1.0, modified to enable SRST on JTAG connector
# http://www.st.com/spear
#
# List of board modifications to enable SRST, as reported in
# ST Application Note (FIXME: add reference).
# - Modifications on the top layer:
#    1. replace reset chip U4 with a STM6315SDW13F;
# - Modifications on the bottom layer:
#    2. add 0 ohm resistor R10. It is located close to JTAG connector.
#    3. add a 10K ohm pull-up resistor on the reset wire named as
#       POWERGOOD in the schematic.
#
# The easier way to do modification 3, is to use a resistor in package
# 0603 and solder it between R10 and R54:
# - one pad soldered with the pad of R54 connected to 3.3V (this
#   is the pad of R54 far from JTAG connector J4)
# - the other pad soldered with the nearest pad of R10.
#
# Date:      2011-11-18
# Author:    Antonio Borneo <borneo.antonio@gmail.com>


# Modified boards has SRST on JTAG connector
set BOARD_HAS_SRST 1
source [find board/spear300evb.cfg]
# Configuration for the ST SPEAr310 Evaluation board
# EVALSPEAr310 Rev. 2.0
# http://www.st.com/spear
#
# Date:      2010-08-17
# Author:    Antonio Borneo <borneo.antonio@gmail.com>

# The standard board has JTAG SRST not connected.
# This script targets such boards using quirky code to bypass the issue.
#
# Check ST Application Note AN3321 on how to fix SRST on
# the board, then use the script board/spear310evb20_mod.cfg


source [find mem_helper.tcl]
source [find target/spear3xx.cfg]
source [find chip/st/spear/spear3xx_ddr.tcl]
source [find chip/st/spear/spear3xx.tcl]

arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable

# CFI parallel NOR on EMI CS0. 2x 16bit 8M devices = 16Mbyte.
set _FLASHNAME0 $_CHIPNAME.pnor
flash bank $_FLASHNAME0 cfi 0x50000000 0x01000000 2 4 $_TARGETNAME

# Serial NOR on SMI CS0. 8Mbyte.
set _FLASHNAME1 $_CHIPNAME.snor
flash bank $_FLASHNAME1 stmsmi 0xf8000000 0 0 0 $_TARGETNAME

if { [info exists BOARD_HAS_SRST] } {
	# Modified board has SRST on JTAG connector
	reset_config trst_and_srst separate srst_gates_jtag \
		trst_push_pull srst_open_drain
} else {
	# Standard board has no SRST on JTAG connector
	reset_config trst_only separate srst_gates_jtag trst_push_pull
	source [find chip/st/spear/quirk_no_srst.tcl]
}

$_TARGETNAME configure -event reset-init { spear310evb20_init }

proc spear310evb20_init {} {
	reg pc 0xffff0020	;# loop forever

	sp3xx_clock_default
	sp3xx_common_init
	sp3xx_ddr_init "mt47h64m16_3_333_cl5_async"
	sp310_init
	sp310_emi_init
}
# Configuration for the ST SPEAr310 Evaluation board
# EVALSPEAr310 Rev. 2.0, modified to enable SRST on JTAG connector
# http://www.st.com/spear
#
# List of board modifications to enable SRST, as reported in
# ST Application Note AN3321.
# - Modifications on the top layer:
#    1. remove R137 and C57, located near the SMII PHY U18;
#    2. remove R172 and C75, located near the SMII PHY U19;
#    3. remove R207 and C90, located near the SMII PHY U20;
#    4. remove C236, located near the SMII PHY U21;
#    5. remove U12, located near the JTAG connector;
#    6. solder together pins 7, 8 and 9 of U12;
#    7. solder together pins 11, 12, 13, 14, 15, 16, 17 and 18 of U12.
# - Modifications on the bottom layer:
#    8. replace reset chip U11 with a STM6315SDW13F;
#    9. add 0 ohm resistor R329. It is located close to JTAG connector.
#
# Date:      2009-10-31
# Author:    Antonio Borneo <borneo.antonio@gmail.com>


# Modified boards has SRST on JTAG connector
set BOARD_HAS_SRST 1
source [find board/spear310evb20.cfg]
# Configuration for the ST SPEAr320 CPU board
# EVAL_SPEAr320CPU Rev. 2.0
# http://www.st.com/spear
#
# Date:      2011-11-18
# Author:    Antonio Borneo <borneo.antonio@gmail.com>

# The standard board has JTAG SRST not connected.
# This script targets such boards using quirky code to bypass the issue.


source [find mem_helper.tcl]
source [find target/spear3xx.cfg]
source [find chip/st/spear/spear3xx_ddr.tcl]
source [find chip/st/spear/spear3xx.tcl]

arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable


# Serial NOR on SMI CS0. 8Mbyte.
set _FLASHNAME1 $_CHIPNAME.snor
flash bank $_FLASHNAME1 stmsmi 0xf8000000 0 0 0 $_TARGETNAME

if { [info exists BOARD_HAS_SRST] } {
	# Modified board has SRST on JTAG connector
	reset_config trst_and_srst separate srst_gates_jtag \
		trst_push_pull srst_open_drain
} else {
	# Standard board has no SRST on JTAG connector
	reset_config trst_only separate srst_gates_jtag trst_push_pull
	source [find chip/st/spear/quirk_no_srst.tcl]
}

$_TARGETNAME configure -event reset-init { spear320cpu_init }

if { [info exists DDR_CHIPS] } {
        set _DDR_CHIPS $DDR_CHIPS
} else {
        set _DDR_CHIPS 1
}

proc spear320cpu_init {} {
	global _DDR_CHIPS
	reg pc 0xffff0020;	# loop forever

	sp3xx_clock_default
	sp3xx_common_init
	sp3xx_ddr_init "mt47h64m16_3_333_cl5_async" $_DDR_CHIPS
	sp320_init
}
# Configuration for the ST SPEAr320 Evaluation board
# EVAL_SPEAr320CPU Rev. 2.0, modified to enable SRST on JTAG connector
# http://www.st.com/spear
#
# List of board modifications to enable SRST, as reported in
# ST Application Note (FIXME: add reference).
# - Modifications on the bottom layer:
#    1. replace reset chip U7 with a STM6315SDW13F;
#    2. add 0 ohm resistor R45. It is located close to JTAG connector.
#    3. add a 10K ohm pull-up resistor on the reset wire named as
#       POWERGOOD in the schematic.
#
# The easier way to do modification 3, is to use a resistor in package
# 0603 or 0402 and solder it between R15 and R45:
# - one pad soldered with the pad of R15 connected to 3.3V (this
#   is the pad of R15 closer to R45)
# - the other pad soldered with the nearest pad of R45.
#
# Date:      2011-11-18
# Author:    Antonio Borneo <borneo.antonio@gmail.com>


# Modified boards has SRST on JTAG connector
set BOARD_HAS_SRST 1
source [find board/spear320cpu.cfg]
# SPDX-License-Identifier: GPL-2.0-or-later

# This is an B-L475E-IOT01A Discovery kit for IoT node with a single STM32L475VGT6 chip.
# http://www.st.com/en/evaluation-tools/b-l475e-iot01a.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 96KB
set WORKAREASIZE 0x18000

# enable stmqspi
set QUADSPI 1

source [find target/stm32l4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x4002104C 0x000001FF 0				;# RCC_AHB2ENR |= GPIOAEN-GPIOIEN (enable clocks)
	mmw 0x40021050 0x00000100 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PE11: NCS, PE10: CLK, PE15: BK1_IO3, PE14: BK1_IO2, PE13: BK1_IO1, PE12: BK1_IO0

	# PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V

	# Port E: PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V
	mmw 0x48001000 0xAAA00000 0x55500000	;# MODER
	mmw 0x48001008 0xFFF00000 0x00000000	;# OSPEEDR
	mmw 0x48001024 0xAAAAAA00 0x55555500	;# AFRH

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x01500008				;# QUADSPI_CR: PRESCALER=1, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00160100				;# QUADSPI_DCR: FSIZE=0x16, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mmw 0x40022000 0x00000004 0x00000003	;# 4 WS for 72 MHz HCLK
	sleep 1
	mmw 0x40021000 0x00000100 0x00000000	;# HSI on
	mww 0x4002100C 0x01002432				;# 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI
	mww 0x40021008 0x00008001				;# always HSI, APB1: /1, APB2: /1
	mmw 0x40021000 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40021008 0x00000003 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is a ST NUCLEO 8L152R8 board with a single STM8L152R8T6 chip.
# http://www.st.com/en/evaluation-tools/nucleo-8l152r8.html

source [find interface/stlink-dap.cfg]

transport select swim

source [find target/stm8l152.cfg]

reset_config srst_only
# This is for all ST NUCLEO with any STM32F0. Known boards at the moment:
# STM32F030R8
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259997
# NUCLEO-F072RB
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259997
# STM32F091RC
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF260944

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f0x.cfg]

reset_config srst_only
# This is an ST NUCLEO F103RB board with a single STM32F103RBT6 chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259875

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f1x.cfg]

reset_config srst_only
# This is an ST NUCLEO F334R8 board with a single STM32F334R8T6 chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF260004

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f3x.cfg]

reset_config srst_only
# This is for all ST NUCLEO with any STM32F4. Known boards at the moment:
# STM32F401RET6
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF260000
# STM32F411RET6
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF260320

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f4x.cfg]

reset_config srst_only
# STMicroelectronics STM32F7 Nucleo development board
# Known boards: NUCLEO-F746ZG and NUCLEO-F767ZI

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f7x.cfg]

reset_config srst_only
# This is an ST NUCLEO-H743ZI board with single STM32H743ZI chip.
# http://www.st.com/en/evaluation-tools/nucleo-h743zi.html

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32h7x_dual_bank.cfg]

reset_config srst_only
# This is an ST NUCLEO-H745ZI-Q board with single STM32H745ZITx chip.

source [find interface/stlink-dap.cfg]
transport select dapdirect_swd

# STM32H745xx devices are dual core (Cortex-M7 and Cortex-M4)
set DUAL_CORE 1

# enable CTI for cross halting both cores
set USE_CTI 1

source [find target/stm32h7x_dual_bank.cfg]

reset_config srst_only
# This is an ST NUCLEO-L073RZ board with single STM32L073RZ chip.
# http://www.st.com/en/evaluation-tools/nucleo-l073rz.html
source [find interface/stlink.cfg]

transport select hla_swd

set WORKAREASIZE 0x2000

source [find target/stm32l0_dual_bank.cfg]

# There is only system reset line and JTAG/SWD command can be issued when SRST
reset_config srst_only
# This is an ST NUCLEO L152RE board with a single STM32L152RET6 chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF260002

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32l1x_dual_bank.cfg]

reset_config srst_only
# Should work with all STM32L4 Nucleo Dev Boards.
# http://www.st.com/en/evaluation-tools/stm32-mcu-nucleo.html

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32l4x.cfg]

# use hardware reset
reset_config srst_only srst_nogate
# SPDX-License-Identifier: GPL-2.0-or-later

# This is for STM32L5 Nucleo Dev Boards.
# http://www.st.com/en/evaluation-tools/stm32-mcu-nucleo.html

source [find interface/stlink-dap.cfg]

transport select dapdirect_swd

source [find target/stm32l5x.cfg]

# use hardware reset
reset_config srst_only srst_nogate
#
# Configuration for STM32WB55 Nucleo board (STM32WB55RGV6)
#

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32wbx.cfg]

reset_config srst_only
# This is an evaluation board with a single BlueNRG-1 chip.
# http://www.st.com/content/st_com/en/products/evaluation-tools/solution-evaluation-tools/communication-and-connectivity-solution-eval-boards/steval-idb008v1.html
set CHIPNAME bluenrg-1
source [find target/bluenrg-x.cfg]
# This is an evaluation board with a single BlueNRG-2 chip.
# http://www.st.com/content/st_com/en/products/evaluation-tools/solution-evaluation-tools/communication-and-connectivity-solution-eval-boards/steval-idb007v1.html
set CHIPNAME bluenrg-2
source [find target/bluenrg-x.cfg]
# This is an evaluation board with a single BlueNRG-LP chip.
set CHIPNAME bluenrg-lp
source [find target/bluenrg-x.cfg]
# Use for the STM207VG plug-in board (1 MiB Flash and 112+16 KiB Ram
# coming with the STEVAL-PCC010 board
# http://www.st.com/internet/evalboard/product/251530.jsp
# or any other board with only a STM32F2x in the JTAG chain

# increase working area to 32KB for faster flash programming
set WORKAREASIZE 0x8000

source [find target/stm32f2x.cfg]
# STM320518-EVAL: This is an STM32F0 eval board with a single STM32F051R8T6
# (64KB) chip.
# http://www.st.com/internet/evalboard/product/252994.jsp
#

# increase working area to 8KB
set WORKAREASIZE 0x2000

# chip name
set CHIPNAME STM32F051R8T6

source [find target/stm32f0x.cfg]
# STM320518-EVAL: This is an STM32F0 eval board with a single STM32F051R8T6
# (64KB) chip.
# http://www.st.com/internet/evalboard/product/252994.jsp
#
# This is for using the onboard STLINK/V2

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 8KB
set WORKAREASIZE 0x2000

# chip name
set CHIPNAME STM32F051R8T6

source [find target/stm32f0x.cfg]

reset_config srst_only
# This is an STM32 eval board with a single STM32F100VBT6 chip.
# http://www.st.com/internet/evalboard/product/247099.jsp

# The chip has only 8KB sram
set WORKAREASIZE 0x2000

source [find target/stm32f1x.cfg]
# This is an STM32 eval board with a single STM32F10x (128KB) chip.
# http://www.st.com/internet/evalboard/product/176090.jsp

# increase working area to 32KB for faster flash programming
set WORKAREASIZE 0x8000

source [find target/stm32f1x.cfg]
# This is an STM32 eval board with a single STM32F107VCT chip.
# http://www.st.com/internet/evalboard/product/217965.jsp

# increase working area to 32KB for faster flash programming
set WORKAREASIZE 0x8000

source [find target/stm32f1x.cfg]
# This is an STM32 eval board with a single STM32F103ZET6 chip.
# http://www.st.com/internet/evalboard/product/204176.jsp

# increase working area to 32KB for faster flash programming
set WORKAREASIZE 0x8000

source [find target/stm32f1x.cfg]

#
# configure FSMC Bank 1 (NOR/PSRAM Bank 2) NOR flash
# M29W128GL70ZA6E
#

set _FLASHNAME $_CHIPNAME.norflash
flash bank $_FLASHNAME cfi 0x64000000 0x01000000 2 2 $_TARGETNAME

proc stm32_enable_fsmc {} {

	echo "Enabling FSMC Bank 1 (NOR/PSRAM Bank 2)"

	# enable gpio (defg) clocks for fsmc
	# RCC_APB2ENR
	mww 0x40021018 0x000001E0

	# enable fsmc clock
	# RCC_AHBENR
	mww 0x40021014 0x00000114

	# configure gpio to alternate function
	# GPIOD_CRL
	mww 0x40011400 0x44BB44BB
	# GPIOD_CRH
	mww 0x40011404 0xBBBBBBBB

	# GPIOE_CRL
	mww 0x40011800 0xBBBBB444
	# GPIOE_CRH
	mww 0x40011804 0xBBBBBBBB

	# GPIOF_CRL
	mww 0x40011C00 0x44BBBBBB
	# GPIOF_CRH
	mww 0x40011C04 0xBBBB4444

	# GPIOG_CRL
	mww 0x40012000 0x44BBBBBB
	# GPIOG_CRH
	mww 0x40012004 0x444444B4

	# setup fsmc timings
	# FSMC_BCR1
	mww 0xA0000008 0x00001058

	# FSMC_BTR1
	mww 0xA000000C 0x10000502

	# FSMC_BCR1 - enable fsmc
	mww 0xA0000008 0x00001059
}

$_TARGETNAME configure -event reset-init {
	stm32_enable_fsmc
}
# STM3220G-EVAL: This is an STM32F2 eval board with a single STM32F207IGH6
# (128KB) chip.
# http://www.st.com/internet/evalboard/product/250374.jsp

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F207IGH6

source [find target/stm32f2x.cfg]
# STM3220G-EVAL: This is an STM32F2 eval board with a single STM32F207IGH6
# (128KB) chip.
# http://www.st.com/internet/evalboard/product/250374.jsp
#
# This is for using the onboard STLINK/V2

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F207IGH6

source [find target/stm32f2x.cfg]

reset_config srst_only
# STM3241G-EVAL: This is an STM32F4 eval board with a single STM32F417IGH6
# (1024KB) chip.
# http://www.st.com/internet/evalboard/product/252216.jsp

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F417IGH6

source [find target/stm32f4x.cfg]
# STM3241G-EVAL: This is an STM32F4 eval board with a single STM32F417IGH6
# (1024KB) chip.
# http://www.st.com/internet/evalboard/product/252216.jsp
#
# This is for using the onboard STLINK/V2

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F417IGH6

source [find target/stm32f4x.cfg]

reset_config srst_only
# STM32429I-EVAL: This is an STM32F4 eval board with a single STM32F429NIH6
# (2048KB) chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF259093

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F429NIH6

source [find target/stm32f4x.cfg]
# STM32429I-EVAL: This is an STM32F4 eval board with a single STM32F429NIH6
# (2048KB) chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF259093
#
# This is for using the onboard STLINK/V2

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F429NIH6

source [find target/stm32f4x.cfg]

reset_config srst_only
# STM32439I-EVAL: This is an STM32F4 eval board with a single STM32F439NIH6
# (2048KB) chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF259094

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F439NIH6

source [find target/stm32f4x.cfg]
# STM32439I-EVAL: This is an STM32F4 eval board with a single STM32F439NIH6
# (2048KB) chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF259094
#
# This is for using the onboard STLINK/V2

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# chip name
set CHIPNAME STM32F439NIH6

source [find target/stm32f4x.cfg]

reset_config srst_only
# STM327[4|5]6G-EVAL: This is for the STM32F7 eval boards.
# STM32746G-EVAL
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF261639
# STM32756G-EVAL
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF261640

# increase working area to 256KB
set WORKAREASIZE 0x40000

source [find target/stm32f7x.cfg]
# This is an STM32F0 discovery board with a single STM32F051R8T6 chip.
# http://www.st.com/internet/evalboard/product/253215.jsp

source [find interface/stlink.cfg]

transport select hla_swd

set WORKAREASIZE 0x2000
source [find target/stm32f0x.cfg]

reset_config srst_only
# STM32F103C8 "Blue Pill"

# NOTE:
# There is a fair bit of confusion about whether the "Blue Pill" has 128kB or 64kB flash size.
# The most likely cause is that there exist a -C8 and a -CB variant of the STM32F103, where
# the C8 has 64kB, the CB has 128kB as per specification. "Blue Pill" boards are manufactured
# by a lot of different vendors, some may actually use the CB variant but from a cursory look
# it very hard to tell them apart ("C8" and "CB" look very similar). Nevertheless, people have
# tried using the full 128kB of flash on the C8 and found it to be working. Hence this board file
# overrides the internal size detection. Be aware though that you may be using you particular
# board outside of its specification. If in doubt, comment the following line.
set FLASH_SIZE 0x20000

source [find target/stm32f1x.cfg]
# This is an STM32F334 discovery board with a single STM32F334C8T6 chip.
# As it is one of the few boards with stlink V.2-1, we source the corresponding
# nucleo file.
# http://www.st.com/web/en/catalog/tools/FM116/SC959/SS1532/LN1848/PF260318

source [find board/st_nucleo_f3.cfg]
# This is an STM32F3 discovery board with a single STM32F303VCT6 chip.
# http://www.st.com/internet/evalboard/product/254044.jsp

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f3x.cfg]

reset_config srst_only
# This is an STM32F412G discovery board with a single STM32F412ZGT6 chip.
# http://www.st.com/en/evaluation-tools/32f412gdiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000000FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOHEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PB02: CLK, PG06: BK1_NCS, PF06: BK1_IO3, PF07: BK1_IO2, PF09: BK1_IO1, PF08: BK1_IO0

	# PB02:AF09:V, PF09:AF10:V, PF08:AF10:V, PF07:AF09:V, PF06:AF09:V, PG06:AF10:V

	# Port B: PB02:AF09:V
	mmw 0x40020400 0x00000020 0x00000010	;# MODER
	mmw 0x40020408 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x00000900 0x00000600	;# AFRL

	# Port F: PF09:AF10:V, PF08:AF10:V, PF07:AF09:V, PF06:AF09:V
	mmw 0x40021400 0x000AA000 0x00055000	;# MODER
	mmw 0x40021408 0x000FF000 0x00000000	;# OSPEEDR
	mmw 0x40021420 0x99000000 0x66000000	;# AFRL
	mmw 0x40021424 0x000000AA 0x00000055	;# AFRH

	# Port G: PG06:AF10:V
	mmw 0x40021800 0x00002000 0x00001000	;# MODER
	mmw 0x40021808 0x00003000 0x00000000	;# OSPEEDR
	mmw 0x40021820 0x0A000000 0x05000000	;# AFRL

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00170100				;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000003				;# 3 WS for 96 MHz HCLK
	sleep 1
	mww 0x40023804 0x24001808				;# 96 MHz: HSI, PLLM=8, PLLN=96, PLLP=2
	mww 0x40023808 0x00001000				;# APB1: /2, APB2: /1
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32F413H discovery board with a single STM32F413ZHT6 chip.
# http://www.st.com/en/evaluation-tools/32f413hdiscovery.html

#
# Untested!!!
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000000FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOHEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PG06: BK1_NCS, PB02: CLK, PD13: BK1_IO3, PE02: BK1_IO2, PF09: BK1_IO1, PF08: BK1_IO0

	# PB02:AF09:V, PD13:AF09:V, PE02:AF09:V, PF09:AF10:V, PF08:AF10:V, PG06:AF10:V

	# Port B: PB02:AF09:V
	mmw 0x40020400 0x00000020 0x00000010	;# MODER
	mmw 0x40020408 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x00000900 0x00000600	;# AFRL

	# Port D: PD13:AF09:V
	mmw 0x40020C00 0x08000000 0x04000000	;# MODER
	mmw 0x40020C08 0x0C000000 0x00000000	;# OSPEEDR
	mmw 0x40020C24 0x00900000 0x00600000	;# AFRH

	# Port E: PE02:AF09:V
	mmw 0x40021000 0x00000020 0x00000010	;# MODER
	mmw 0x40021008 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40021020 0x00000900 0x00000600	;# AFRL

	# Port F: PF09:AF10:V, PF08:AF10:V
	mmw 0x40021400 0x000A0000 0x00050000	;# MODER
	mmw 0x40021408 0x000F0000 0x00000000	;# OSPEEDR
	mmw 0x40021424 0x000000AA 0x00000055	;# AFRH

	# Port G: PG06:AF10:V
	mmw 0x40021800 0x00002000 0x00001000	;# MODER
	mmw 0x40021808 0x00003000 0x00000000	;# OSPEEDR
	mmw 0x40021820 0x0A000000 0x05000000	;# AFRL

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00170100				;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000003				;# 3 WS for 96 MHz HCLK
	sleep 1
	mww 0x40023804 0x24001808				;# 96 MHz: HSI, PLLM=8, PLLN=96, PLLP=2
	mww 0x40023808 0x00001000				;# APB1: /2, APB2: /1
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
#
# This is an STM32F429 discovery board with a single STM32F429ZI chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF259090
#

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32f4x.cfg]

reset_config srst_only
#
# This is an STM32F429 discovery board with a single STM32F429ZI chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF259090
#

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

source [find target/stm32f4x.cfg]

reset_config srst_only
#
# This is an STM32F469 discovery board with a single STM32F469NI chip.
# http://www.st.com/web/catalog/tools/FM116/CL1620/SC959/SS1532/LN1848/PF262395
#

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

source [find target/stm32f4x.cfg]

reset_config srst_only
# This is an STM32F469I discovery board with a single STM32F469NIH6 chip.
# http://www.st.com/en/evaluation-tools/32f469idiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000007FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PF10: CLK, PB06: BK1_NCS, PF06: BK1_IO3, PF07: BK1_IO2, PF09: BK1_IO1, PF08: BK1_IO0

	# PB06:AF10:V, PF10:AF09:V, PF09:AF10:V, PF08:AF10:V, PF07:AF09:V, PF06:AF09:V

	# Port B: PB06:AF10:V
	mmw 0x40020400 0x00002000 0x00001000	;# MODER
	mmw 0x40020408 0x00003000 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x0A000000 0x05000000	;# AFRL

	# Port F: PF10:AF09:V, PF09:AF10:V, PF08:AF10:V, PF07:AF09:V, PF06:AF09:V
	mmw 0x40021400 0x002AA000 0x00155000	;# MODER
	mmw 0x40021408 0x003FF000 0x00000000	;# OSPEEDR
	mmw 0x40021420 0x99000000 0x66000000	;# AFRL
	mmw 0x40021424 0x000009AA 0x00000655	;# AFRH

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00170100				;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000005				;# 5 WS for 160 MHz HCLK
	sleep 1
	mww 0x40023804 0x24002808				;# 160 MHz: HSI, PLLM=8, PLLN=160, PLLP=2
	mww 0x40023808 0x00009400				;# APB1: /4, APB2: /2
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32F4 discovery board with a single STM32F407VGT6 chip.
# http://www.st.com/internet/evalboard/product/252419.jsp

source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 64KB
set WORKAREASIZE 0x10000

source [find target/stm32f4x.cfg]

reset_config srst_only
# This is an STM32F723E discovery board with a single STM32F723IEK6 chip.
# http://www.st.com/en/evaluation-tools/32f723ediscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 128KB
set WORKAREASIZE 0x20000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f7x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000007FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PB02: CLK, PB06: BK1_NCS, PD13: BK1_IO3, PE02: BK1_IO2, PC10: BK1_IO1, PC09: BK1_IO0

	# PB06:AF10:V, PB02:AF09:V, PC10:AF09:V, PC09:AF09:V, PD13:AF09:V, PE02:AF09:V

	# Port B: PB06:AF10:V, PB02:AF09:V
	mmw 0x40020400 0x00002020 0x00001010	;# MODER
	mmw 0x40020408 0x00003030 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x0A000900 0x05000600	;# AFRL

	# Port C: PC10:AF09:V, PC09:AF09:V
	mmw 0x40020800 0x00280000 0x00140000	;# MODER
	mmw 0x40020808 0x003C0000 0x00000000	;# OSPEEDR
	mmw 0x40020824 0x00000990 0x00000660	;# AFRH

	# Port D: PD13:AF09:V
	mmw 0x40020C00 0x08000000 0x04000000	;# MODER
	mmw 0x40020C08 0x0C000000 0x00000000	;# OSPEEDR
	mmw 0x40020C24 0x00900000 0x00600000	;# AFRH

	# Port E: PE02:AF09:V
	mmw 0x40021000 0x00000020 0x00000010	;# MODER
	mmw 0x40021008 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40021020 0x00000900 0x00000600	;# AFRL

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00190100				;# QUADSPI_DCR: FSIZE=0x19, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 4-byte addresses
	mww 0xA0001014 0x0D003513				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000006				;# 6 WS for 192 MHz HCLK
	sleep 1
	mww 0x40023804 0x24003008				;# 192 MHz: PLLM=8, PLLN=192, PLLP=2
	mww 0x40023808 0x00009400				;# APB1: /4, APB2: /2
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32F746G discovery board with a single STM32F746NGH6 chip.
# http://www.st.com/en/evaluation-tools/32f746gdiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 256KB
set WORKAREASIZE 0x40000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f7x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000007FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PB02: CLK, PB06: BK1_NCS, PD13: BK1_IO3, PE02: BK1_IO2, PD12: BK1_IO1, PD11: BK1_IO0

	# PB06:AF10:V, PB02:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PE02:AF09:V

	# Port B: PB06:AF10:V, PB02:AF09:V
	mmw 0x40020400 0x00002020 0x00001010	;# MODER
	mmw 0x40020408 0x00003030 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x0A000900 0x05000600	;# AFRL

	# Port D: PD13:AF09:V, PD12:AF09:V, PD11:AF09:V
	mmw 0x40020C00 0x0A800000 0x05400000	;# MODER
	mmw 0x40020C08 0x0FC00000 0x00000000	;# OSPEEDR
	mmw 0x40020C24 0x00999000 0x00666000	;# AFRH

	# Port E: PE02:AF09:V
	mmw 0x40021000 0x00000020 0x00000010	;# MODER
	mmw 0x40021008 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40021020 0x00000900 0x00000600	;# AFRL

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00170100				;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000006				;# 6 WS for 192 MHz HCLK
	sleep 1
	mww 0x40023804 0x24003008				;# 192 MHz: PLLM=8, PLLN=192, PLLP=2
	mww 0x40023808 0x00009400				;# APB1: /4, APB2: /2
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32F769I discovery board with a single STM32F769NIH6 chip.
# http://www.st.com/en/evaluation-tools/32f769idiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 256KB
set WORKAREASIZE 0x40000

# enable stmqspi
set QUADSPI 1

source [find target/stm32f7x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x40023830 0x000007FF 0				;# RCC_AHB1ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x40023838 0x00000002 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PB02: CLK, PB06: BK1_NCS, PD13: BK1_IO3, PE02: BK1_IO2, PC10: BK1_IO1, PC09: BK1_IO0

	# PB06:AF10:V, PB02:AF09:V, PC10:AF09:V, PC09:AF09:V, PD13:AF09:V, PE02:AF09:V

	# Port B: PB06:AF10:V, PB02:AF09:V
	mmw 0x40020400 0x00002020 0x00001010	;# MODER
	mmw 0x40020408 0x00003030 0x00000000	;# OSPEEDR
	mmw 0x40020420 0x0A000900 0x05000600	;# AFRL

	# Port C: PC10:AF09:V, PC09:AF09:V
	mmw 0x40020800 0x00280000 0x00140000	;# MODER
	mmw 0x40020808 0x003C0000 0x00000000	;# OSPEEDR
	mmw 0x40020824 0x00000990 0x00000660	;# AFRH

	# Port D: PD13:AF09:V
	mmw 0x40020C00 0x08000000 0x04000000	;# MODER
	mmw 0x40020C08 0x0C000000 0x00000000	;# OSPEEDR
	mmw 0x40020C24 0x00900000 0x00600000	;# AFRH

	# Port E: PE02:AF09:V
	mmw 0x40021000 0x00000020 0x00000010	;# MODER
	mmw 0x40021008 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x40021020 0x00000900 0x00000600	;# AFRL

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x03500008				;# QUADSPI_CR: PRESCALER=3, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00190100				;# QUADSPI_DCR: FSIZE=0x19, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# exit qpi mode
	mww 0xA0001014 0x000033f5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO

	# 1-line memory-mapped read mode with 4-byte addresses
	mww 0xA0001014 0x0D003513				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=READ

	# 4-line qpi mode
	mww 0xA0001014 0x00003135				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=EQIO

	# 4-line memory-mapped read mode with 4-byte addresses
	mww 0xA0001014 0x0F283FEC				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0xA, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=4READ4B
}

$_TARGETNAME configure -event reset-init {
	mww 0x40023C00 0x00000006				;# 6 WS for 192 MHz HCLK
	sleep 1
	mww 0x40023804 0x24003008				;# 192 MHz: PLLM=8, PLLN=192, PLLP=2
	mww 0x40023808 0x00009400				;# APB1: /4, APB2: /2
	mmw 0x40023800 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40023808 0x00000002 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32F7 discovery board with a single STM32F756NGH6 chip.
# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF261641

# This is for using the onboard STLINK/V2-1
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 256KB
set WORKAREASIZE 0x40000

source [find target/stm32f7x.cfg]
# This is a stm32h735g-dk with a single STM32H735IGK6 chip.
# https://www.st.com/en/evaluation-tools/stm32h735g-dk.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h735igk6

# enable stmqspi
if {![info exists OCTOSPI1]} {
	set OCTOSPI1 1
	set OCTOSPI2 0
}

source [find target/stm32h7x.cfg]

# OCTOSPI initialization
# octo: 8-line mode
proc octospi_init { octo } {
	global a b
	mmw 0x58024540 0x000006FF 0				;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x58024534 0x00284000 0				;# RCC_AHB3ENR |= IOMNGREN, OSPI2EN, OSPI1EN (enable clocks)
	sleep 1									;# Wait for clock startup

	mww 0x5200B404 0x03010111				;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI1
	mww 0x5200B408 0x00000000				;# OCTOSPIM_P2CR: disable Port 2

	# PG06: OCSPI1_NCS, PF10: OCSPI1_CLK, PB02: OCSPI1_DQS, PD07: OCSPI1_IO7, PG09: OCSPI1_IO6, PD05: OCSPI1_IO5,
	# PD04: OCSPI1_IO4, PD13: OCSPI1_IO3, PE02: OCSPI1_IO2, PD12: OCSPI1_IO1, PD11: OCSPI1_IO0

	# PB02:AF10:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PD07:AF10:V, PD05:AF10:V
	# PD04:AF10:V, PE02:AF09:V, PF10:AF09:V, PG09:AF09:V, PG06:AF10:V
	# Port B: PB02:AF10:V
	mmw 0x58020400 0x00000020 0x00000010	;# MODER
	mmw 0x58020408 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x5802040C 0x00000000 0x00000030	;# PUPDR
	mmw 0x58020420 0x00000A00 0x00000500	;# AFRL
	# Port D: PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PD07:AF10:V, PD05:AF10:V, PD04:AF10:V
	mmw 0x58020C00 0x0A808A00 0x05404500	;# MODER
	mmw 0x58020C08 0x0FC0CF00 0x00000000	;# OSPEEDR
	mmw 0x58020C0C 0x00000000 0x0FC0CF00	;# PUPDR
	mmw 0x58020C20 0xA0AA0000 0x50550000	;# AFRL
	mmw 0x58020C24 0x00999000 0x00666000	;# AFRH
	# Port E: PE02:AF09:V
	mmw 0x58021000 0x00000020 0x00000010	;# MODER
	mmw 0x58021008 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x5802100C 0x00000000 0x00000030	;# PUPDR
	mmw 0x58021020 0x00000900 0x00000600	;# AFRL
	# Port F: PF10:AF09:V
	mmw 0x58021400 0x00200000 0x00100000	;# MODER
	mmw 0x58021408 0x00300000 0x00000000	;# OSPEEDR
	mmw 0x5802140C 0x00000000 0x00300000	;# PUPDR
	mmw 0x58021424 0x00000900 0x00000600	;# AFRH
	# Port G: PG09:AF09:V, PG06:AF10:V
	mmw 0x58021800 0x00082000 0x00041000	;# MODER
	mmw 0x58021808 0x000C3000 0x00000000	;# OSPEEDR
	mmw 0x5802180C 0x00000000 0x000C3000	;# PUPDR
	mmw 0x58021820 0x0A000000 0x05000000	;# AFRL
	mmw 0x58021824 0x00000090 0x00000060	;# AFRH

	# OCTOSPI1: memory-mapped 1-line read mode with 4-byte addresses
	mww 0x52005130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x52005000 0x3040000B				;# OCTOSPI_CR: FMODE=0x1, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0
	mww 0x52005008 0x01190100				;# OCTOSPI_DCR1: MTYP=0x1, FSIZE=0x19, CSHT=0x01, CKMODE=0, DLYBYP=0
	mww 0x5200500C 0x00000005				;# OCTOSPI_DCR2: PRESCALER=5

	mww 0x52005108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x0
	mww 0x52005100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
	mww 0x52005110 0x00000013				;# OCTOSPI_IR: INSTR=READ4B

	flash probe $a							;# load configuration from CR, TCR, CCR, IR register values

	if { $octo == 1 } {
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05								;# Read Status Register
		stmqspi cmd $a 0 0x72 0x00 0x00 0x00 0x00 0x02		;# Write Conf. Reg. 2, addr 0x00000000: DTR OPI enable

		# OCTOSPI1: memory-mapped 8-line read mode with 4-byte addresses
		mww 0x52005000 0x3040000B				;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=1, EN=1
		mww 0x52005108 0x10000006				;# OCTOSPI_TCR: SSHIFT=0, DHQC=1, DCYC=0x6
		mww 0x52005100 0x2C003C1C				;# OCTOSPI_CCR: DTR, DMODE=0x4, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x4, ISIZE=0x1, IMODE=0x4
		mww 0x52005110 0x0000EE11				;# OCTOSPI_IR: INSTR=OCTA DTR Read

		flash probe $a							;# reload configuration from CR, TCR, CCR, IR register values

		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 0 0x04								;# Write Disable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
	}
}

$_CHIPNAME.cpu0 configure -event reset-init {
	global OCTOSPI1
	global OCTOSPI2

	mmw 0x52002000 0x00000004 0x0000000B	;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $OCTOSPI1 } {
		octospi_init 1
	}
}
# This is a stm32h745i-disco with a single STM32H745XIH6 chip.
# www.st.com/en/product/stm32h745i-disco.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h745xih6

# enable stmqspi
if {![info exists QUADSPI]} {
	set QUADSPI 1
}

source [find target/stm32h7x_dual_bank.cfg]

source [find board/stm32h7x_dual_qspi.cfg]

$_CHIPNAME.cpu0 configure -event reset-init {
	global QUADSPI

	mmw 0x52002000 0x00000004 0x0000000B	;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $QUADSPI } {
		qspi_init 1
	}
}

# This is a stm32h747i-disco with a single STM32H747XIH6 chip.
# www.st.com/en/product/stm32h747i-disco.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h747xih6

# enable stmqspi
if {![info exists QUADSPI]} {
	set QUADSPI 1
}

source [find target/stm32h7x_dual_bank.cfg]

# QUADSPI initialization
# qpi: 4-line mode
proc qspi_init { qpi } {
	global a
	mmw 0x580244E0 0x000007FF 0				;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x580244D4 0x00004000 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PG06: BK1_NCS, PB02: CLK, PF06: BK1_IO3, PF07: BK1_IO2, PF09: BK1_IO1, PD11: BK1_IO0,
	# PG14: BK2_IO3, PG09: BK2_IO2, PH03: BK2_IO1, PH02: BK2_IO0

	# PB02:AF09:V, PD11:AF09:V, PF09:AF10:V, PF07:AF09:V, PF06:AF09:V, PG14:AF09:H
	# PG09:AF09:V, PG06:AF10:H, PH03:AF09:V, PH02:AF09:V

	# Port B: PB02:AF09:V
	mmw 0x58020400 0x00000020 0x00000010	;# MODER
	mmw 0x58020408 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x58020420 0x00000900 0x00000600	;# AFRL
	# Port D: PD11:AF09:V
	mmw 0x58020C00 0x00800000 0x00400000	;# MODER
	mmw 0x58020C08 0x00C00000 0x00000000	;# OSPEEDR
	mmw 0x58020C24 0x00009000 0x00006000	;# AFRH
	# Port F: PF09:AF10:V, PF07:AF09:V, PF06:AF09:V
	mmw 0x58021400 0x0008A000 0x00045000	;# MODER
	mmw 0x58021408 0x000CF000 0x00000000	;# OSPEEDR
	mmw 0x58021420 0x99000000 0x66000000	;# AFRL
	mmw 0x58021424 0x000000A0 0x00000050	;# AFRH
	# Port G: PG14:AF09:H, PG09:AF09:V, PG06:AF10:H
	mmw 0x58021800 0x20082000 0x10041000	;# MODER
	mmw 0x58021808 0x200C2000 0x10001000	;# OSPEEDR
	mmw 0x58021820 0x0A000000 0x05000000	;# AFRL
	mmw 0x58021824 0x09000090 0x06000060	;# AFRH
	# Port H: PH03:AF09:V, PH02:AF09:V
	mmw 0x58021C00 0x000000A0 0x00000050	;# MODER
	mmw 0x58021C08 0x000000F0 0x00000000	;# OSPEEDR
	mmw 0x58021C20 0x00009900 0x00006600	;# AFRL

	# correct FSIZE is 0x1A, however, this causes trouble when
	# reading the last bytes at end of bank in *memory mapped* mode

	# for dual flash mode 2 * mt25ql512
	mww 0x52005000 0x05500058				;# QUADSPI_CR: PRESCALER=5, APMS=1, FTHRES=0, FSEL=0, DFM=1, SSHIFT=1, TCEN=1
	mww 0x52005004 0x001A0200				;# QUADSPI_DCR: FSIZE=0x1A, CSHT=0x02, CKMODE=0

	mww 0x52005030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x52005014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1
	mmw 0x52005000 0x00000001 0				;# QUADSPI_CR: EN=1

	# Exit QPI mode
	mmw 0x52005000 0x00000002 0				;# QUADSPI_CR: ABORT=1
	mww 0x52005014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=Exit QPI
	sleep 1

	if { $qpi == 1 } {
		# Write Enable
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000106			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enable
		sleep 1

		# Configure dummy clocks via volatile configuration register
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005010 0x00000001			;# QUADSPI_DLR: 2 data bytes
		mww 0x52005014 0x01000181			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x1, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Volatile Conf. Reg.
		mwh 0x52005020 0xABAB				;# QUADSPI_DR: 0xAB 0xAB for 10 dummy clocks
		sleep 1

		# Write Enable
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000106			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enable
		sleep 1

		# Enable QPI mode via enhanced volatile configuration register
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005010 0x00000001			;# QUADSPI_DLR: 2 data bytes
		mww 0x52005014 0x01000161			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x1, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enhanced Conf. Reg.
		mwh 0x52005020 0x3F3F				;# QUADSPI_DR: 0x3F 0x3F to enable QPI and DPI mode
		sleep 1

		# Enter QPI mode
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000135			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Enter QPI
		sleep 1

		# memory-mapped fast read mode with 4-byte addresses and 10 dummy cycles (for read only)
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x0F283FEC			;# QUADSPI_CCR: FMODE=0x3, DMODE=0x3, DCYC=0xA, ADSIZE=0x3, ADMODE=0x3, IMODE=0x3, INSTR=Fast READ
	} else {
		# memory-mapped read mode with 4-byte addresses
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x0D003513			;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=READ
	}
}

$_CHIPNAME.cpu0 configure -event reset-init {
	global QUADSPI

	mmw 0x52002000 0x00000004 0x0000000B	;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $QUADSPI } {
		qspi_init 1
	}
}

# This is a stm32h750b-dk with a single STM32H750XBH6 chip.
# www.st.com/en/product/stm32h750b-dk.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h750xbh6

# enable stmqspi
if {![info exists QUADSPI]} {
	set QUADSPI 1
}

source [find target/stm32h7x.cfg]

source [find board/stm32h7x_dual_qspi.cfg]

$_CHIPNAME.cpu0 configure -event reset-init {
	global QUADSPI

	mmw 0x52002000 0x00000004 0x0000000B	;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $QUADSPI } {
		qspi_init 1
	}
}

# This is a stm32h7b3i-dk with a single STM32H7B3LIH6Q chip.
# https://www.st.com/en/evaluation-tools/stm32h7b3i-dk.html
#

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

set CHIPNAME stm32h7b3lih6q

# enable stmqspi
if {![info exists OCTOSPI1]} {
	set OCTOSPI1 1
	set OCTOSPI2 0
}

source [find target/stm32h7x_dual_bank.cfg]

# OCTOSPI initialization
# octo: 8-line mode
proc octospi_init { octo } {
	global a b
	mmw 0x58024540 0x000007FF 0				;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x58024534 0x00284000 0				;# RCC_AHB3ENR |= IOMNGREN, OSPI2EN, OSPI1EN (enable clocks)
	sleep 1									;# Wait for clock startup

	mww 0x5200B404 0x03010111				;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI1
	mww 0x5200B408 0x00000000				;# OCTOSPIM_P2CR: disable Port 2

	# PG06: OCSPI1_NCS, PB02: OCSPI1_CLK, PC05: OCSPI1_DQS, PD07: OCSPI1_IO7, PG09: OCSPI1_IO6, PH03: OCSPI1_IO5,
	# PC01: OCSPI1_IO4, PF06: OCSPI1_IO3, PF07: OCSPI1_IO2, PF09: OCSPI1_IO1, PD11: OCSPI1_IO0

	# PB02:AF09:V, PC05:AF10:V, PC01:AF10:V, PD11:AF09:V, PD07:AF10:V, PF09:AF10:V
	# PF07:AF10:V, PF06:AF10:V, PG09:AF09:V, PG06:AF10:V, PH03:AF09:V
	# Port B: PB02:AF09:V
	mmw 0x58020400 0x00000020 0x00000010	;# MODER
	mmw 0x58020408 0x00000030 0x00000000	;# OSPEEDR
	mmw 0x5802040C 0x00000000 0x00000030	;# PUPDR
	mmw 0x58020420 0x00000900 0x00000600	;# AFRL
	# Port C: PC05:AF10:V, PC01:AF10:V
	mmw 0x58020800 0x00000808 0x00000404	;# MODER
	mmw 0x58020808 0x00000C0C 0x00000000	;# OSPEEDR
	mmw 0x5802080C 0x00000000 0x00000C0C	;# PUPDR
	mmw 0x58020820 0x00A000A0 0x00500050	;# AFRL
	# Port D: PD11:AF09:V, PD07:AF10:V
	mmw 0x58020C00 0x00808000 0x00404000	;# MODER
	mmw 0x58020C08 0x00C0C000 0x00000000	;# OSPEEDR
	mmw 0x58020C0C 0x00000000 0x00C0C000	;# PUPDR
	mmw 0x58020C20 0xA0000000 0x50000000	;# AFRL
	mmw 0x58020C24 0x00009000 0x00006000	;# AFRH
	# Port F: PF09:AF10:V, PF07:AF10:V, PF06:AF10:V
	mmw 0x58021400 0x0008A000 0x00045000	;# MODER
	mmw 0x58021408 0x000CF000 0x00000000	;# OSPEEDR
	mmw 0x5802140C 0x00000000 0x000CF000	;# PUPDR
	mmw 0x58021420 0xAA000000 0x55000000	;# AFRL
	mmw 0x58021424 0x000000A0 0x00000050	;# AFRH
	# Port G: PG09:AF09:V, PG06:AF10:V
	mmw 0x58021800 0x00082000 0x00041000	;# MODER
	mmw 0x58021808 0x000C3000 0x00000000	;# OSPEEDR
	mmw 0x5802180C 0x00000000 0x000C3000	;# PUPDR
	mmw 0x58021820 0x0A000000 0x05000000	;# AFRL
	mmw 0x58021824 0x00000090 0x00000060	;# AFRH
	# Port H: PH03:AF09:V
	mmw 0x58021C00 0x00000080 0x00000040	;# MODER
	mmw 0x58021C08 0x000000C0 0x00000000	;# OSPEEDR
	mmw 0x58021C0C 0x00000000 0x000000C0	;# PUPDR
	mmw 0x58021C20 0x00009000 0x00006000	;# AFRL

	# OCTOSPI1: memory-mapped 1-line read mode with 4-byte addresses
	mww 0x52005130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x52005000 0x3040000B				;# OCTOSPI_CR: FMODE=0x1, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0
	mww 0x52005008 0x01190100				;# OCTOSPI_DCR1: MTYP=0x1, FSIZE=0x19, CSHT=0x01, CKMODE=0, DLYBYP=0
	mww 0x5200500C 0x00000005				;# OCTOSPI_DCR2: PRESCALER=5

	mww 0x52005108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x0
	mww 0x52005100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
	mww 0x52005110 0x00000013				;# OCTOSPI_IR: INSTR=READ4B

	flash probe $a							;# load configuration from CR, TCR, CCR, IR register values

	if { $octo == 1 } {
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05								;# Read Status Register
		stmqspi cmd $a 0 0x72 0x00 0x00 0x00 0x00 0x02		;# Write Conf. Reg. 2, addr 0x00000000: DTR OPI enable

		# OCTOSPI1: memory-mapped 8-line read mode with 4-byte addresses
		mww 0x52005000 0x3040000B				;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=1, EN=1
		mww 0x52005108 0x10000006				;# OCTOSPI_TCR: SSHIFT=0, DHQC=1, DCYC=0x6
		mww 0x52005100 0x2C003C1C				;# OCTOSPI_CCR: DTR, DMODE=0x4, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x4, ISIZE=0x1, IMODE=0x4
		mww 0x52005110 0x0000EE11				;# OCTOSPI_IR: INSTR=OCTA DTR Read

		flash probe $a							;# reload configuration from CR, TCR, CCR, IR register values

		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 0 0x04								;# Write Disable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
	}
}

$_CHIPNAME.cpu0 configure -event reset-init {
	global OCTOSPI1
	global OCTOSPI2

	mmw 0x52002000 0x00000004 0x0000000B	;# FLASH_ACR: 4 WS for 192 MHZ HCLK

	mmw 0x58024400 0x00000001 0x00000018	;# RCC_CR: HSIDIV=1, HSI on
	mmw 0x58024410 0x10000000 0xEE000007	;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
	mww 0x58024418 0x00000040				;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
	mww 0x5802441C 0x00000440				;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
	mww 0x58024420 0x00000040				;# RCC_D3CFGR: D3PPRE=2
	mww 0x58024428 0x00000040				;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
	mmw 0x5802442C 0x0001000C 0x00000002	;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
	mww 0x58024430 0x01070217				;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
	mmw 0x58024400 0x01000000 0				;# RCC_CR: PLL1ON=1
	sleep 1
	mmw 0x58024410 0x00000003 0				;# RCC_CFGR: PLL1 as system clock
	sleep 1

	adapter speed 24000

	if { $OCTOSPI1 } {
		octospi_init 1
	}
}
# STM32H7[4|5]3I-EVAL: this is for the H7 eval boards.
# This is an ST EVAL-H743XI board with single STM32H743XI chip.
# http://www.st.com/en/evaluation-tools/stm32h743i-eval.html
# This is an ST EVAL-H753XI board with single STM32H753XI chip.
# http://www.st.com/en/evaluation-tools/stm32h753i-eval.html

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32h7x_dual_bank.cfg]

reset_config srst_only
# stm32h754i-disco and stm32h750b-dk dual quad qspi.

# QUADSPI initialization
# qpi: 4-line mode
proc qspi_init { qpi } {
	global a
	mmw 0x580244E0 0x000007FF 0				;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
	mmw 0x580244D4 0x00004000 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PG06: BK1_NCS, PF10: CLK, PF06: BK1_IO3, PF07: BK1_IO2, PF09: BK1_IO1, PD11: BK1_IO0,
	# PG14: BK2_IO3, PG09: BK2_IO2, PH03: BK2_IO1, PH02: BK2_IO0

	# PD11:AF09:V, PF10:AF09:V, PF09:AF10:V, PF07:AF09:V, PF06:AF09:V, PG14:AF09:H
	# PG09:AF09:V, PG06:AF10:H, PH03:AF09:V, PH02:AF09:V

	# Port D: PD11:AF09:V
	mmw 0x58020C00 0x00800000 0x00400000	;# MODER
	mmw 0x58020C08 0x00C00000 0x00000000	;# OSPEEDR
	mmw 0x58020C24 0x00009000 0x00006000	;# AFRH
	# Port F: PF10:AF09:V, PF09:AF10:V, PF07:AF09:V, PF06:AF09:V
	mmw 0x58021400 0x0028A000 0x00145000	;# MODER
	mmw 0x58021408 0x003CF000 0x00000000	;# OSPEEDR
	mmw 0x58021420 0x99000000 0x66000000	;# AFRL
	mmw 0x58021424 0x000009A0 0x00000650	;# AFRH
	# Port G: PG14:AF09:H, PG09:AF09:V, PG06:AF10:H
	mmw 0x58021800 0x20082000 0x10041000	;# MODER
	mmw 0x58021808 0x200C2000 0x10001000	;# OSPEEDR
	mmw 0x58021820 0x0A000000 0x05000000	;# AFRL
	mmw 0x58021824 0x09000090 0x06000060	;# AFRH
	# Port H: PH03:AF09:V, PH02:AF09:V
	mmw 0x58021C00 0x000000A0 0x00000050	;# MODER
	mmw 0x58021C08 0x000000F0 0x00000000	;# OSPEEDR
	mmw 0x58021C20 0x00009900 0x00006600	;# AFRL

	# correct FSIZE is 0x1A, however, this causes trouble when
	# reading the last bytes at end of bank in *memory mapped* mode

	# for dual flash mode 2 * mt25ql512
	mww 0x52005000 0x05500058				;# QUADSPI_CR: PRESCALER=5, APMS=1, FTHRES=0, FSEL=0, DFM=1, SSHIFT=1, TCEN=1
	mww 0x52005004 0x001A0200				;# QUADSPI_DCR: FSIZE=0x1A, CSHT=0x02, CKMODE=0

	mww 0x52005030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0x52005014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1
	mmw 0x52005000 0x00000001 0				;# QUADSPI_CR: EN=1

	# Exit QPI mode
	mmw 0x52005000 0x00000002 0				;# QUADSPI_CR: ABORT=1
	mww 0x52005014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=Exit QPI
	sleep 1

	if { $qpi == 1 } {
		# Write Enable
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000106			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enable
		sleep 1

		# Configure dummy clocks via volatile configuration register
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005010 0x00000001			;# QUADSPI_DLR: 2 data bytes
		mww 0x52005014 0x01000181			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x1, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Volatile Conf. Reg.
		mwh 0x52005020 0xABAB				;# QUADSPI_DR: 0xAB 0xAB for 10 dummy clocks
		sleep 1

		# Write Enable
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000106			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enable
		sleep 1

		# Enable QPI mode via enhanced volatile configuration register
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005010 0x00000001			;# QUADSPI_DLR: 2 data bytes
		mww 0x52005014 0x01000161			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x1, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Write Enhanced Conf. Reg.
		mwh 0x52005020 0x3F3F				;# QUADSPI_DR: 0x3F 0x3F to enable QPI and DPI mode
		sleep 1

		# Enter QPI mode
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x00000135			;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=Enter QPI
		sleep 1

		# memory-mapped fast read mode with 4-byte addresses and 10 dummy cycles (for read only)
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x0F283FEC			;# QUADSPI_CCR: FMODE=0x3, DMODE=0x3, DCYC=0xA, ADSIZE=0x3, ADMODE=0x3, IMODE=0x3, INSTR=Fast READ
	} else {
		# memory-mapped read mode with 4-byte addresses
		mmw 0x52005000 0x00000002 0			;# QUADSPI_CR: ABORT=1
		mww 0x52005014 0x0D003513			;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x3, ADMODE=0x1, IMODE=0x1, INSTR=READ
	}
}
# This is an STM32L053 discovery board with a single STM32L053 chip.
# http://www.st.com/web/en/catalog/tools/PF260319

source [find interface/stlink.cfg]

transport select hla_swd

set WORKAREASIZE 0x2000
source [find target/stm32l0.cfg]

reset_config srst_only
# This is an STM32L476G discovery board with a single STM32L476VGT6 chip.
# http://www.st.com/en/evaluation-tools/32l476gdiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 96KB
set WORKAREASIZE 0x18000

# enable stmqspi
set QUADSPI 1

source [find target/stm32l4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x4002104C 0x000001FF 0				;# RCC_AHB2ENR |= GPIOAEN-GPIOIEN (enable clocks)
	mmw 0x40021050 0x00000100 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PE11: NCS, PE10: CLK, PE15: BK1_IO3, PE14: BK1_IO2, PE13: BK1_IO1, PE12: BK1_IO0

	# PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V

	# Port E: PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V
	mmw 0x48001000 0xAAA00000 0x55500000    ;# MODER
	mmw 0x48001008 0xFFF00000 0x00000000    ;# OSPEEDR
	mmw 0x48001024 0xAAAAAA00 0x55555500    ;# AFRH

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x01500008				;# QUADSPI_CR: PRESCALER=1, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00170100				;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mmw 0x40022000 0x00000004 0x00000003	;# 4 WS for 72 MHz HCLK
	sleep 1
	mmw 0x40021000 0x00000100 0x00000000	;# HSI on
	mww 0x4002100C 0x01002432				;# 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI
	mww 0x40021008 0x00008001				;# always HSI, APB1: /1, APB2: /1
	mmw 0x40021000 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40021008 0x00000003 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# This is an STM32L496G discovery board with a single STM32L496AGI6 chip.
# http://www.st.com/en/evaluation-tools/32l496gdiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 96KB
set WORKAREASIZE 0x18000

# enable stmqspi
set QUADSPI 1

source [find target/stm32l4x.cfg]

# QUADSPI initialization
proc qspi_init { } {
	global a
	mmw 0x4002104C 0x000001FF 0				;# RCC_AHB2ENR |= GPIOAEN-GPIOIEN (enable clocks)
	mmw 0x40021050 0x00000100 0				;# RCC_AHB3ENR |= QSPIEN (enable clock)
	sleep 1									;# Wait for clock startup

	# PB11: BK1_NCS, PA03: CLK, PA06: BK1_IO3, PA07: BK1_IO2, PB00: BK1_IO1, PB01: BK1_IO0

	# PA07:AF10:V, PA06:AF10:V, PA03:AF10:V, PB11:AF10:V, PB01:AF10:V, PB00:AF10:V

	# Port A: PA07:AF10:V, PA06:AF10:V, PA03:AF10:V
	mmw 0x48000000 0x0000A080 0x00005040    ;# MODER
	mmw 0x48000008 0x0000F0C0 0x00000000    ;# OSPEEDR
	mmw 0x48000020 0xAA00A000 0x55005000    ;# AFRL

	# Port B: PB11:AF10:V, PB01:AF10:V, PB00:AF10:V
	mmw 0x48000400 0x0080000A 0x00400005    ;# MODER
	mmw 0x48000408 0x00C0000F 0x00000000    ;# OSPEEDR
	mmw 0x48000420 0x000000AA 0x00000055    ;# AFRL
	mmw 0x48000424 0x0000A000 0x00005000    ;# AFRH

	mww 0xA0001030 0x00001000				;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x01500008				;# QUADSPI_CR: PRESCALER=1, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1
	mww 0xA0001004 0x00160100				;# QUADSPI_DCR: FSIZE=0x16, CSHT=0x01, CKMODE=0
	mmw 0xA0001000 0x00000001 0				;# QUADSPI_CR: EN=1

	# 1-line spi mode
	mww 0xA0001014 0x000003F5				;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=RSTQIO
	sleep 1

	# memory-mapped read mode with 3-byte addresses
	mww 0xA0001014 0x0D002503				;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ
}

$_TARGETNAME configure -event reset-init {
	mmw 0x40022000 0x00000004 0x00000003	;# 4 WS for 72 MHz HCLK
	sleep 1
	mmw 0x40021000 0x00000100 0x00000000	;# HSI on
	mww 0x4002100C 0x01002432				;# 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI
	mww 0x40021008 0x00008001				;# always HSI, APB1: /1, APB2: /1
	mmw 0x40021000 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40021008 0x00000003 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	qspi_init
}
# Explicitly for the STM32L476 discovery board:
# http://www.st.com/web/en/catalog/tools/PF261635
# but perfectly functional for any other STM32L4 board connected via
# an stlink-v2-1 interface.
# This is for STM32L4 boards that are connected via stlink-v2-1.

source [find interface/stlink.cfg]

transport select hla_swd

source [find target/stm32l4x.cfg]

reset_config srst_only
# This is a STM32L4P5G discovery board with a single STM32L4R9AGI6 chip.
# http://www.st.com/en/evaluation-tools/stm32l4p5g-dk.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 96KB
set WORKAREASIZE 0x18000

# enable stmqspi
set OCTOSPI1 1
set OCTOSPI2 0

source [find target/stm32l4x.cfg]

# OCTOSPI initialization
# octo: 8-line mode
proc octospi_init { octo } {
	global a b
	mmw 0x4002104C 0x001001FF 0				;# RCC_AHB2ENR |= OSPIMEN, GPIOAEN-GPIOIEN (enable clocks)
	mmw 0x40021050 0x00000300 0				;# RCC_AHB3ENR |= OSPI2EN, OSPI1EN (enable clocks)
	mmw 0x40021058 0x10000000 0				;# RCC_APB1ENR1 |= PWREN (enable clock)
	sleep 1									;# Wait for clock startup

	mmw 0x40007004 0x00000200 0				;# PWR_CR2 |= IOSV (required for use of GPOIG, cf. RM0432)

	mww 0x50061C04 0x07050333				;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI2
	mww 0x50061C08 0x03010111				;# OCTOSPIM_P2CR: assign Port 2 to OCTOSPI1

	# PE11: P1_NCS, PE10: P1_CLK, PG06: P1_DQS, PD07: P1_IO7, PC03: P1_IO6, PD05: P1_IO5
	# PD04: P1_IO4, PA06: P1_IO3, PA07: P1_IO2, PE13: P1_IO1, PE11: P1_IO0

	# PA07:AF10:V, PA06:AF10:V, PC03:AF10:V, PD07:AF10:V, PD05:AF10:V, PD04:AF10:V
	# PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V, PG06:AF03:V

	# Port A: PA07:AF10:V, PA06:AF10:V
	mmw 0x48000000 0x0000A000 0x00005000	;# MODER
	mmw 0x48000008 0x0000F000 0x00000000	;# OSPEEDR
	mmw 0x4800000C 0x00000000 0x0000F000	;# PUPDR
	mmw 0x48000020 0xAA000000 0x55000000	;# AFRL
	# Port C: PC03:AF10:V
	mmw 0x48000800 0x00000080 0x00000040	;# MODER
	mmw 0x48000808 0x000000C0 0x00000000	;# OSPEEDR
	mmw 0x4800080C 0x00000000 0x000000C0	;# PUPDR
	mmw 0x48000820 0x0000A000 0x00005000	;# AFRL
	# Port D: PD07:AF10:V, PD05:AF10:V, PD04:AF10:V
	mmw 0x48000C00 0x00008A00 0x00004500	;# MODER
	mmw 0x48000C08 0x0000CF00 0x00000000	;# OSPEEDR
	mmw 0x48000C0C 0x00000000 0x0000CF00	;# PUPDR
	mmw 0x48000C20 0xA0AA0000 0x50550000	;# AFRL
	# Port E: PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V
	mmw 0x48001000 0x0AA00000 0x05500000	;# MODER
	mmw 0x48001008 0x0FF00000 0x00000000	;# OSPEEDR
	mmw 0x4800100C 0x00000000 0x0FF00000	;# PUPDR
	mmw 0x48001024 0x00AAAA00 0x00555500	;# AFRH
	# Port G: PG06:AF03:V
	mmw 0x48001800 0x00002000 0x00001000	;# MODER
	mmw 0x48001808 0x00003000 0x00000000	;# OSPEEDR
	mmw 0x4800180C 0x00000000 0x00003000	;# PUPDR
	mmw 0x48001820 0x03000000 0x0C000000	;# AFRL

	# PG12: P2_NCS, PF04: P2_CLK, PF12: P2_DQS, PG10: P2_IO7, PG09: P2_IO6, PG01: P2_IO5
	# PG00: P2_IO4, PF03: P2_IO3, PF02: P2_IO2, PF01: P2_IO1, PF00: P2_IO0

	# PF12:AF05:V, PF04:AF05:V, PF03:AF05:V, PF02:AF05:V, PF01:AF05:V, PF00:AF05:V
	# PG12:AF05:V, PG10:AF05:V, PG09:AF05:V, PG01:AF05:V, PG00:AF05:V

	# Port F: PF12:AF05:V, PF04:AF05:V, PF03:AF05:V, PF02:AF05:V, PF01:AF05:V, PF00:AF05:V
	mmw 0x48001400 0x020002AA 0x01000155	;# MODER
	mmw 0x48001408 0x030003FF 0x00000000	;# OSPEEDR
	mmw 0x4800140C 0x00000000 0x030003FF	;# PUPDR
	mmw 0x48001420 0x00055555 0x000AAAAA	;# AFRL
	mmw 0x48001424 0x00050000 0x000A0000	;# AFRH
	# Port G: PG12:AF05:V, PG10:AF05:V, PG09:AF05:V, PG01:AF05:V, PG00:AF05:V
	mmw 0x48001800 0x0228000A 0x01140005	;# MODER
	mmw 0x48001808 0x033C000F 0x00000000	;# OSPEEDR
	mmw 0x4800180C 0x00000000 0x033C000F	;# PUPDR
	mmw 0x48001820 0x00000055 0x000000AA	;# AFRL
	mmw 0x48001824 0x00050550 0x000A0AA0	;# AFRH

	# OCTOSPI1: memory-mapped 1-line read mode with 4-byte addresses
	mww 0xA0001130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x3040000B				;# OCTOSPI_CR: FMODE=0x1, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0
	mww 0xA0001008 0x01190100				;# OCTOSPI_DCR1: MTYP=0x1, FSIZE=0x19, CSHT=0x01, CKMODE=0, DLYBYP=0
	mww 0xA000100C 0x00000001				;# OCTOSPI_DCR2: PRESCALER=1

	mww 0xA0001108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x0
	mww 0xA0001100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
	mww 0xA0001110 0x00000013				;# OCTOSPI_IR: INSTR=READ4B

	if { $octo == 1 } {
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05								;# Read Status Register
		stmqspi cmd $a 0 0x72 0x00 0x00 0x00 0x00 0x02		;# Write Conf. Reg. 2, addr 0x00000000: DTR OPI enable

		# OCTOSPI1: memory-mapped 8-line read mode with 4-byte addresses
		mww 0xA0001000 0x3040000B				;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=1, EN=1
		mww 0xA0001108 0x10000006				;# OCTOSPI_TCR: SSHIFT=0, DHQC=1, DCYC=0x6
		mww 0xA0001100 0x2C003C1C				;# OCTOSPI_CCR: DTR, DMODE=0x4, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x4, ISIZE=0x1, IMODE=0x4
		mww 0xA0001110 0x0000EE11				;# OCTOSPI_IR: INSTR=OCTA DTR Read

		flash probe $a							;# reload configuration from CR, TCR, CCR, IR register values

		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 0 0x04								;# Write Disable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
	}
}

$_TARGETNAME configure -event reset-init {
	mmw 0x40022000 0x00000003 0x0000000C	;# 3 WS for 72 MHz HCLK
	sleep 1
	mmw 0x40021000 0x00000100 0x00000000	;# HSI on
	mww 0x4002100C 0x01002432				;# RCC_PLLCFGR 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI
	mww 0x40021008 0x00008001				;# always HSI, APB1: /1, APB2: /1
	mmw 0x40021000 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40021008 0x00000003 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 24000

	octospi_init 1
}

# This is a STM32L4R9I discovery board with a single STM32L4R9AII6 chip.
# http://www.st.com/en/evaluation-tools/32l4r9idiscovery.html

# This is for using the onboard STLINK
source [find interface/stlink.cfg]

transport select hla_swd

# increase working area to 96KB
set WORKAREASIZE 0x18000

# enable stmqspi
set OCTOSPI1 1
set OCTOSPI2 0

source [find target/stm32l4x.cfg]

# OCTOSPI initialization
# octo: 8-line mode
proc octospi_init { octo } {
	global a b
	mmw 0x4002104C 0x001001FF 0				;# RCC_AHB2ENR |= OSPIMEN, GPIOAEN-GPIOIEN (enable clocks)
	mmw 0x40021050 0x00000300 0				;# RCC_AHB3ENR |= OSPI2EN, OSPI1EN (enable clocks)
	mmw 0x40021058 0x10000000 0				;# RCC_APB1ENR1 |= PWREN (enable clock)
	sleep 1									;# Wait for clock startup

	mmw 0x40007004 0x00000200 0				;# PWR_CR2 |= IOSV (required for use of GPOIG, cf. RM0432)

	mww 0x50061C04 0x00000000				;# OCTOSPIM_P1CR: disable Port 1
	mww 0x50061C08 0x03010111				;# OCTOSPIM_P2CR: assign Port 2 to OCTOSPI1

	# PG12: P2_NCS, PI06: P2_CLK, PG15: P2_DQS, PG10: P2_IO7, PG09: P2_IO6, PH10: P2_IO5,
	# PH09: P2_IO4, PH08: P2_IO3, PI09: P2_IO2, PI10: P2_IO1, PI11: P2_IO0

	# PG15:AF05:V, PG12:AF05:V, PG10:AF05:V, PG09:AF05:V, PH10:AF05:V, PH09:AF05:V
	# PH08:AF05:V, PI11:AF05:V, PI10:AF05:V, PI09:AF05:V, PI06:AF05:V

	# Port G: PG15:AF05:V, PG12:AF05:V, PG10:AF05:V, PG09:AF05:V
	mmw 0x48001800 0x82280000 0x41140000	;# MODER
	mmw 0x48001808 0xC33C0000 0x00000000	;# OSPEEDR
	mmw 0x48001824 0x50050550 0xA00A0AA0	;# AFRH

	# Port H: PH10:AF05:V, PH09:AF05:V, PH08:AF05:V
	mmw 0x48001C00 0x002A0000 0x00150000	;# MODER
	mmw 0x48001C08 0x003F0000 0x00000000	;# OSPEEDR
	mmw 0x48001C24 0x00000555 0x00000AAA	;# AFRH

	# Port I: PI11:AF05:V, PI10:AF05:V, PI09:AF05:V, PI06:AF05:V
	mmw 0x48002000 0x00A82000 0x00541000	;# MODER
	mmw 0x48002008 0x00FC3000 0x00000000	;# OSPEEDR
	mmw 0x48002020 0x05000000 0x0A000000	;# AFRL
	mmw 0x48002024 0x00005550 0x0000AAA0	;# AFRH

	# OCTOSPI1: memory-mapped 1-line read mode with 4-byte addresses
	mww 0xA0001130 0x00001000				;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
	mww 0xA0001000 0x3040000B				;# OCTOSPI_CR: FMODE=0x1, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0
	mww 0xA0001008 0x01190100				;# OCTOSPI_DCR1: MTYP=0x1, FSIZE=0x19, CSHT=0x01, CKMODE=0, DLYBYP=0
	mww 0xA000100C 0x00000001				;# OCTOSPI_DCR2: PRESCALER=1

	mww 0xA0001108 0x00000000				;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x0
	mww 0xA0001100 0x01003101				;# OCTOSPI_CCR: DMODE=0x1, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x1, ISIZE=0x0, IMODE=0x1
	mww 0xA0001110 0x00000013				;# OCTOSPI_IR: INSTR=READ4B

	if { $octo == 1 } {
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05								;# Read Status Register
		stmqspi cmd $a 0 0x72 0x00 0x00 0x00 0x00 0x02		;# Write Conf. Reg. 2, addr 0x00000000: DTR OPI enable

		# OCTOSPI1: memory-mapped 8-line read mode with 4-byte addresses
		mww 0xA0001000 0x3040000B				;# OCTOSPI_CR: FMODE=0x3, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=1, EN=1
		mww 0xA0001108 0x10000006				;# OCTOSPI_TCR: SSHIFT=0, DHQC=1, DCYC=0x6
		mww 0xA0001100 0x2C003C1C				;# OCTOSPI_CCR: DTR, DMODE=0x4, ABMODE=0x0, ADSIZE=0x3, ADMODE=0x4, ISIZE=0x1, IMODE=0x4
		mww 0xA0001110 0x0000EE11				;# OCTOSPI_IR: INSTR=OCTA DTR Read

		flash probe $a							;# reload configuration from CR, TCR, CCR, IR register values

		stmqspi cmd $a 0 0x06								;# Write Enable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 0 0x04								;# Write Disable
		stmqspi cmd $a 1 0x05 0x00 0x00 0x00 0x00			;# Read Status Register (note dummy address in 8-line mode)
		stmqspi cmd $a 1 0x71 0x00 0x00 0x00 0x00			;# Read Conf. Reg. 2, addr 0x00000000: DOPI, SOPI bits
	}
}

$_TARGETNAME configure -event reset-init {
	mmw 0x40022000 0x00000003 0x0000000C	;# 3 WS for 72 MHz HCLK
	sleep 1
	mmw 0x40021000 0x00000100 0x00000000	;# HSI on
	mww 0x4002100C 0x01002432				;# RCC_PLLCFGR 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI
	mww 0x40021008 0x00008001				;# always HSI, APB1: /1, APB2: /1
	mmw 0x40021000 0x01000000 0x00000000	;# PLL on
	sleep 1
	mmw 0x40021008 0x00000003 0x00000000	;# switch to PLL
	sleep 1

	adapter speed 4000

	octospi_init 1
}
# This is an STM32L discovery board with a single STM32L152RBT6 chip.
# http://www.st.com/internet/evalboard/product/250990.jsp

source [find interface/stlink.cfg]

transport select hla_swd

set WORKAREASIZE 0x4000
source [find target/stm32l1.cfg]

reset_config srst_only
# board MB1272B
# http://www.st.com/en/evaluation-tools/stm32mp157a-dk1.html
# http://www.st.com/en/evaluation-tools/stm32mp157c-dk2.html

source [find interface/stlink-dap.cfg]

transport select dapdirect_swd

source [find target/stm32mp15x.cfg]

reset_config srst_only
# This is an STM32VL discovery board with a single STM32F100RB chip.
# http://www.st.com/internet/evalboard/product/250863.jsp

source [find interface/stlink.cfg]

transport select hla_swd

set WORKAREASIZE 0x2000
source [find target/stm32f1x.cfg]

reset_config srst_only
# str910-eval eval board
#
# Need reset scripts
reset_config trst_and_srst

# FIXME use some standard target config, maybe create one from this
#
#	source [find target/...cfg]

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME str912
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists FLASHTAPID] } {
   set _FLASHTAPID $FLASHTAPID
} else {
   set _FLASHTAPID 0x04570041
}
jtag newtap $_CHIPNAME flash -irlen 8 -ircapture 0x1 -irmask 0x1 -expected-id $_FLASHTAPID


if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x25966041
}
jtag newtap $_CHIPNAME cpu   -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

if { [info exists BSTAPID] } {
   set _BSTAPID $BSTAPID
} else {
   set _BSTAPID 0x1457f041
}
jtag newtap $_CHIPNAME bs    -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 1

$_TARGETNAME configure -event reset-init {
	# We can increase speed now that we know the target is halted.
	#jtag_rclk 3000

	# -- Enable 96K RAM
	# PFQBC enabled / DTCM & AHB wait-states disabled
	mww 0x5C002034 0x0191

	str9x flash_config 0 4 2 0 0x80000
	flash protect 0 0 7 off
}

#flash bank str9x <base> <size> 0 0 <target#> <variant>
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
source [find target/c100.cfg]
# basic register definition for C100
source [find target/c100regs.tcl]
# board-config info
source [find target/c100config.tcl]
# C100 helper functions
source [find target/c100helper.tcl]


# Telo board & C100 support trst and srst
# make the reset asserted to
# allow RC circuit to discharge for: [ms]
adapter srst pulse_width 100
jtag_ntrst_assert_width 100
# don't talk to JTAG after reset for: [ms]
adapter srst delay 100
jtag_ntrst_delay 100
reset_config trst_and_srst separate




# issue telnet: reset init
# issue gdb: monitor reset init
$_TARGETNAME configure -event reset-init {
	adapter speed 100
	# this will setup Telo board
	setupTelo
	#turn up the JTAG speed
	adapter speed 3000
	echo "JTAG speek now 3MHz"
	echo "type helpC100 to get help on C100"
}

$_TARGETNAME configure -event reset-deassert-post {
	# Force target into ARM state.
#	soft_reset_halt ;# not implemented on ARM11
	echo "Detected SRSRT asserted on C100.CPU"

}

$_TARGETNAME configure -event reset-assert-post {
  echo "Assering reset"
  #sleep 10
}

proc power_restore {} { echo "Sensed power restore. No action." }
proc srst_deasserted {} { echo "Sensed nSRST deasserted. No action." }


# boots from NOR on CS0:  8 MBytes CFI flash, 16-bit bus
# it's really 16MB but the upper 8mb is controller via gpio
# openocd does not support 'complex reads/writes' to NOR
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x20000000 0x01000000 2 2 $_TARGETNAME

# writing data to memory does not work without this
arm11 memwrite burst disable
#
# TI AM335x Evaluation Module
#
# For more information please see http://www.ti.com/tool/tmdxevm3358
#
jtag_rclk 6000

source [find target/am335x.cfg]

reset_config trst_and_srst
# Texas Instruments AM437x Industrial Development Kit

# The JTAG interface is built directly on the board.
source [find interface/ftdi/xds100v2.cfg]

transport select jtag
adapter speed 30000

source [find target/am437x.cfg]
$_TARGETNAME configure -event reset-init { init_platform 0x61a11b32 }

reset_config trst_and_srst
# Works on both AM437x GP EVM and AM438x ePOS EVM
transport select jtag
adapter speed 16000

source [find target/am437x.cfg]

reset_config trst_and_srst
# OMAP3 BeagleBoard
#  http://beagleboard.org

# Fall back to 6MHz if RTCK is not supported
jtag_rclk 6000

source [find target/omap3530.cfg]

# TI-14 JTAG connector
reset_config trst_only

# Later run:  omap3_dbginit
# BeagleBoard xM (DM37x)
#  http://beagleboard.org

set CHIPTYPE "dm37x"
source [find target/amdm37x.cfg]

# The TI-14 JTAG connector does not have srst.  CPU reset is handled in
# hardware.
reset_config trst_only

# "amdm37x_dbginit dm37x.cpu" needs to be run after init.
# AM335x Beaglebone family base configuration
#  http://beagleboard.org/bone

source [find target/am335x.cfg]
# AM335x Beaglebone
#  http://beagleboard.org/bone

# The JTAG interface is built directly on the board.
source [find interface/ftdi/xds100v2.cfg]

adapter speed 16000

reset_config trst_and_srst

source [find board/ti_beaglebone-base.cfg]
# AM335x Beaglebone Black
#  http://beagleboard.org/bone

adapter speed 1000

reset_config trst_and_srst

source [find board/ti_beaglebone-base.cfg]
jtag_rclk 6000

source [find target/omap4430.cfg]

reset_config trst_and_srst
#
# TI CC13x0 LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
transport select jtag
adapter speed 5500
source [find target/ti_cc13x0.cfg]
#
# TI CC13x2 LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 5500
transport select jtag
source [find target/ti_cc13x2.cfg]
#
# TI CC26x0 LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 5500
transport select jtag
source [find target/ti_cc26x0.cfg]
#
# TI CC26x2 LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 5500
transport select jtag
source [find target/ti_cc26x2.cfg]
#
# TI SimpleLink Wi-Fi CC3200 LaunchPad
#
# http://www.ti.com/tool/cc3200-launchxl
#

source [find interface/ftdi/ti-icdi.cfg]

if { [info exists TRANSPORT] } {
   transport select $TRANSPORT
} else {
   transport select jtag
}

adapter speed 2500

set WORKAREASIZE 0x40000
source [find target/ti_cc32xx.cfg]

reset_config srst_only
adapter srst delay 1100
#
# TI CC3220SF-LaunchXL LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 8500
transport select swd
source [find target/ti_cc3220sf.cfg]
#
# TI CC32xx-LaunchXL LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 8500
transport select swd
source [find target/ti_cc32xx.cfg]

reset_config srst_only
adapter srst delay 1100
#
# TI Tiva C DK-TM4C129X Connected Development Kit
#
# http://www.ti.com/tool/dk-tm4c129x
#

source [find interface/ti-icdi.cfg]

transport select hla_jtag

set WORKAREASIZE 0x8000
set CHIPNAME tm4c129xnczad

source [find target/stellaris.cfg]
#
# TI Tiva C Series ek-tm4c123gxl Launchpad Evaluation Kit
#
# http://www.ti.com/tool/ek-tm4c123gxl
#

source [find interface/ti-icdi.cfg]

transport select hla_jtag

set WORKAREASIZE 0x8000
set CHIPNAME tm4c123gh6pm
source [find target/stellaris.cfg]
#
# TI Tiva C Series ek-tm4c1294xl Launchpad Evaluation Kit
#
# http://www.ti.com/tool/ek-tm4c1294xl
#

source [find interface/ti-icdi.cfg]

transport select hla_jtag

set WORKAREASIZE 0x8000
set CHIPNAME tm4c1294ncpdt

source [find target/stellaris.cfg]
#
# TI MSP432 LaunchPad Evaluation Kit
#
source [find interface/xds110.cfg]
adapter speed 10000
transport select swd
source [find target/ti_msp432.cfg]
jtag_rclk 6000

source [find target/omap4430.cfg]

reset_config trst_only
jtag_rclk 6000

source [find target/omap4460.cfg]

reset_config trst_only
# TMS570 Microcontroller USB Kit
# http://www.ti.com/tool/TMDX570LS20SUSB

# Board uses a FT2232H to emulate an XDS100v2 JTAG debugger
# TODO: board also supports an SCI UART on the 2232's B Bus
source [find interface/ftdi/xds100v2.cfg]

# Processor is TMS570LS20216
source [find target/ti_tms570ls20xxx.cfg]

reset_config trst_only

# xds100v2 config says add this to the end
init
ftdi_set_signal PWR_RST 1
jtag arp_init
adapter speed 1500

source [find interface/ftdi/xds100v2.cfg]
source [find target/ti_tms570.cfg]

reset_config trst_only
#
# board configuration for Tocoding Poplar
#

# board does not feature anything but JTAG
transport select jtag

adapter speed 10000

# SRST-only reset configuration
reset_config srst_only srst_push_pull

source [find target/hi3798.cfg]

# make sure the default target is the boot core
targets ${_TARGETNAME}0

proc core_up { args } {
	global _TARGETNAME

	# examine remaining cores
	foreach _core [set args] {
		${_TARGETNAME}$_core arp_examine
	}
}
######################################
# Target:    Toshiba TOPAS910 -- TMPA910 Starterkit
#
######################################

# We add to the minimal configuration.
source [find target/tmpa910.cfg]

######################
# Target configuration
######################

#$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { topas910_init }

proc topas910_init { } {
# Init PLL
# my settings
	mww 0xf005000c 0x00000007
	mww 0xf0050010 0x00000065
	mww 0xf005000c 0x000000a7
	sleep 10
	mdw 0xf0050008
	mww 0xf0050008 0x00000002
	mww 0xf0050004 0x00000000
# NEW: set CLKCR5
	mww 0xf0050054 0x00000040
#
	sleep 10
# Init SDRAM
#  _PMCDRV          = 0x00000071;
#  //
#  // Initialize SDRAM timing parameter
#  //
#  _DMC_CAS_LATENCY = 0x00000006;
#  _DMC_T_DQSS      = 0x00000000;
#  _DMC_T_MRD       = 0x00000002;
#  _DMC_T_RAS       = 0x00000007;
#
#  _DMC_T_RC        = 0x0000000A;
#  _DMC_T_RCD       = 0x00000013;
#
#  _DMC_T_RFC       = 0x0000010A;
#
#  _DMC_T_RP        = 0x00000013;
#  _DMC_T_RRD       = 0x00000002;
#  _DMC_T_WR        = 0x00000002;
#  _DMC_T_WTR       = 0x00000001;
#  _DMC_T_XP        = 0x0000000A;
#  _DMC_T_XSR       = 0x0000000B;
#  _DMC_T_ESR       = 0x00000014;
#
#  //
#  // Configure SDRAM type parameter
#  _DMC_MEMORY_CFG  = 0x00008011;
#  _DMC_USER_CONFIG = 0x00000011;
#  // 32 bit memory interface
#
#
#  _DMC_REFRESH_PRD = 0x00000A60;
#  _DMC_CHIP_0_CFG  = 0x000140FC;
#
#  _DMC_DIRECT_CMD  = 0x000C0000;
#  _DMC_DIRECT_CMD  = 0x00000000;
#
#  _DMC_DIRECT_CMD  = 0x00040000;
#  _DMC_DIRECT_CMD  = 0x00040000;
#  _DMC_DIRECT_CMD  = 0x00080031;
#  //
#  // Finally start SDRAM
#  //
#  _DMC_MEMC_CMD    = MEMC_CMD_GO;
#  */

	mww 0xf0020260 0x00000071
	mww 0xf4300014 0x00000006
	mww 0xf4300018 0x00000000
	mww 0xf430001C 0x00000002
	mww 0xf4300020 0x00000007
	mww 0xf4300024 0x0000000A
	mww 0xf4300028 0x00000013
	mww 0xf430002C 0x0000010A
	mww 0xf4300030 0x00000013
	mww 0xf4300034 0x00000002
	mww 0xf4300038 0x00000002
	mww 0xf430003C 0x00000001
	mww 0xf4300040 0x0000000A
	mww 0xf4300044 0x0000000B
	mww 0xf4300048 0x00000014
	mww 0xf430000C 0x00008011
	mww 0xf4300304 0x00000011
	mww 0xf4300010 0x00000A60
	mww 0xf4300200 0x000140FC
	mww 0xf4300008 0x000C0000
	mww 0xf4300008 0x00000000
	mww 0xf4300008 0x00040000
	mww 0xf4300008 0x00040000
	mww 0xf4300008 0x00080031
	mww 0xf4300004 0x00000000

	sleep 10
#	adapter speed NNNN

# remap off in case of IROM boot
	mww 0xf0000004 0x00000001

}

# comment the following out if usinf J-Link, it soes not support DCC
arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads


#####################
# Flash configuration
#####################

#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x20000000 0x2000000 2 2 $_TARGETNAME
# Thanks to Pieter Conradie for this script!
# Target:    Toshiba TOPAS900 -- TMPA900 Starterkit
######################################

# We add to the minimal configuration.
source [find target/tmpa900.cfg]

######################
# Target configuration
######################

#$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { topasa900_init }

proc topasa900_init { } {
# Init PLL
# my settings
	mww 0xf005000c 0x00000007
	mww 0xf0050010 0x00000065
	mww 0xf005000c 0x000000a7
	sleep 10
	mdw 0xf0050008
	mww 0xf0050008 0x00000002
	mww 0xf0050004 0x00000000
# NEW: set CLKCR5
	mww 0xf0050054 0x00000040
#
# bplan settings
#	mww 0xf0050004 0x00000000
#	mww 0xf005000c 0x000000a7
#	sleep 10
#	mdw 0xf0050008
#	mww 0xf0050008 0x00000002
#	mww 0xf0050010 0x00000065
#	mww 0xf0050054 0x00000040
	sleep 10
# Init SDRAM
#  _PMCDRV          = 0x00000071;
#  //
#  // Initialize SDRAM timing parameter
#  //
#  _DMC_CAS_LATENCY = 0x00000006;
#  _DMC_T_DQSS      = 0x00000000;
#  _DMC_T_MRD       = 0x00000002;
#  _DMC_T_RAS       = 0x00000007;
#
#  _DMC_T_RC        = 0x0000000A;
#  _DMC_T_RCD       = 0x00000013;
#
#  _DMC_T_RFC       = 0x0000010A;
#
#  _DMC_T_RP        = 0x00000013;
#  _DMC_T_RRD       = 0x00000002;
#  _DMC_T_WR        = 0x00000002;
#  _DMC_T_WTR       = 0x00000001;
#  _DMC_T_XP        = 0x0000000A;
#  _DMC_T_XSR       = 0x0000000B;
#  _DMC_T_ESR       = 0x00000014;
#
#  //
#  // Configure SDRAM type parameter
#  _DMC_MEMORY_CFG  = 0x00008011;
#  _DMC_USER_CONFIG = 0x00000011;   // 32 bit memory interface
#
#
#  _DMC_REFRESH_PRD = 0x00000A60;
#  _DMC_CHIP_0_CFG  = 0x000140FC;
#
#  _DMC_DIRECT_CMD  = 0x000C0000;
#  _DMC_DIRECT_CMD  = 0x00000000;
#
#  _DMC_DIRECT_CMD  = 0x00040000;
#  _DMC_DIRECT_CMD  = 0x00040000;
#  _DMC_DIRECT_CMD  = 0x00080031;
#  //
#  // Finally start SDRAM
#  //
#  _DMC_MEMC_CMD    = MEMC_CMD_GO;
#  */

	mww 0xf0020260 0x00000071
	mww 0xf4300014 0x00000006
	mww 0xf4300018 0x00000000
	mww 0xf430001C 0x00000002
	mww 0xf4300020 0x00000007
	mww 0xf4300024 0x0000000A
	mww 0xf4300028 0x00000013
	mww 0xf430002C 0x0000010A
	mww 0xf4300030 0x00000013
	mww 0xf4300034 0x00000002
	mww 0xf4300038 0x00000002
	mww 0xf430003C 0x00000001
	mww 0xf4300040 0x0000000A
	mww 0xf4300044 0x0000000B
	mww 0xf4300048 0x00000014
	mww 0xf430000C 0x00008011
	mww 0xf4300304 0x00000011
	mww 0xf4300010 0x00000A60
	mww 0xf4300200 0x000140FC
	mww 0xf4300008 0x000C0000
	mww 0xf4300008 0x00000000
	mww 0xf4300008 0x00040000
	mww 0xf4300008 0x00040000
	mww 0xf4300008 0x00080031
	mww 0xf4300004 0x00000000

	sleep 10
#	adapter speed NNNN

# remap off in case of IROM boot
	mww 0xf0000004 0x00000001

}

# comment the following out if usinf J-Link, it soes not support DCC
arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads


#####################
# Flash configuration
#####################

#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x20000000 0x1000000 2 2 $_TARGETNAME
source [find target/atheros_ar9331.cfg]

$_TARGETNAME configure -event reset-init {
	ar9331_25mhz_pll_init
	sleep 1
	ar9331_ddr1_init
}

set ram_boot_address 0xa0000000
$_TARGETNAME configure -work-area-phys 0xa1FFE000 -work-area-size 0x1000

flash bank flash0 ath79 0xbf000000 0 0 0 $_TARGETNAME cs0
source [find target/atheros_ar9344.cfg]

reset_config trst_only separate

proc ar9344_40mhz_pll_init {} {
	# QCA_PLL_SRIF_CPU_DPLL2_REG
	mww 0xb81161C4 0x13210f00
	# QCA_PLL_SRIF_CPU_DPLL3_REG
	mww 0xb81161C8 0x03000000
	# QCA_PLL_SRIF_DDR_DPLL2_REG
	mww 0xb8116244 0x13210f00
	# QCA_PLL_SRIF_DDR_DPLL3_REG
	mww 0xb8116248 0x03000000
	# QCA_PLL_SRIF_BB_DPLL_BASE_REG
	mww 0xb8116188 0x03000000

	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
	mww 0xb8050008 0x0130001C
	mww 0xb8050008 0x0130001C
	mww 0xb8050008 0x0130001C

	# QCA_PLL_CPU_PLL_CFG_REG
	mww 0xb8050000 0x40021380
	# QCA_PLL_DDR_PLL_CFG_REG
	mww 0xb8050004 0x40815800
	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
	mww 0xb8050008 0x0130801C

	# QCA_PLL_SRIF_CPU_DPLL2_REG
	mww 0xb81161C4 0x10810F00
	mww 0xb81161C0 0x41C00000
	# QCA_PLL_SRIF_CPU_DPLL2_REG
	mww 0xb81161C4 0xD0810F00
	# QCA_PLL_SRIF_CPU_DPLL3_REG
	mww 0xb81161C8 0x03000000
	# QCA_PLL_SRIF_CPU_DPLL2_REG
	mww 0xb81161C4 0xD0800F00

	# QCA_PLL_SRIF_CPU_DPLL3_REG
	mww 0xb81161C8 0x03000000
	# QCA_PLL_SRIF_CPU_DPLL3_REG
	mww 0xb81161C8 0x43000000
	# QCA_PLL_SRIF_CPU_DPLL3_REG
	mww 0xb81161C8 0x030003E8

	# QCA_PLL_SRIF_DDR_DPLL2_REG
	mww 0xb8116244 0x10810F00
	mww 0xb8116240 0x41680000
	# QCA_PLL_SRIF_DDR_DPLL2_REG
	mww 0xb8116244 0xD0810F00
	# QCA_PLL_SRIF_DDR_DPLL3_REG
	mww 0xb8116248 0x03000000
	# QCA_PLL_SRIF_DDR_DPLL2_REG
	mww 0xb8116244 0xD0800F00

	# QCA_PLL_SRIF_DDR_DPLL3_REG
	mww 0xb8116248 0x03000000
	# QCA_PLL_SRIF_DDR_DPLL3_REG
	mww 0xb8116248 0x43000000
	# QCA_PLL_SRIF_DDR_DPLL3_REG
	mww 0xb8116248 0x03000718

	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
	mww 0xb8050008 0x01308018
	mww 0xb8050008 0x01308010
	mww 0xb8050008 0x01308000

	# QCA_PLL_DDR_PLL_DITHER_REG
	mww 0xb8050044 0x78180200
	# QCA_PLL_CPU_PLL_DITHER_REG
	mww 0xb8050048 0x41C00000

}

proc ar9344_ddr_init {} {
	# QCA_DDR_CTRL_CFG_REG
	mww 0xb8000108 0x40
	# QCA_DDR_RD_DATA_THIS_CYCLE_REG
	mww 0xb8000018 0xFF
	# QCA_DDR_BURST_REG
	mww 0xb80000C4 0x74444444
	# QCA_DDR_BURST2_REG
	mww 0xb80000C8 0x0222
	# QCA_AHB_MASTER_TOUT_MAX_REG
	mww 0xb80000CC 0xFFFFF

	# QCA_DDR_CFG_REG
	mww 0xb8000000 0xC7D48CD0
	# QCA_DDR_CFG2_REG
	mww 0xb8000004 0x9DD0E6A8

	# QCA_DDR_DDR2_CFG_REG
	mww 0xb80000B8 0x0E59
	# QCA_DDR_CFG2_REG
	mww 0xb8000004 0x9DD0E6A8

	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x08
	mww 0xb8000010 0x08
	mww 0xb8000010 0x10
	mww 0xb8000010 0x20
	# QCA_DDR_EMR_REG
	mww 0xb800000C 0x02
	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x02

	# QCA_DDR_MR_REG
	mww 0xb8000008 0x0133
	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x1
	mww 0xb8000010 0x8
	mww 0xb8000010 0x8
	mww 0xb8000010 0x4
	mww 0xb8000010 0x4

	# QCA_DDR_MR_REG
	mww 0xb8000008 0x33
	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x1

	# QCA_DDR_EMR_REG
	mww 0xb800000C 0x0382
	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x2
	# QCA_DDR_EMR_REG
	mww 0xb800000C 0x0402
	# QCA_DDR_CTRL_REG
	mww 0xb8000010 0x2

	# QCA_DDR_REFRESH_REG
	mww 0xb8000014 0x4270

	# QCA_DDR_TAP_CTRL_0_REG
	mww 0xb800001C 0x0e
	# QCA_DDR_TAP_CTRL_1_REG
	mww 0xb8000020 0x0e
	# QCA_DDR_TAP_CTRL_2_REG
	mww 0xb8000024 0x0e
	# QCA_DDR_TAP_CTRL_3_REG
	mww 0xb8000028 0x0e
}

$_TARGETNAME configure -event reset-init {

	# mww 0xb806001c 0x1000000
	ar9344_40mhz_pll_init
	sleep 100

	# flash remap
	# SPI_CONTROL_ADDR
	mww 0xbF000004 0x43

	ar9344_ddr_init
	sleep 100
}

set ram_boot_address 0xa0000000
$_TARGETNAME configure -work-area-phys 0x1d000000 -work-area-size 0x1000

flash bank flash0 ath79 0xbf000000 0 0 0 $_TARGETNAME cs0
#
# Freescale TWRK60F120M development board
#

source [find target/k60.cfg]

$_TARGETNAME configure -event reset-init {
	puts "-event reset-init occurred"
}

#
# Definitions for the additional 'program flash' banks
# (instructions and/or data)
#
flash bank pflash.1 kinetis 0x00040000 0x40000 0 4 $_TARGETNAME
flash bank pflash.2 kinetis 0x00080000 0x40000 0 4 $_TARGETNAME
flash bank pflash.3 kinetis 0x000c0000 0x40000 0 4 $_TARGETNAME
#
# Freescale TWRK60N512 development board
#

source [find target/k60.cfg]

$_TARGETNAME configure -event reset-init {
	puts "-event reset-init occurred"
}

#
# Definitions for the additional 'program flash' bank
# (instructions and/or data)
#
flash bank pflash.1 kinetis 0x00040000 0x40000 0 4 $_TARGETNAME
#
# Board configuration file for the Freescale VF65GS10 tower board
#
# Board has a 20 pin Cortex+ETM debug connector with only nSRST available
reset_config srst_only

# This configuration file only deals with the hardware JTAG.
# There is has also an embedded Kinetis K20 with OpenSDA
# where a CMSIS-DAP application can be installed.

# Source generic VF6xx target configuration
source [find target/vybrid_vf6xx.cfg]

# basic DDR memory init, setting up pad configuration
# for DDR first then configuring the DDRMC for the
# board
proc ddr_init { } {
	# iomux ddr
	mww phys 0x40048220 0x00000180
	mww phys 0x40048224 0x00000180
	mww phys 0x40048228 0x00000180
	mww phys 0x4004822c 0x00000180
	mww phys 0x40048230 0x00000180
	mww phys 0x40048234 0x00000180
	mww phys 0x40048238 0x00000180
	mww phys 0x4004823c 0x00000180
	mww phys 0x40048240 0x00000180
	mww phys 0x40048244 0x00000180
	mww phys 0x40048248 0x00000180
	mww phys 0x4004824c 0x00000180
	mww phys 0x40048250 0x00000180
	mww phys 0x40048254 0x00000180
	mww phys 0x40048258 0x00000180
	mww phys 0x4004825c 0x00000180
	mww phys 0x40048260 0x00000180
	mww phys 0x40048264 0x00000180
	mww phys 0x40048268 0x00000180
	mww phys 0x4004826c 0x00000180
	mww phys 0x40048270 0x00000180
	mww phys 0x40048274 0x00000180
	mww phys 0x40048278 0x00000180
	mww phys 0x4004827c 0x00010180
	mww phys 0x40048280 0x00010180
	mww phys 0x40048284 0x00010180
	mww phys 0x40048288 0x00010180
	mww phys 0x4004828c 0x00010180
	mww phys 0x40048290 0x00010180
	mww phys 0x40048294 0x00010180
	mww phys 0x40048298 0x00010180
	mww phys 0x4004829c 0x00010180
	mww phys 0x400482a0 0x00010180
	mww phys 0x400482a4 0x00010180
	mww phys 0x400482a8 0x00010180
	mww phys 0x400482ac 0x00010180
	mww phys 0x400482b0 0x00010180
	mww phys 0x400482b4 0x00010180
	mww phys 0x400482b8 0x00010180
	mww phys 0x400482bc 0x00010180
	mww phys 0x400482c0 0x00010180
	mww phys 0x400482c4 0x00010180
	mww phys 0x400482c8 0x00010180
	mww phys 0x400482cc 0x00000180
	mww phys 0x400482d0 0x00000180
	mww phys 0x400482d4 0x00000180
	mww phys 0x400482d8 0x00000180
	mww phys 0x4004821c 0x000001a0
	# ddr_ctrl_init
	mww phys 0x400ae000 0x00000600
	mww phys 0x400ae008 0x00000020
	mww phys 0x400ae028 0x00013880
	mww phys 0x400ae02c 0x00030d40
	mww phys 0x400ae030 0x0000050c
	mww phys 0x400ae034 0x15040400
	mww phys 0x400ae038 0x1406040f
	mww phys 0x400ae040 0x04040000
	mww phys 0x400ae044 0x006db00c
	mww phys 0x400ae048 0x00000403
	mww phys 0x400ae050 0x01000000
	mww phys 0x400ae054 0x00060001
	mww phys 0x400ae058 0x000c0000
	mww phys 0x400ae05c 0x03000200
	mww phys 0x400ae060 0x00000006
	mww phys 0x400ae064 0x00010000
	mww phys 0x400ae068 0x0c30002c
	mww phys 0x400ae070 0x00000000
	mww phys 0x400ae074 0x00000003
	mww phys 0x400ae078 0x0000000a
	mww phys 0x400ae07c 0x003001d4
	mww phys 0x400ae084 0x00010000
	mww phys 0x400ae088 0x00050500
	mww phys 0x400ae098 0x00000000
	mww phys 0x400ae09c 0x04001002
	mww phys 0x400ae0a4 0x00000001
	mww phys 0x400ae0c0 0x00460420
	mww phys 0x400ae108 0x01000200
	mww phys 0x400ae10c 0x00000040
	mww phys 0x400ae114 0x00000200
	mww phys 0x400ae118 0x00000040
	mww phys 0x400ae120 0x00000000
	mww phys 0x400ae124 0x0a010300
	mww phys 0x400ae128 0x01014040
	mww phys 0x400ae12c 0x01010101
	mww phys 0x400ae130 0x03030100
	mww phys 0x400ae134 0x01000101
	mww phys 0x400ae138 0x0700000c
	mww phys 0x400ae13c 0x00000000
	mww phys 0x400ae148 0x10000000
	mww phys 0x400ae15c 0x01000000
	mww phys 0x400ae160 0x00040000
	mww phys 0x400ae164 0x00000002
	mww phys 0x400ae16c 0x00020000
	mww phys 0x400ae180 0x00002819
	mww phys 0x400ae184 0x01000000
	mww phys 0x400ae188 0x00000000
	mww phys 0x400ae18c 0x00000000
	mww phys 0x400ae198 0x00000000
	mww phys 0x400ae1a4 0x00000c00
	mww phys 0x400ae1a8 0x00000000
	mww phys 0x400ae1b8 0x0000000c
	mww phys 0x400ae1c8 0x00000000
	mww phys 0x400ae1cc 0x00000000
	mww phys 0x400ae1d4 0x00000000
	mww phys 0x400ae1d8 0x01010000
	mww phys 0x400ae1e0 0x02020000
	mww phys 0x400ae1e4 0x00000202
	mww phys 0x400ae1e8 0x01010064
	mww phys 0x400ae1ec 0x00010101
	mww phys 0x400ae1f0 0x00000064
	mww phys 0x400ae1f8 0x00000800
	mww phys 0x400ae210 0x00000506
	mww phys 0x400ae224 0x00020000
	mww phys 0x400ae228 0x01000000
	mww phys 0x400ae22c 0x04070303
	mww phys 0x400ae230 0x00000040
	mww phys 0x400ae23c 0x06000080
	mww phys 0x400ae240 0x04070303
	mww phys 0x400ae244 0x00000040
	mww phys 0x400ae248 0x00000040
	mww phys 0x400ae24c 0x000f0000
	mww phys 0x400ae250 0x000f0000
	mww phys 0x400ae25c 0x00000101
	mww phys 0x400ae268 0x682c4000
	mww phys 0x400ae26c 0x00000012
	mww phys 0x400ae278 0x00000006
	mww phys 0x400ae284 0x00010202
	mww phys 0x400ae400 0x00002613
	mww phys 0x400ae440 0x00002613
	mww phys 0x400ae404 0x00002615
	mww phys 0x400ae444 0x00002615
	mww phys 0x400ae408 0x00210000
	mww phys 0x400ae448 0x00210000
	mww phys 0x400ae488 0x00210000
	mww phys 0x400ae40c 0x0001012a
	mww phys 0x400ae44c 0x0001012a
	mww phys 0x400ae48c 0x0001012a
	mww phys 0x400ae410 0x00002400
	mww phys 0x400ae450 0x00002400
	mww phys 0x400ae490 0x00002400
	mww phys 0x400ae4c4 0x00000000
	mww phys 0x400ae4c8 0x00001100
	mww phys 0x400ae4d0 0x00010101
	mww phys 0x400ae000 0x00000601
}

# clock control init, setting up basic
# clocks
proc clock_init { } {
	# captured from u-boot
	mww phys 0x4006b040 0xffffffff
	mww phys 0x4006b044 0xffffffff
	mww phys 0x4006b048 0xffffffff
	mww phys 0x4006b04c 0xffffffff
	mww phys 0x4006b050 0xffffffff
	mww phys 0x4006b058 0xffffffff
	mww phys 0x4006b05c 0xffffffff
	mww phys 0x4006b060 0xffffffff
	mww phys 0x4006b064 0xffffffff
	mww phys 0x4006b068 0xffffffff
	mww phys 0x40050030 0x00002001
	mww phys 0x40050270 0x80002001
	mww phys 0x4006b000 0x00011005
	mww phys 0x4006b008 0x0001ff24
	mww phys 0x4006b00c 0x00000810
	mww phys 0x4006b010 0x00cc0000
	mww phys 0x4006b014 0x01000000
	mww phys 0x4006b018 0x20000000
	mww phys 0x4006b01c 0x0000001f
	mww phys 0x4006b020 0x00000000
}

# This function applies the initial configuration after a "reset init"
# command
proc board_init { } {
	clock_init
	ddr_init
}

# hook the init function into the reset-init event
${_TARGETNAME}0 configure -event reset-init { board_init }
# set a slow default JTAG clock, can be overridden later
adapter speed 1000
#
# Board configuration file for the Freescale VF65GS10 tower board
#
# CMSIS-DAP via USB-OTG connector
#
source [find interface/cmsis-dap.cfg]

# only SWD is supported by the CMSIS-DAP on this board
transport select swd

# Source generic part of twr-vf65gs10 configuration
source [find board/twr-vf65gs10.cfg]

# override reset configuration
reset_config srst_only
# -------------------------------------------------------------------------
# KaRo TX25 CPU Module on a StarterkitV base board
# http://www.karo-electronics.com/tx25.html
# -------------------------------------------------------------------------


source [find target/imx25.cfg]

	#-------------------------------------------------------------------------
	# Declare Nand
	#-------------------------------------------------------------------------

	nand device K9F1G08UOC mxc imx25.cpu mx25 hwecc biswap


$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { tx25_init }


proc tx25_init { } {

	#-------------------------------------------------------------------------
	# AIPS setup - Only setup MPROTx registers. The PACR default values are good.
	# Set all MPROTx to be non-bufferable, trusted for R/W,
	# not forced to user-mode.
	#-------------------------------------------------------------------------

	mww 0x43f00000 0x77777777
	mww 0x43f00004 0x77777777
	mww 0x53f00000 0x77777777
	mww 0x53f00004 0x77777777

	sleep 100

	#-------------------------------------------------------------------------
	# MAX (Multi-Layer AHB Crossbar Switch) setup
	# MPR - priority for MX25 is (SDHC2/SDMA)>USBOTG>RTIC>IAHB>DAHB
	#-------------------------------------------------------------------------

	mww 0x43f04000 0x00043210
	mww 0x43f04100 0x00043210
	mww 0x43f04200 0x00043210
	mww 0x43f04300 0x00043210
	mww 0x43f04400 0x00043210

	# SGPCR - always park on last master
	mww 0x43f04010 0x10
	mww 0x43f04110 0x10
	mww 0x43f04210 0x10
	mww 0x43f04310 0x10
	mww 0x43f04410 0x10

	# MGPCR - restore default values
	mww 0x43f04800 0x0
	mww 0x43f04900 0x0
	mww 0x43f04a00 0x0
	mww 0x43f04b00 0x0
	mww 0x43f04c00 0x0

	# Configure M3IF registers
	# M3IF Control Register (M3IFCTL) for MX25
	# MRRP[0] = LCDC           on priority list (1 << 0)  = 0x00000001
	# MRRP[1] = MAX1       not on priority list (0 << 1)  = 0x00000000
	# MRRP[2] = MAX0       not on priority list (0 << 2)  = 0x00000000
	# MRRP[3] = USB HOST   not on priority list (0 << 3)  = 0x00000000
	# MRRP[4] = SDMA       not on priority list (0 << 4)  = 0x00000000
	# MRRP[5] = SD/ATA/FEC not on priority list (0 << 5)  = 0x00000000
	# MRRP[6] = SCMFBC     not on priority list (0 << 6)  = 0x00000000
	# MRRP[7] = CSI        not on priority list (0 << 7)  = 0x00000000
	#                                                       ----------
	#                                                       0x00000001
	mww 0xb8003000 0x00000001

	#-------------------------------------------------------------------------
	# configure ARM CLK
	#-------------------------------------------------------------------------

	# Set the Clock CTL (HRM p. 355)
	mww 0x53F80008 0x20034000

	# Setup Clock Gating CTL 0-2 (HRM p. 357)
	mww 0x53F8000C 0x1fffffff
	mww 0x53F80010 0xffffffff
	mww 0x53F80014 0x000fdfff

	#-------------------------------------------------------------------------
	# SDRAM initialization
	#-------------------------------------------------------------------------

	# set to 3.3v SDRAM
	mww 0x43FAC454 0x00000800

	# reset (set up ESDMISC)
	mww 0xB8001010 0x00000002

	# Setup for SDRAM Bank 0
	#-------------------------------------------------------------------------

	# Write ESDCFG0
	mww 0xB8001004 0x00095728

	# CTL SMode = Precharge command
	mww 0xB8001000 0x92116480
	mww 0x80000400 0x00000000

	# CTL SMode = Auto Refresh command
	mww 0xB8001000 0xA2116480
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0
	mww 0x80000000 0x0

	# CTL SMode = Load Mode Register command
	mww 0xB8001000 0xB2116480
	mwb 0x80000033 0x00

	# CTL SMode = normal
	mww 0xB8001000 0x82116480

	# Setup for SDRAM Bank 1
	#-------------------------------------------------------------------------

	# Write ESDCFG1
	mww 0xB800100C 0x00095728

	# CTL SMode = Precharge command
	mww 0xB8001008 0x92116480
	mww 0x90000400 0x00000000

	# CTL SMode = Auto Refresh command
	mww 0xB8001008 0xA2116480
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000
	mww 0x90000000 0x00000000

	# CTL SMode = Load Mode Register command
	mww 0xB8001008 0xB2116480
	mwb 0x90000033 0x00

	# CTL SMode = normal
	mww 0xB8001008 0x82116480

	# GPIO configuration
	#-------------------------------------------------------------------------

	mww 0x43FAC02C 0x00000015
	mww 0x53FD0000 0x01000000
	mww 0x53FD0004 0x00000080
}
# KaRo TX27 CPU Module on a StarterkitV base board
#
# http://www.karo-electronics.com/tx27.html
#
source [find target/imx27.cfg]

$_TARGETNAME configure -event gdb-attach { reset init }
$_TARGETNAME configure -event reset-init { tx27_init }

proc tx27_init { } {
	# This setup puts RAM at 0xA0000000
	# init_aipi (AIPI1.PSR0, AIPI2.PSR0, AIPI1.PSR1 and AIPI2.PSR1)
	mww 0x10000000 0x20040304
	mww 0x10020000 0x00000000
	mww 0x10000004 0xDFFBFCFB
	mww 0x10020004 0xFFFFFFFF

	sleep 100

	#init_max ( PORT0.MPR, #PORT0.AMPR, #PORT1.MPR, #PORT1.AMPR, #PORT2.MPR, #PORT2.AMPR)
	mww 0x1003F000 0x00302145
	mww 0x1003F004 0x00302145
	mww 0x1003F100 0x00302145
	mww 0x1003F104 0x00302145
	mww 0x1003F200 0x00302145
	mww 0x1003F204 0x00302145

	#init_drive_strength (#DSCR3, #DSCR5, #DSCR6, #DSCR7, #DSCR8 )
	mww 0x10027828 0x55555555
	mww 0x10027830 0x55555555
	mww 0x10027834 0x55555555
	mww 0x10027838 0x00005005
	mww 0x1002783C 0x15555555

	#init_sdram_speed
	#mww 0xD8001010 0x00000004
	mww 0xD8001010 0x00000024

	mww 0xD8001004 0x00395729

	mww 0xD8001000 0x92120000
	mww 0xA0000400 0x0

	mww 0xD8001000 0xA2120000
	mww 0xA0000000 0x0
	mww 0xA0000000 0x0

	mww 0xD8001000 0xB2120000
	mdb 0xA0000000
	mdb 0xA0000033

	mww 0xD8001000 0x82126485

	# =============================================
	# Sync mode (AHB Clk = 133MHz ; BCLK = 44.3MHz)
	# =============================================
	mww 0xD8002000 0x23524E80
	mww 0xD8002004 0x10000D03
	mww 0xD8002008 0x00720900

	nand probe 0
}

nand device tx27.nand mxc $_TARGETNAME mx27 hwecc biswap
# Thanks to Pieter Conradie for this script!
#
# Unknown vendor board contains:
#
# Atmel AT91SAM9260 : PLLA = 192.512MHz, MCK = 96.256 MHz
#                     OSCSEL configured for internal RC oscillator (22 to 42 kHz)
#
# 16-bit NOR FLASH : Intel JS28F128P30T85 128MBit
# 32-bit SDRAM : 2 x Samsung K4S561632H-UC75, 4M x 16Bit x 4 Banks
##################################################################

# We add to the minimal configuration.
source [find target/at91sam9260.cfg]

$_TARGETNAME configure -event reset-start {
        # At reset CPU runs at 22 to 42 kHz.
        # JTAG Frequency must be 6 times slower.
        jtag_rclk 3
        halt
	# RSTC_MR : enable user reset, MMU may be enabled... use physical address
        mww phys 0xfffffd08 0xa5000501
}


$_TARGETNAME configure -event reset-init {
        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog

	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc28 0x205dbf09         ;# CKGR_PLLAR: Set PLLA Register for 192.512MHz
        sleep 20                          ;# wait 20 ms
        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
        sleep 10                          ;# wait 10 ms
        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
        sleep 10                          ;# wait 10 ms

	# Increase JTAG Speed to 6 MHz if RCLK is not supported
        jtag_rclk 6000

	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads

	mww 0xffffec00 0x01020102         ;# SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
	mww 0xffffec04 0x09070806         ;# SMC_PULSE0
	mww 0xffffec08 0x000d000b         ;# SMC_CYCLE0
	mww 0xffffec0c 0x00001003         ;# SMC_MODE0

	flash probe 0                     ;# Identify flash bank 0

	mww 0xfffff870 0xffff0000         ;# PIO_ASR  : Select peripheral function for D15..D31
        mww 0xfffff804 0xffff0000         ;# PIO_PDR  : Disable PIO function for D15..D31
        mww 0xfffff860 0xffff0000         ;# PIO_PUDR : Disable D15..D31 pull-ups

        mww 0xffffef1c 0x00010102         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
                                           #            VDDIOMSEL set for +3V3 memory
                                           #            Disable D0..D15 pull-ups

	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)

	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
	mww 0x20000000 0
	mww 0xffffea04 0x2a2              ;# SDRAMC_TR : Set refresh timer count to 7us
}


#####################
# Flash configuration
#####################

#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME
# Target Configuration for the Uptech 2410 board.
# This configuration hould also work on smdk2410, but I havn't tested it yet.
# Author: xionglingfeng@Gmail.com

source [find target/samsung_s3c2410.cfg]

$_TARGETNAME configure -event reset-init { uptech2410_init }
$_TARGETNAME configure -event gdb-attach { reset init }

proc init_pll_sdram { } {
	#echo "---------- Initializing PLL and SDRAM ---------"
	#watchdog timer disable
	mww phys 0x53000000 0x00000000

	#disable all interrupts
	mww phys 0x4a000008 0xffffffff

	#disable all sub-interrupts
	mww phys 0x4a00001c 0x000007ff

	#clear all source pending bits
	mww phys 0x4a000000 0xffffffff

	#clear all sub-source pending bits
	mww phys 0x4a000018 0x000007ff

	#clear interrupt pending bit
	mww phys 0x4a000010 0xffffffff

	#PLL locktime counter
	mww phys 0x4c000000 0x00ffffff

	#Fin=12MHz Fout=202.8MHz
	#mww phys 0x4c000004 0x000a1031

	#FCLK:HCLK:PCLK = 1:2:4
	mww phys 0x4c000014 0x00000003


	mww phys 0x48000000 0x11111110
	mww phys 0x48000004 0x00007FFC
	mww phys 0x48000008 0x00007FFC
	mww phys 0x4800000c 0x00000700
	mww phys 0x48000010 0x00000700
	mww phys 0x48000014 0x00002E50
	mww phys 0x48000018 0x00002E50
	mww phys 0x4800001c 0x00018005
	mww phys 0x48000020 0x00018005
	mww phys 0x48000024 0x008c04e9
	mww phys 0x48000028 0x000000b2
	mww phys 0x4800002c 0x00000030
	mww phys 0x48000030 0x00000030
}

proc uptech2410_init { } {
	init_pll_sdram
	#echo "---------- Probing Nand flash ----------"
	nand probe 0
	#echo "---------- Enable some functions ----------"
}

set _NANDNAME $_CHIPNAME.nand
nand device $_NANDNAME s3c2410 $_TARGETNAME
# Config for Gumstix Verdex XM4 and XL6P (PXA270)

set CHIPNAME verdex
source [find target/pxa270.cfg]

# The board supports separate reset lines
# Override this in the interface config for parallel dongles
reset_config trst_and_srst separate

# XM4 = 400MHz, XL6P = 600MHz...let's run at 0.1*400MHz=40MHz
adapter speed 40000

# flash bank <driver> <base> <size> <chip_width> <bus_width>
# XL6P has 32 MB flash
flash bank $_CHIPNAME.flash0 cfi 0x00000000 0x02000000 2 2 $_TARGETNAME
# XM4 has 16 MB flash
#flash bank $_CHIPNAME.flash0 cfi 0x00000000 0x01000000 2 2 $_TARGETNAME
# Config for Voipac PXA270/PXA270M module.

set CHIPNAME voipac
source [find target/pxa270.cfg]

# The board supports separate reset lines
# Override this in the interface config for parallel dongles
reset_config trst_and_srst separate

# flash bank <driver> <base> <size> <chip_width> <bus_width>
flash bank $_CHIPNAME.flash0 cfi 0x00000000 0x2000000 2 2 $_TARGETNAME
flash bank $_CHIPNAME.flash1 cfi 0x02000000 0x2000000 2 2 $_TARGETNAME
#
# Voltcraft DSO-3062C digital oscilloscope (uses a Samsung S3C2440)
#
# http://www.eevblog.com/forum/general-chat/hantek-tekway-dso-hack-get-200mhz-bw-for-free/
# http://www.mikrocontroller.net/topic/249628
# http://elinux.org/Das_Oszi
# http://randomprojects.org/wiki/Voltcraft_DSO-3062C
#

# Enable this if your JTAG adapter supports multiple transports (JTAG or SWD).
# Otherwise comment it out, as it will cause an OpenOCD error.
### transport select jtag

source [find target/samsung_s3c2440.cfg]

adapter speed 16000

# Samsung K9F1208U0C NAND flash chip (64MiB, 3.3V, 8-bit)
nand device $_CHIPNAME.nand s3c2440 $_TARGETNAME

# arm7_9 fast_memory_access enable
# arm7_9 dcc_downloads enable

init
reset
halt
scan_chain
targets
nand probe 0
nand list
# This is for the T-Home X300T / X301T IPTV box,
# which are based on IPTV reference designs from Kiss/Cisco KMM-3***
#
# It has Sigma Designs SMP8634 chip.
source [find target/smp8634.cfg]

$_TARGETNAME configure -event reset-init { x300t_init }

# 1MB CFI capable flash
# flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0xac000000 0x100000 2 2 $_TARGETNAME

proc x300t_init { } {
	# Setup SDRAM config and flash mapping
	# initialize ram
	mww 0xa003fffc 3
	mww 0xa003fffc 2
	mww 0xa0030000 0xE34111BA
	mww 0xa003fffc 0xa4444
	mww 0xa003fffc 0

	# remap boot vector in CPU local RAM
	mww 0xa006f000 0x60000

	# map flash to CPU address space REG_BASE_cpu_block+CPU_remap4
	mww 0x0006f010 0x48000000

	# map flash addr to REG_BASE_cpu_block + LR_XENV_LOCATION (normally done by XOS)
	mww 0x00061ff0 0x48000000
}
#
# Infineon XMC 2Go
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

set CHIPNAME xmc1100
set WORKAREASIZE 0x4000
source [find target/xmc1xxx.cfg]

reset_config srst_only srst_nogate
#
# Infineon XMC1100 Boot Kit
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

set CHIPNAME xmc1100
set WORKAREASIZE 0x4000
source [find target/xmc1xxx.cfg]

reset_config srst_only srst_nogate
#
# Infineon XMC4200 Application Kit - Actuator
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

set CHIPNAME xmc4200
source [find target/xmc4xxx.cfg]
#
# Infineon XMC4300 Relax EtherCAT Kit
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

set CHIPNAME xmc4300
source [find target/xmc4xxx.cfg]
#
# Infineon XMC4500 Application Kit - General Purpose
#

set CHIPNAME xmc4500
source [find target/xmc4xxx.cfg]

reset_config srst_only
#
# Infineon XMC4500 Application Kit - SDRAM
#

#
# Segger J-Link Lite XMC4200 on-board
#

set CHIPNAME xmc4500
source [find target/xmc4xxx.cfg]
#
# Infineon XMC4500 Relax Kit / Relax Lite Kit
#

#
# Segger J-Link Lite XMC4500 on-board
#
source [find interface/jlink.cfg]
transport select swd

# There's also an unpopulated 10-pin 0.05" pinout.

set CHIPNAME xmc4500
source [find target/xmc4xxx.cfg]
#
# Infineon XMC4700 Relax Lite Kit / Relax Kit for 5V Shields / Relax Kit
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

# There's also an unpopulated 10-pin 0.05" pinout.

set CHIPNAME xmc4700
source [find target/xmc4xxx.cfg]

# Relax Kit only: N25Q032A qSPI flash
#
# Infineon XMC4800 Relax EtherCAT Kit
#

#
# Segger J-Link Lite XMC4200 on-board
#
source [find interface/jlink.cfg]
transport select swd

# There's also an unpopulated 10-pin 0.05" pinout.

set CHIPNAME xmc4800
source [find target/xmc4xxx.cfg]

# N25Q032A qSPI flash
#
# xCORE-XA Core Module
#
# https://www.xmos.com/support/boards?product=17940
#

#
# J-Link OB STM32F103
#
source [find interface/jlink.cfg]
transport select swd

#
# XS1-XAU8A-10
#
source [find target/xmos_xs1-xau8a-10_arm.cfg]
#Script for ZY1000

#Atmel ties SRST & TRST together, at which point it makes
#no sense to use TRST, but use TMS instead.
#
#The annoying thing with tying SRST & TRST together is that
#there is no way to halt the CPU *before and during* the
#SRST reset, which means that the CPU will run a number
#of cycles before it can be halted(as much as milliseconds).
reset_config srst_only srst_pulls_trst


if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME zy1000
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}


#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1f0f0f0f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

# at CPU CLK <32kHz this must be disabled
arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x01000000 0x200000 2 2 $_TARGETNAME

$_TARGETNAME configure -event reset-init {
	# Set up chip selects & timings
	mww 0xFFE00000 0x0100273D
	mww 0xFFE00004 0x08002125
	mww 0xFFEe0008 0x02002125
	mww 0xFFE0000c 0x03002125
	mww 0xFFE00010 0x40000000
	mww 0xFFE00014 0x50000000
	mww 0xFFE00018 0x60000000
	mww 0xFFE0001c 0x70000000
	mww 0xFFE00020 0x00000001
	mww 0xFFE00024 0x00000000

	# remap
	mww 0xFFFFF124 0xFFFFFFFF
	mww 0xffff0010 0x100
	mww 0xffff0034 0x100

	#disable 16x5x UART interrupts
	mww 0x08020004 0
}

$_TARGETNAME configure -event gdb-attach {
	# Without this gdb-attach will first time as probe will fail
	reset init
}

# required for usable performance. Used for lots of
# other things than flash programming.
$_TARGETNAME configure -work-area-phys 0x00020000 -work-area-size 0x20000 -work-area-backup 0

adapter speed 16000


proc production_info {} {
	return "Serial number is official MAC number. Format XXXXXXXXXXXX"
}

# There is no return value from this procedure. If it is
# successful it does not throw an exception
#
# Progress messages are output via puts
proc production {firmwarefile serialnumber} {
	if {[string length $serialnumber]!=12} {
		echo "Invalid serial number"
		return
	}

	echo "Power cycling target"
	power off
	sleep 3000
	power on
	sleep 1000
	reset init
	flash write_image erase $firmwarefile 0x1000000 bin
	verify_image $firmwarefile 0x1000000 bin

	# Big endian... weee!!!!
	echo "Setting MAC number to $serialnumber"
	flash fillw [expr 0x1030000-0x8] "0x[string range $serialnumber 2 3][string range $serialnumber 0 1]0000" 1
	flash fillw [expr 0x1030000-0x4] "0x[string range $serialnumber 10 11][string range $serialnumber 8 9][string range $serialnumber 6 7][string range $serialnumber 4 5]" 1
	echo "Production successful"
}


proc production_test {} {
	power on
	sleep 1000
	target_request debugmsgs enable
	reset run
	sleep 25000
	target_request debugmsgs disable
	return "See IP address above..."
}
set AIC_SMR      	[expr $AT91C_BASE_AIC + 0x00000000 ]
global AIC_SMR
set AIC_SVR      	[expr $AT91C_BASE_AIC + 0x00000080 ]
global AIC_SVR
set AIC_IVR      	[expr $AT91C_BASE_AIC + 0x00000100 ]
global AIC_IVR
set AIC_FVR      	[expr $AT91C_BASE_AIC + 0x00000104 ]
global AIC_FVR
set AIC_ISR      	[expr $AT91C_BASE_AIC + 0x00000108 ]
global AIC_ISR
set AIC_IPR      	[expr $AT91C_BASE_AIC + 0x0000010C ]
global AIC_IPR
set AIC_IMR      	[expr $AT91C_BASE_AIC + 0x00000110 ]
global AIC_IMR
set AIC_CISR     	[expr $AT91C_BASE_AIC + 0x00000114 ]
global AIC_CISR
set AIC_IECR     	[expr $AT91C_BASE_AIC + 0x00000120 ]
global AIC_IECR
set AIC_IDCR     	[expr $AT91C_BASE_AIC + 0x00000124 ]
global AIC_IDCR
set AIC_ICCR     	[expr $AT91C_BASE_AIC + 0x00000128 ]
global AIC_ICCR
set AIC_ISCR     	[expr $AT91C_BASE_AIC + 0x0000012C ]
global AIC_ISCR
set AIC_EOICR    	[expr $AT91C_BASE_AIC + 0x00000130 ]
global AIC_EOICR
set AIC_SPU      	[expr $AT91C_BASE_AIC + 0x00000134 ]
global AIC_SPU
set AIC_DCR      	[expr $AT91C_BASE_AIC + 0x00000138 ]
global AIC_DCR
set AIC_FFER     	[expr $AT91C_BASE_AIC + 0x00000140 ]
global AIC_FFER
set AIC_FFDR     	[expr $AT91C_BASE_AIC + 0x00000144 ]
global AIC_FFDR
set AIC_FFSR     	[expr $AT91C_BASE_AIC + 0x00000148 ]
global AIC_FFSR


proc aic_enable_disable_list { VAL ENAME DNAME } {
    global AT91C_ID

    show_mmr32_bits AT91C_ID $VAL

}

proc show_AIC_IPR_helper { NAME ADDR VAL } {
    aic_enable_disable_list  $VAL "IRQ PENDING" "irq not-pending"
}

proc show_AIC_IMR_helper { NAME ADDR VAL } {
    aic_enable_disable_list  $VAL "IRQ ENABLED" "irq disabled"
}


proc show_AIC { } {
    global AIC_SMR
    if [catch { mem2array aaa 32 $AIC_SMR [expr 32 * 4] } msg ] {
	error [format "%s (%s)" $msg AIC_SMR]
    }
    echo "AIC_SMR: Mode & Type"
    global AT91C_ID
    for { set x 0 } { $x < 32 } {  } {
	echo -n "   "
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo  [format "%2d: %5s 0x%08x"  $x $AT91C_ID($x) $aaa($x)]
	incr x
    }
    global AIC_SVR
    if [catch { mem2array aaa 32 $AIC_SVR [expr 32 * 4] } msg ] {
	error [format "%s (%s)" $msg AIC_SVR]
    }
    echo "AIC_SVR: Vectors"
    for { set x 0 } { $x < 32 } {  } {
	echo -n "   "
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo -n [format "%2d: %5s 0x%08x | " $x $AT91C_ID($x) $aaa($x)]
	incr x
	echo [format "%2d: %5s 0x%08x" $x $AT91C_ID($x) $aaa($x)]
	incr x
    }

    foreach REG {
	AIC_IVR   AIC_FVR  AIC_ISR
	AIC_IPR  AIC_IMR  AIC_CISR  AIC_IECR AIC_IDCR
	AIC_ICCR AIC_ISCR AIC_EOICR AIC_SPU  AIC_DCR
	AIC_FFER AIC_FFDR AIC_FFSR } {
	if [catch { show_mmr32_reg $REG } msg ] {
	    error $msg
	    break
	}
    }
}
set PIO_PER	0x00	;# Enable Register
set PIO_PDR	0x04	;# Disable Register
set PIO_PSR	0x08	;# Status Register
set PIO_OER	0x10	;# Output Enable Register
set PIO_ODR	0x14	;# Output Disable Register
set PIO_OSR	0x18	;# Output Status Register
set PIO_IFER	0x20	;# Glitch Input Filter Enable
set PIO_IFDR	0x24	;# Glitch Input Filter Disable
set PIO_IFSR	0x28	;# Glitch Input Filter Status
set PIO_SODR	0x30	;# Set Output Data Register
set PIO_CODR	0x34	;# Clear Output Data Register
set PIO_ODSR	0x38	;# Output Data Status Register
set PIO_PDSR	0x3c	;# Pin Data Status Register
set PIO_IER	0x40	;# Interrupt Enable Register
set PIO_IDR	0x44	;# Interrupt Disable Register
set PIO_IMR	0x48	;# Interrupt Mask Register
set PIO_ISR	0x4c	;# Interrupt Status Register
set PIO_MDER	0x50	;# Multi-driver Enable Register
set PIO_MDDR	0x54	;# Multi-driver Disable Register
set PIO_MDSR	0x58	;# Multi-driver Status Register
set PIO_PUDR	0x60	;# Pull-up Disable Register
set PIO_PUER	0x64	;# Pull-up Enable Register
set PIO_PUSR	0x68	;# Pull-up Status Register
set PIO_ASR	0x70	;# Peripheral A Select Register
set PIO_BSR	0x74	;# Peripheral B Select Register
set PIO_ABSR	0x78	;# AB Status Register
set PIO_OWER	0xa0	;# Output Write Enable Register
set PIO_OWDR	0xa4	;# Output Write Disable Register
set PIO_OWSR	0xa8	;# Output Write Status Register
set	AT91_PMC_SCER		[expr ($AT91_PMC + 0x00)]	;# System Clock Enable Register
set	AT91_PMC_SCDR		[expr ($AT91_PMC + 0x04)]	;# System Clock Disable Register

set	AT91_PMC_SCSR		[expr ($AT91_PMC + 0x08)]	;# System Clock Status Register
set		AT91_PMC_PCK		[expr (1 <<  0)]		;# Processor Clock
set		AT91RM9200_PMC_UDP	[expr (1 <<  1)]		;# USB Devcice Port Clock [AT91RM9200 only]
set		AT91RM9200_PMC_MCKUDP	[expr (1 <<  2)]		;# USB Device Port Master Clock Automatic Disable on Suspend [AT91RM9200 only]
set		AT91CAP9_PMC_DDR	[expr (1 <<  2)]		;# DDR Clock [CAP9 revC & some SAM9 only]
set		AT91RM9200_PMC_UHP	[expr (1 <<  4)]		;# USB Host Port Clock [AT91RM9200 only]
set		AT91SAM926x_PMC_UHP	[expr (1 <<  6)]		;# USB Host Port Clock [AT91SAM926x only]
set		AT91CAP9_PMC_UHP	[expr (1 <<  6)]		;# USB Host Port Clock [AT91CAP9 only]
set		AT91SAM926x_PMC_UDP	[expr (1 <<  7)]		;# USB Devcice Port Clock [AT91SAM926x only]
set		AT91_PMC_PCK0		[expr (1 <<  8)]		;# Programmable Clock 0
set		AT91_PMC_PCK1		[expr (1 <<  9)]		;# Programmable Clock 1
set		AT91_PMC_PCK2		[expr (1 << 10)]		;# Programmable Clock 2
set		AT91_PMC_PCK3		[expr (1 << 11)]		;# Programmable Clock 3
set		AT91_PMC_HCK0		[expr (1 << 16)]		;# AHB Clock (USB host) [AT91SAM9261 only]
set		AT91_PMC_HCK1		[expr (1 << 17)]		;# AHB Clock (LCD) [AT91SAM9261 only]

set	AT91_PMC_PCER		[expr ($AT91_PMC + 0x10)]	;# Peripheral Clock Enable Register
set	AT91_PMC_PCDR		[expr ($AT91_PMC + 0x14)]	;# Peripheral Clock Disable Register
set	AT91_PMC_PCSR		[expr ($AT91_PMC + 0x18)]	;# Peripheral Clock Status Register

set	AT91_CKGR_UCKR		[expr ($AT91_PMC + 0x1C)]	;# UTMI Clock Register [some SAM9, CAP9]
set		AT91_PMC_UPLLEN		[expr (1   << 16)]		;# UTMI PLL Enable
set		AT91_PMC_UPLLCOUNT	[expr (0xf << 20)]		;# UTMI PLL Start-up Time
set		AT91_PMC_BIASEN		[expr (1   << 24)]		;# UTMI BIAS Enable
set		AT91_PMC_BIASCOUNT	[expr (0xf << 28)]		;# UTMI BIAS Start-up Time

set	AT91_CKGR_MOR		[expr ($AT91_PMC + 0x20)]	;# Main Oscillator Register [not on SAM9RL]
set		AT91_PMC_MOSCEN		[expr (1    << 0)]		;# Main Oscillator Enable
set		AT91_PMC_OSCBYPASS	[expr (1    << 1)]		;# Oscillator Bypass [SAM9x, CAP9]
set		AT91_PMC_OSCOUNT	[expr (0xff << 8)]		;# Main Oscillator Start-up Time

set	AT91_CKGR_MCFR		[expr ($AT91_PMC + 0x24)]	;# Main Clock Frequency Register
set		AT91_PMC_MAINF		[expr (0xffff <<  0)]		;# Main Clock Frequency
set		AT91_PMC_MAINRDY	[expr (1	<< 16)]		;# Main Clock Ready

set	AT91_CKGR_PLLAR		[expr ($AT91_PMC + 0x28)]	;# PLL A Register
set	AT91_CKGR_PLLBR		[expr ($AT91_PMC + 0x2c)]	;# PLL B Register
set		AT91_PMC_DIV		[expr (0xff  <<  0)]		;# Divider
set		AT91_PMC_PLLCOUNT	[expr (0x3f  <<  8)]		;# PLL Counter
set		AT91_PMC_OUT		[expr (3     << 14)]		;# PLL Clock Frequency Range
set		AT91_PMC_MUL		[expr (0x7ff << 16)]		;# PLL Multiplier
set		AT91_PMC_USBDIV		[expr (3     << 28)]		;# USB Divisor (PLLB only)
set			AT91_PMC_USBDIV_1		[expr (0 << 28)]
set			AT91_PMC_USBDIV_2		[expr (1 << 28)]
set			AT91_PMC_USBDIV_4		[expr (2 << 28)]
set		AT91_PMC_USB96M		[expr (1     << 28)]		;# Divider by 2 Enable (PLLB only)
set		AT91_PMC_PLLA_WR_ERRATA	[expr (1     << 29)]		;# Bit 29 must always be set to 1 when programming the CKGR_PLLAR register

set	AT91_PMC_MCKR		[expr ($AT91_PMC + 0x30)]	;# Master Clock Register
set		AT91_PMC_CSS		[expr (3 <<  0)]		;# Master Clock Selection
set			AT91_PMC_CSS_SLOW		[expr (0 << 0)]
set			AT91_PMC_CSS_MAIN		[expr (1 << 0)]
set			AT91_PMC_CSS_PLLA		[expr (2 << 0)]
set			AT91_PMC_CSS_PLLB		[expr (3 << 0)]
set			AT91_PMC_CSS_UPLL		[expr (3 << 0)]	;# [some SAM9 only]
set		AT91_PMC_PRES		[expr (7 <<  2)]		;# Master Clock Prescaler
set			AT91_PMC_PRES_1			[expr (0 << 2)]
set			AT91_PMC_PRES_2			[expr (1 << 2)]
set			AT91_PMC_PRES_4			[expr (2 << 2)]
set			AT91_PMC_PRES_8			[expr (3 << 2)]
set			AT91_PMC_PRES_16		[expr (4 << 2)]
set			AT91_PMC_PRES_32		[expr (5 << 2)]
set			AT91_PMC_PRES_64		[expr (6 << 2)]
set		AT91_PMC_MDIV		[expr (3 <<  8)]		;# Master Clock Division
set			AT91RM9200_PMC_MDIV_1		[expr (0 << 8)]	;# [AT91RM9200 only]
set			AT91RM9200_PMC_MDIV_2		[expr (1 << 8)]
set			AT91RM9200_PMC_MDIV_3		[expr (2 << 8)]
set			AT91RM9200_PMC_MDIV_4		[expr (3 << 8)]
set			AT91SAM9_PMC_MDIV_1		[expr (0 << 8)]	;# [SAM9,CAP9 only]
set			AT91SAM9_PMC_MDIV_2		[expr (1 << 8)]
set			AT91SAM9_PMC_MDIV_4		[expr (2 << 8)]
set			AT91SAM9_PMC_MDIV_6		[expr (3 << 8)]	;# [some SAM9 only]
set			AT91SAM9_PMC_MDIV_3		[expr (3 << 8)]	;# [some SAM9 only]
set		AT91_PMC_PDIV		[expr (1 << 12)]		;# Processor Clock Division [some SAM9 only]
set			AT91_PMC_PDIV_1			[expr (0 << 12)]
set			AT91_PMC_PDIV_2			[expr (1 << 12)]
set		AT91_PMC_PLLADIV2	[expr (1 << 12)]		;# PLLA divisor by 2 [some SAM9 only]
set			AT91_PMC_PLLADIV2_OFF		[expr (0 << 12)]
set			AT91_PMC_PLLADIV2_ON		[expr (1 << 12)]

set	AT91_PMC_USB		[expr ($AT91_PMC + 0x38)]	;# USB Clock Register [some SAM9 only]
set		AT91_PMC_USBS		[expr (0x1 <<  0)]		;# USB OHCI Input clock selection
set			AT91_PMC_USBS_PLLA		[expr (0 << 0)]
set			AT91_PMC_USBS_UPLL		[expr (1 << 0)]
set		AT91_PMC_OHCIUSBDIV	[expr (0xF <<  8)]		;# Divider for USB OHCI Clock

;# set	AT91_PMC_PCKR(n)	[expr ($AT91_PMC + 0x40 + ((n) * 4))]	;# Programmable Clock 0-N Registers
set		AT91_PMC_CSSMCK		[expr (0x1 <<  8)]		;# CSS or Master Clock Selection
set			AT91_PMC_CSSMCK_CSS		[expr (0 << 8)]
set			AT91_PMC_CSSMCK_MCK		[expr (1 << 8)]

set	AT91_PMC_IER		[expr ($AT91_PMC + 0x60)]	;# Interrupt Enable Register
set	AT91_PMC_IDR		[expr ($AT91_PMC + 0x64)]	;# Interrupt Disable Register
set	AT91_PMC_SR		[expr ($AT91_PMC + 0x68)]	;# Status Register
set		AT91_PMC_MOSCS		[expr (1 <<  0)]		;# MOSCS Flag
set		AT91_PMC_LOCKA		[expr (1 <<  1)]		;# PLLA Lock
set		AT91_PMC_LOCKB		[expr (1 <<  2)]		;# PLLB Lock
set		AT91_PMC_MCKRDY		[expr (1 <<  3)]		;# Master Clock
set		AT91_PMC_LOCKU		[expr (1 <<  6)]		;# UPLL Lock [some SAM9, AT91CAP9 only]
set		AT91_PMC_OSCSEL		[expr (1 <<  7)]		;# Slow Clock Oscillator [AT91CAP9 revC only]
set		AT91_PMC_PCK0RDY	[expr (1 <<  8)]		;# Programmable Clock 0
set		AT91_PMC_PCK1RDY	[expr (1 <<  9)]		;# Programmable Clock 1
set		AT91_PMC_PCK2RDY	[expr (1 << 10)]		;# Programmable Clock 2
set		AT91_PMC_PCK3RDY	[expr (1 << 11)]		;# Programmable Clock 3
set	AT91_PMC_IMR		[expr ($AT91_PMC + 0x6c)]	;# Interrupt Mask Register

set AT91_PMC_PROT		[expr ($AT91_PMC + 0xe4)]	;# Protect Register [AT91CAP9 revC only]
set		AT91_PMC_PROTKEY	0x504d4301	;# Activation Code

set AT91_PMC_VER		[expr ($AT91_PMC + 0xfc)]	;# PMC Module Version [AT91CAP9 only]
set AT91_RSTC_CR		[expr ($AT91_RSTC + 0x00)]	;# Reset Controller Control Register
set		AT91_RSTC_PROCRST	[expr (1 << 0)]		;# Processor Reset
set		AT91_RSTC_PERRST	[expr (1 << 2)]		;# Peripheral Reset
set		AT91_RSTC_EXTRST	[expr (1 << 3)]		;# External Reset
set		AT91_RSTC_KEY		[expr (0xa5 << 24)]		;# KEY Password

set AT91_RSTC_SR		[expr ($AT91_RSTC + 0x04)]	;# Reset Controller Status Register
set		AT91_RSTC_URSTS		[expr (1 << 0)]		;# User Reset Status
set		AT91_RSTC_RSTTYP	[expr (7 << 8)]		;# Reset Type
set			AT91_RSTC_RSTTYP_GENERAL	[expr (0 << 8)]
set			AT91_RSTC_RSTTYP_WAKEUP		[expr (1 << 8)]
set			AT91_RSTC_RSTTYP_WATCHDOG	[expr (2 << 8)]
set			AT91_RSTC_RSTTYP_SOFTWARE	[expr (3 << 8)]
set			AT91_RSTC_RSTTYP_USER	[expr (4 << 8)]
set		AT91_RSTC_NRSTL		[expr (1 << 16)]		;# NRST Pin Level
set		AT91_RSTC_SRCMP		[expr (1 << 17)]		;# Software Reset Command in Progress

set AT91_RSTC_MR		[expr ($AT91_RSTC + 0x08)]	;# Reset Controller Mode Register
set		AT91_RSTC_URSTEN	[expr (1 << 0)]		;# User Reset Enable
set		AT91_RSTC_URSTIEN	[expr (1 << 4)]		;# User Reset Interrupt Enable
set		AT91_RSTC_ERSTL		[expr (0xf << 8)]		;# External Reset Length
set AT91_WDT_CR		[expr ($AT91_WDT + 0x00)]	;# Watchdog Control Register
set		AT91_WDT_WDRSTT		[expr (1    << 0)]	;# Restart
set		AT91_WDT_KEY		[expr (0xa5 << 24)]	;# KEY Password

set AT91_WDT_MR		[expr ($AT91_WDT + 0x04)]	;# Watchdog Mode Register
set		AT91_WDT_WDV		[expr (0xfff << 0)]	;# Counter Value
set		AT91_WDT_WDFIEN		[expr (1     << 12)]	;# Fault Interrupt Enable
set		AT91_WDT_WDRSTEN	[expr (1     << 13)]	;# Reset Processor
set		AT91_WDT_WDRPROC	[expr (1     << 14)]	;# Timer Restart
set		AT91_WDT_WDDIS		[expr (1     << 15)]	;# Watchdog Disable
set		AT91_WDT_WDD		[expr (0xfff << 16)]	;# Delta Value
set		AT91_WDT_WDDBGHLT	[expr (1     << 28)]	;# Debug Halt
set		AT91_WDT_WDIDLEHLT	[expr (1     << 29)]	;# Idle Halt

set AT91_WDT_SR		[expr ($AT91_WDT + 0x08)]	;# Watchdog Status Register
set		AT91_WDT_WDUNF		[expr (1 << 0)]		;# Watchdog Underflow
set		AT91_WDT_WDERR		[expr (1 << 1)]		;# Watchdog Error
source [find bitsbytes.tcl]
source [find cpu/arm/arm7tdmi.tcl]
source [find memory.tcl]
source [find mmr_helpers.tcl]

set CHIP_MAKER  atmel
set CHIP_FAMILY at91sam7
set CHIP_NAME   at91sam7x128
# how many flash regions.
set N_FLASH                1
set FLASH(0,CHIPSELECT)    -1
set FLASH(0,BASE)          0x00100000
set FLASH(0,LEN)           $__128K
set FLASH(0,HUMAN)         "internal flash"
set FLASH(0,TYPE)          "flash"
set FLASH(0,RWX)           $RWX_R_X
set FLASH(0,ACCESS_WIDTH)  $ACCESS_WIDTH_ANY
# how many ram regions.
set N_RAM                  1
set RAM(0,CHIPSELECT)      -1
set RAM(0,BASE)            0x00200000
set RAM(0,LEN)             $__32K
set RAM(0,HUMAN)           "internal ram"
set RAM(0,TYPE)            "ram"
set RAM(0,RWX)             $RWX_RWX
set RAM(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

# I AM LAZY... I create 1 region for all MMRs.
set N_MMREGS    1
set MMREGS(0,CHIPSELECT)      -1
set MMREGS(0,BASE)            0xfff00000
set MMREGS(0,LEN)             0x000fffff
set MMREGS(0,HUMAN)           "mm-regs"
set MMREGS(0,TYPE)            "mmr"
set MMREGS(0,RWX)             $RWX_RW
set MMREGS(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

# no external memory
set N_XMEM 0




set AT91C_BASE_SYS       0xFFFFF000
set AT91C_BASE_AIC       0xFFFFF000
set AT91C_BASE_PDC_DBGU  0xFFFFF300
set AT91C_BASE_DBGU      0xFFFFF200
set AT91C_BASE_PIOA      0xFFFFF400
set AT91C_BASE_PIOB      0xFFFFF600
set AT91C_BASE_CKGR      0xFFFFFC20
set AT91C_BASE_PMC       0xFFFFFC00
set AT91C_BASE_RSTC      0xFFFFFD00
set AT91C_BASE_RTTC      0xFFFFFD20
set AT91C_BASE_PITC      0xFFFFFD30
set AT91C_BASE_WDTC      0xFFFFFD40
set AT91C_BASE_VREG      0xFFFFFD60
set AT91C_BASE_MC        0xFFFFFF00
set AT91C_BASE_PDC_SPI1  0xFFFE4100
set AT91C_BASE_SPI1      0xFFFE4000
set AT91C_BASE_PDC_SPI0  0xFFFE0100
set AT91C_BASE_SPI0      0xFFFE0000
set AT91C_BASE_PDC_US1   0xFFFC4100
set AT91C_BASE_US1       0xFFFC4000
set AT91C_BASE_PDC_US0   0xFFFC0100
set AT91C_BASE_US0       0xFFFC0000
set AT91C_BASE_PDC_SSC   0xFFFD4100
set AT91C_BASE_SSC       0xFFFD4000
set AT91C_BASE_TWI       0xFFFB8000
set AT91C_BASE_PWMC_CH3  0xFFFCC260
set AT91C_BASE_PWMC_CH2  0xFFFCC240
set AT91C_BASE_PWMC_CH1  0xFFFCC220
set AT91C_BASE_PWMC_CH0  0xFFFCC200
set AT91C_BASE_PWMC      0xFFFCC000
set AT91C_BASE_UDP       0xFFFB0000
set AT91C_BASE_TC0       0xFFFA0000
set AT91C_BASE_TC1       0xFFFA0040
set AT91C_BASE_TC2       0xFFFA0080
set AT91C_BASE_TCB       0xFFFA0000
set AT91C_BASE_CAN_MB0   0xFFFD0200
set AT91C_BASE_CAN_MB1   0xFFFD0220
set AT91C_BASE_CAN_MB2   0xFFFD0240
set AT91C_BASE_CAN_MB3   0xFFFD0260
set AT91C_BASE_CAN_MB4   0xFFFD0280
set AT91C_BASE_CAN_MB5   0xFFFD02A0
set AT91C_BASE_CAN_MB6   0xFFFD02C0
set AT91C_BASE_CAN_MB7   0xFFFD02E0
set AT91C_BASE_CAN       0xFFFD0000
set AT91C_BASE_EMAC      0xFFFDC000
set AT91C_BASE_PDC_ADC   0xFFFD8100
set AT91C_BASE_ADC       0xFFFD8000

set AT91C_ID(0) FIQ
set AT91C_ID(1) SYS
set AT91C_ID(2) PIOA
set AT91C_ID(3) PIOB
set AT91C_ID(4) SPI0
set AT91C_ID(5) SPI1
set AT91C_ID(6) US0
set AT91C_ID(7) US1
set AT91C_ID(8) SSC
set AT91C_ID(9) TWI
set AT91C_ID(10) PWMC
set AT91C_ID(11) UDP
set AT91C_ID(12) TC0
set AT91C_ID(13) TC1
set AT91C_ID(14) TC2
set AT91C_ID(15) CAN
set AT91C_ID(16) EMAC
set AT91C_ID(17) ADC
set AT91C_ID(18) ""
set AT91C_ID(19) ""
set AT91C_ID(20) ""
set AT91C_ID(21) ""
set AT91C_ID(22) ""
set AT91C_ID(23) ""
set AT91C_ID(24) ""
set AT91C_ID(25) ""
set AT91C_ID(26) ""
set AT91C_ID(27) ""
set AT91C_ID(28) ""
set AT91C_ID(29) ""
set AT91C_ID(30) IRQ0
set AT91C_ID(31) IRQ1

source [find chip/atmel/at91/aic.tcl]
source [find chip/atmel/at91/usarts.tcl]
source [find chip/atmel/at91/pmc.tcl]
source [find chip/atmel/at91/rtt.tcl]
source [find bitsbytes.tcl]
source [find cpu/arm/arm7tdmi.tcl]
source [find memory.tcl]
source [find mmr_helpers.tcl]

set CHIP_MAKER  atmel
set CHIP_FAMILY at91sam7
set CHIP_NAME   at91sam7x256
# how many flash regions.
set N_FLASH                1
set FLASH(0,CHIPSELECT)    -1
set FLASH(0,BASE)          0x00100000
set FLASH(0,LEN)           $__256K
set FLASH(0,HUMAN)         "internal flash"
set FLASH(0,TYPE)          "flash"
set FLASH(0,RWX)           $RWX_R_X
set FLASH(0,ACCESS_WIDTH)  $ACCESS_WIDTH_ANY
# how many ram regions.
set N_RAM                  1
set RAM(0,CHIPSELECT)      -1
set RAM(0,BASE)            0x00200000
set RAM(0,LEN)             $__64K
set RAM(0,HUMAN)           "internal ram"
set RAM(0,TYPE)            "ram"
set RAM(0,RWX)             $RWX_RWX
set RAM(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

# I AM LAZY... I create 1 region for all MMRs.
set N_MMREGS    1
set MMREGS(0,CHIPSELECT)      -1
set MMREGS(0,BASE)            0xfff00000
set MMREGS(0,LEN)             0x000fffff
set MMREGS(0,HUMAN)           "mm-regs"
set MMREGS(0,TYPE)            "mmr"
set MMREGS(0,RWX)             $RWX_RW
set MMREGS(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

# no external memory
set N_XMEM 0

set  AT91C_BASE_SYS              0xFFFFF000
set  AT91C_BASE_AIC              0xFFFFF000
set  AT91C_BASE_PDC_DBGU         0xFFFFF300
set  AT91C_BASE_DBGU             0xFFFFF200
set  AT91C_BASE_PIOA             0xFFFFF400
set  AT91C_BASE_PIOB             0xFFFFF600
set  AT91C_BASE_CKGR             0xFFFFFC20
set  AT91C_BASE_PMC              0xFFFFFC00
set  AT91C_BASE_RSTC             0xFFFFFD00
set  AT91C_BASE_RTTC             0xFFFFFD20
set  AT91C_BASE_PITC             0xFFFFFD30
set  AT91C_BASE_WDTC             0xFFFFFD40
set  AT91C_BASE_VREG             0xFFFFFD60
set  AT91C_BASE_MC          0xFFFFFF00
set  AT91C_BASE_PDC_SPI1      0xFFFE4100
set  AT91C_BASE_SPI1          0xFFFE4000
set  AT91C_BASE_PDC_SPI0      0xFFFE0100
set  AT91C_BASE_SPI0          0xFFFE0000
set  AT91C_BASE_PDC_US1       0xFFFC4100
set  AT91C_BASE_US1           0xFFFC4000
set  AT91C_BASE_PDC_US0       0xFFFC0100
set  AT91C_BASE_US0           0xFFFC0000
set  AT91C_BASE_PDC_SSC       0xFFFD4100
set  AT91C_BASE_SSC           0xFFFD4000
set  AT91C_BASE_TWI           0xFFFB8000
set  AT91C_BASE_PWMC_CH3      0xFFFCC260
set  AT91C_BASE_PWMC_CH2      0xFFFCC240
set  AT91C_BASE_PWMC_CH1      0xFFFCC220
set  AT91C_BASE_PWMC_CH0      0xFFFCC200
set  AT91C_BASE_PWMC          0xFFFCC000
set  AT91C_BASE_UDP           0xFFFB0000
set  AT91C_BASE_TC0         0xFFFA0000
set  AT91C_BASE_TC1         0xFFFA0040
set  AT91C_BASE_TC2         0xFFFA0080
set  AT91C_BASE_TCB             0xFFFA0000
set  AT91C_BASE_CAN_MB0         0xFFFD0200
set  AT91C_BASE_CAN_MB1         0xFFFD0220
set  AT91C_BASE_CAN_MB2         0xFFFD0240
set  AT91C_BASE_CAN_MB3         0xFFFD0260
set  AT91C_BASE_CAN_MB4         0xFFFD0280
set  AT91C_BASE_CAN_MB5         0xFFFD02A0
set  AT91C_BASE_CAN_MB6         0xFFFD02C0
set  AT91C_BASE_CAN_MB7         0xFFFD02E0
set  AT91C_BASE_CAN             0xFFFD0000
set  AT91C_BASE_EMAC            0xFFFDC000
set  AT91C_BASE_PDC_ADC         0xFFFD8100
set  AT91C_BASE_ADC             0xFFFD8000

set AT91C_ID(0)   "FIQ"
set AT91C_ID(1)   "SYS"
set AT91C_ID(2)   "PIOA"
set AT91C_ID(3)   "PIOB"
set AT91C_ID(4)   "SPI0"
set AT91C_ID(5)   "SPI1"
set AT91C_ID(6)   "US0"
set AT91C_ID(7)   "US1"
set AT91C_ID(8)   "SSC"
set AT91C_ID(9)   "TWI"
set AT91C_ID(10)   "PWMC"
set AT91C_ID(11)   "UDP"
set AT91C_ID(12)   "TC0"
set AT91C_ID(13)   "TC1"
set AT91C_ID(14)   "TC2"
set AT91C_ID(15)   "CAN"
set AT91C_ID(16)   "EMAC"
set AT91C_ID(17)   "ADC"
set AT91C_ID(18)   ""
set AT91C_ID(19)   ""
set AT91C_ID(20)   ""
set AT91C_ID(21)   ""
set AT91C_ID(22)   ""
set AT91C_ID(23)   ""
set AT91C_ID(24)   ""
set AT91C_ID(25)   ""
set AT91C_ID(26)   ""
set AT91C_ID(27)   ""
set AT91C_ID(28)   ""
set AT91C_ID(29)   ""
set AT91C_ID(30)   "IRQ0"
set AT91C_ID(31)   "IRQ1"


source [find chip/atmel/at91/aic.tcl]
source [find chip/atmel/at91/usarts.tcl]
source [find chip/atmel/at91/pmc.tcl]
source [find chip/atmel/at91/rtt.tcl]
#
# Peripheral identifiers/interrupts.
#
set AT91_ID_FIQ		0	;# Advanced Interrupt Controller (FIQ)
set AT91_ID_SYS		1	;# System Peripherals
set AT91SAM9261_ID_PIOA	2	;# Parallel IO Controller A
set AT91SAM9261_ID_PIOB	3	;# Parallel IO Controller B
set AT91SAM9261_ID_PIOC	4	;# Parallel IO Controller C
set AT91SAM9261_ID_US0	6	;# USART 0
set AT91SAM9261_ID_US1	7	;# USART 1
set AT91SAM9261_ID_US2	8	;# USART 2
set AT91SAM9261_ID_MCI	9	;# Multimedia Card Interface
set AT91SAM9261_ID_UDP	10	;# USB Device Port
set AT91SAM9261_ID_TWI	11	;# Two-Wire Interface
set AT91SAM9261_ID_SPI0	12	;# Serial Peripheral Interface 0
set AT91SAM9261_ID_SPI1	13	;# Serial Peripheral Interface 1
set AT91SAM9261_ID_SSC0	14	;# Serial Synchronous Controller 0
set AT91SAM9261_ID_SSC1	15	;# Serial Synchronous Controller 1
set AT91SAM9261_ID_SSC2	16	;# Serial Synchronous Controller 2
set AT91SAM9261_ID_TC0	17	;# Timer Counter 0
set AT91SAM9261_ID_TC1	18	;# Timer Counter 1
set AT91SAM9261_ID_TC2	19	;# Timer Counter 2
set AT91SAM9261_ID_UHP	20	;# USB Host port
set AT91SAM9261_ID_LCDC	21	;# LDC Controller
set AT91SAM9261_ID_IRQ0	29	;# Advanced Interrupt Controller (IRQ0)
set AT91SAM9261_ID_IRQ1	30	;# Advanced Interrupt Controller (IRQ1)
set AT91SAM9261_ID_IRQ2	31	;# Advanced Interrupt Controller (IRQ2)


#
# User Peripheral physical base addresses.
#
set AT91SAM9261_BASE_TCB0		0xfffa0000
set AT91SAM9261_BASE_TC0		0xfffa0000
set AT91SAM9261_BASE_TC1		0xfffa0040
set AT91SAM9261_BASE_TC2		0xfffa0080
set AT91SAM9261_BASE_UDP		0xfffa4000
set AT91SAM9261_BASE_MCI		0xfffa8000
set AT91SAM9261_BASE_TWI		0xfffac000
set AT91SAM9261_BASE_US0		0xfffb0000
set AT91SAM9261_BASE_US1		0xfffb4000
set AT91SAM9261_BASE_US2		0xfffb8000
set AT91SAM9261_BASE_SSC0		0xfffbc000
set AT91SAM9261_BASE_SSC1		0xfffc0000
set AT91SAM9261_BASE_SSC2		0xfffc4000
set AT91SAM9261_BASE_SPI0		0xfffc8000
set AT91SAM9261_BASE_SPI1		0xfffcc000
set AT91_BASE_SYS			0xffffea00


#
# System Peripherals (offset from AT91_BASE_SYS)
#
set AT91_SDRAMC	0xffffea00
set AT91_SMC	0xffffec00
set AT91_MATRIX	0xffffee00
set AT91_AIC	0xfffff000
set AT91_DBGU	0xfffff200
set AT91_PIOA	0xfffff400
set AT91_PIOB	0xfffff600
set AT91_PIOC	0xfffff800
set AT91_PMC	0xfffffc00
set AT91_RSTC	0xfffffd00
set AT91_SHDWC	0xfffffd10
set AT91_RTT	0xfffffd20
set AT91_PIT	0xfffffd30
set AT91_WDT	0xfffffd40
set AT91_GPBR	0xfffffd50

set AT91_USART0	$AT91SAM9261_BASE_US0
set AT91_USART1	$AT91SAM9261_BASE_US1
set AT91_USART2	$AT91SAM9261_BASE_US2


#
# Internal Memory.
#
set AT91SAM9261_SRAM_BASE	0x00300000	;# Internal SRAM base address
set AT91SAM9261_SRAM_SIZE	0x00028000	;# Internal SRAM size (160Kb)

set AT91SAM9261_ROM_BASE	0x00400000	;# Internal ROM base address
set AT91SAM9261_ROM_SIZE	0x00008000	;# Internal ROM size (32Kb)

set AT91SAM9261_UHP_BASE	0x00500000	;# USB Host controller
set AT91SAM9261_LCDC_BASE	0x00600000	;# LDC controller

#
# Cpu Name
#
set AT91_CPU_NAME	"AT91SAM9261"

set AT91_MATRIX_MCFG	[expr ($AT91_MATRIX + 0x00)]	;# Master Configuration Register #
set		AT91_MATRIX_RCB0	[expr (1 << 0)]		;# Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master)
set		AT91_MATRIX_RCB1	[expr (1 << 1)]		;# Remap Command for AHB Master 1 (ARM926EJ-S Data Master)

set AT91_MATRIX_SCFG0	[expr ($AT91_MATRIX + 0x04)]	;# Slave Configuration Register 0
set AT91_MATRIX_SCFG1	[expr ($AT91_MATRIX + 0x08)]	;# Slave Configuration Register 1
set AT91_MATRIX_SCFG2	[expr ($AT91_MATRIX + 0x0C)]	;# Slave Configuration Register 2
set AT91_MATRIX_SCFG3	[expr ($AT91_MATRIX + 0x10)]	;# Slave Configuration Register 3
set AT91_MATRIX_SCFG4	[expr ($AT91_MATRIX + 0x14)]	;# Slave Configuration Register 4
set		AT91_MATRIX_SLOT_CYCLE		[expr (0xff << 0)]	;# Maximum Number of Allowed Cycles for a Burst
set		AT91_MATRIX_DEFMSTR_TYPE	[expr (3    << 16)]	;# Default Master Type
set			AT91_MATRIX_DEFMSTR_TYPE_NONE	[expr (0 << 16)]
set			AT91_MATRIX_DEFMSTR_TYPE_LAST	[expr (1 << 16)]
set			AT91_MATRIX_DEFMSTR_TYPE_FIXED	[expr (2 << 16)]
set		AT91_MATRIX_FIXED_DEFMSTR	[expr (7    << 18)]	;# Fixed Index of Default Master

set AT91_MATRIX_TCR		[expr ($AT91_MATRIX + 0x24)]	;# TCM Configuration Register
set		AT91_MATRIX_ITCM_SIZE		[expr (0xf << 0)]	;# Size of ITCM enabled memory block
set			AT91_MATRIX_ITCM_0		[expr (0 << 0)]
set			AT91_MATRIX_ITCM_16		[expr (5 << 0)]
set			AT91_MATRIX_ITCM_32		[expr (6 << 0)]
set			AT91_MATRIX_ITCM_64		[expr (7 << 0)]
set		AT91_MATRIX_DTCM_SIZE		[expr (0xf << 4)]	;# Size of DTCM enabled memory block
set			AT91_MATRIX_DTCM_0		[expr (0 << 4)]
set			AT91_MATRIX_DTCM_16		[expr (5 << 4)]
set			AT91_MATRIX_DTCM_32		[expr (6 << 4)]
set			AT91_MATRIX_DTCM_64		[expr (7 << 4)]

set AT91_MATRIX_EBICSA	[expr ($AT91_MATRIX + 0x30)]	;# EBI Chip Select Assignment Register
set		AT91_MATRIX_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
set			AT91_MATRIX_CS1A_SMC		[expr (0 << 1)]
set			AT91_MATRIX_CS1A_SDRAMC		[expr (1 << 1)]
set		AT91_MATRIX_CS3A		[expr (1 << 3)]	;# Chip Select 3 Assignment
set			AT91_MATRIX_CS3A_SMC		[expr (0 << 3)]
set			AT91_MATRIX_CS3A_SMC_SMARTMEDIA	[expr (1 << 3)]
set		AT91_MATRIX_CS4A		[expr (1 << 4)]	;# Chip Select 4 Assignment
set			AT91_MATRIX_CS4A_SMC		[expr (0 << 4)]
set			AT91_MATRIX_CS4A_SMC_CF1	[expr (1 << 4)]
set		AT91_MATRIX_CS5A		[expr (1 << 5)]	;# Chip Select 5 Assignment
set			AT91_MATRIX_CS5A_SMC		[expr (0 << 5)]
set			AT91_MATRIX_CS5A_SMC_CF2	[expr (1 << 5)]
set		AT91_MATRIX_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration

set AT91_MATRIX_USBPUCR	[expr ($AT91_MATRIX + 0x34)]	;# USB Pad Pull-Up Control Register
set		AT91_MATRIX_USBPUCR_PUON	[expr (1 << 30)]	;# USB Device PAD Pull-up Enable
#
# Peripheral identifiers/interrupts.
#
set AT91_ID_FIQ		0	;# Advanced Interrupt Controller (FIQ)
set AT91_ID_SYS		1	;# System Peripherals
set AT91SAM9263_ID_PIOA	2	;# Parallel IO Controller A
set AT91SAM9263_ID_PIOB	3	;# Parallel IO Controller B
set AT91SAM9263_ID_PIOCDE	4	;# Parallel IO Controller C, D and E
set AT91SAM9263_ID_US0	7	;# USART 0
set AT91SAM9263_ID_US1	8	;# USART 1
set AT91SAM9263_ID_US2	9	;# USART 2
set AT91SAM9263_ID_MCI0	10	;# Multimedia Card Interface 0
set AT91SAM9263_ID_MCI1	11	;# Multimedia Card Interface 1
set AT91SAM9263_ID_CAN	12	;# CAN
set AT91SAM9263_ID_TWI	13	;# Two-Wire Interface
set AT91SAM9263_ID_SPI0	14	;# Serial Peripheral Interface 0
set AT91SAM9263_ID_SPI1	15	;# Serial Peripheral Interface 1
set AT91SAM9263_ID_SSC0	16	;# Serial Synchronous Controller 0
set AT91SAM9263_ID_SSC1	17	;# Serial Synchronous Controller 1
set AT91SAM9263_ID_AC97C	18	;# AC97 Controller
set AT91SAM9263_ID_TCB	19	;# Timer Counter 0, 1 and 2
set AT91SAM9263_ID_PWMC	20	;# Pulse Width Modulation Controller
set AT91SAM9263_ID_EMAC	21	;# Ethernet
set AT91SAM9263_ID_2DGE	23	;# 2D Graphic Engine
set AT91SAM9263_ID_UDP	24	;# USB Device Port
set AT91SAM9263_ID_ISI	25	;# Image Sensor Interface
set AT91SAM9263_ID_LCDC	26	;# LCD Controller
set AT91SAM9263_ID_DMA	27	;# DMA Controller
set AT91SAM9263_ID_UHP	29	;# USB Host port
set AT91SAM9263_ID_IRQ0	30	;# Advanced Interrupt Controller (IRQ0)
set AT91SAM9263_ID_IRQ1	31	;# Advanced Interrupt Controller (IRQ1)


#
# User Peripheral physical base addresses.
#
set AT91SAM9263_BASE_UDP		0xfff78000
set AT91SAM9263_BASE_TCB0		0xfff7c000
set AT91SAM9263_BASE_TC0		0xfff7c000
set AT91SAM9263_BASE_TC1		0xfff7c040
set AT91SAM9263_BASE_TC2		0xfff7c080
set AT91SAM9263_BASE_MCI0		0xfff80000
set AT91SAM9263_BASE_MCI1		0xfff84000
set AT91SAM9263_BASE_TWI		0xfff88000
set AT91SAM9263_BASE_US0		0xfff8c000
set AT91SAM9263_BASE_US1		0xfff90000
set AT91SAM9263_BASE_US2		0xfff94000
set AT91SAM9263_BASE_SSC0		0xfff98000
set AT91SAM9263_BASE_SSC1		0xfff9c000
set AT91SAM9263_BASE_AC97C		0xfffa0000
set AT91SAM9263_BASE_SPI0		0xfffa4000
set AT91SAM9263_BASE_SPI1		0xfffa8000
set AT91SAM9263_BASE_CAN		0xfffac000
set AT91SAM9263_BASE_PWMC		0xfffb8000
set AT91SAM9263_BASE_EMAC		0xfffbc000
set AT91SAM9263_BASE_ISI		0xfffc4000
set AT91SAM9263_BASE_2DGE		0xfffc8000
set AT91_BASE_SYS			0xffffe000

#
# System Peripherals (offset from AT91_BASE_SYS)
#
set AT91_ECC0		0xffffe000
set AT91_SDRAMC0	0xffffe200
set AT91_SMC0		0xffffe400
set AT91_ECC1		0xffffe600
set AT91_SDRAMC1	0xffffe800
set AT91_SMC1		0xffffea00
set AT91_MATRIX		0xffffec00
set AT91_CCFG		0xffffed10
set AT91_DBGU		0xffffee00
set AT91_AIC		0xfffff000
set AT91_PIOA		0xfffff200
set AT91_PIOB		0xfffff400
set AT91_PIOC		0xfffff600
set AT91_PIOD		0xfffff800
set AT91_PIOE		0xfffffa00
set AT91_PMC		0xfffffc00
set AT91_RSTC		0xfffffd00
set AT91_SHDWC		0xfffffd10
set AT91_RTT0		0xfffffd20
set AT91_PIT		0xfffffd30
set AT91_WDT		0xfffffd40
set AT91_RTT1		0xfffffd50
set AT91_GPBR		0xfffffd60

set AT91_USART0	$AT91SAM9263_BASE_US0
set AT91_USART1	$AT91SAM9263_BASE_US1
set AT91_USART2	$AT91SAM9263_BASE_US2

set AT91_SMC	$AT91_SMC0
set AT91_SDRAMC	$AT91_SDRAMC0

#
# Internal Memory.
#
set AT91SAM9263_SRAM0_BASE	0x00300000	;# Internal SRAM 0 base address
set AT91SAM9263_SRAM0_SIZE	0x00014000	;# Internal SRAM 0 size (80Kb)

set AT91SAM9263_ROM_BASE	0x00400000	;# Internal ROM base address
set AT91SAM9263_ROM_SIZE	0x00020000	;# Internal ROM size (128Kb)

set AT91SAM9263_SRAM1_BASE	0x00500000	;# Internal SRAM 1 base address
set AT91SAM9263_SRAM1_SIZE	0x00004000	;# Internal SRAM 1 size (16Kb)

set AT91SAM9263_LCDC_BASE	0x00700000	;# LCD Controller
set AT91SAM9263_DMAC_BASE	0x00800000	;# DMA Controller
set AT91SAM9263_UHP_BASE	0x00a00000	;# USB Host controller

#
# Cpu Name
#
set AT91_CPU_NAME	"AT91SAM9263"
set AT91_MATRIX_MCFG0	[expr ($AT91_MATRIX + 0x00)]	;# Master Configuration Register 0
set AT91_MATRIX_MCFG1	[expr ($AT91_MATRIX + 0x04)]	;# Master Configuration Register 1
set AT91_MATRIX_MCFG2	[expr ($AT91_MATRIX + 0x08)]	;# Master Configuration Register 2
set AT91_MATRIX_MCFG3	[expr ($AT91_MATRIX + 0x0C)]	;# Master Configuration Register 3
set AT91_MATRIX_MCFG4	[expr ($AT91_MATRIX + 0x10)]	;# Master Configuration Register 4
set AT91_MATRIX_MCFG5	[expr ($AT91_MATRIX + 0x14)]	;# Master Configuration Register 5
set AT91_MATRIX_MCFG6	[expr ($AT91_MATRIX + 0x18)]	;# Master Configuration Register 6
set AT91_MATRIX_MCFG7	[expr ($AT91_MATRIX + 0x1C)]	;# Master Configuration Register 7
set AT91_MATRIX_MCFG8	[expr ($AT91_MATRIX + 0x20)]	;# Master Configuration Register 8
set		AT91_MATRIX_ULBT	[expr (7 << 0)]	;# Undefined Length Burst Type
set			AT91_MATRIX_ULBT_INFINITE	[expr (0 << 0)]
set			AT91_MATRIX_ULBT_SINGLE		[expr (1 << 0)]
set			AT91_MATRIX_ULBT_FOUR		[expr (2 << 0)]
set			AT91_MATRIX_ULBT_EIGHT		[expr (3 << 0)]
set			AT91_MATRIX_ULBT_SIXTEEN	[expr (4 << 0)]

set AT91_MATRIX_SCFG0	[expr ($AT91_MATRIX + 0x40)]	;# Slave Configuration Register 0
set AT91_MATRIX_SCFG1	[expr ($AT91_MATRIX + 0x44)]	;# Slave Configuration Register 1
set AT91_MATRIX_SCFG2	[expr ($AT91_MATRIX + 0x48)]	;# Slave Configuration Register 2
set AT91_MATRIX_SCFG3	[expr ($AT91_MATRIX + 0x4C)]	;# Slave Configuration Register 3
set AT91_MATRIX_SCFG4	[expr ($AT91_MATRIX + 0x50)]	;# Slave Configuration Register 4
set AT91_MATRIX_SCFG5	[expr ($AT91_MATRIX + 0x54)]	;# Slave Configuration Register 5
set AT91_MATRIX_SCFG6	[expr ($AT91_MATRIX + 0x58)]	;# Slave Configuration Register 6
set AT91_MATRIX_SCFG7	[expr ($AT91_MATRIX + 0x5C)]	;# Slave Configuration Register 7
set		AT91_MATRIX_SLOT_CYCLE		[expr (0xff << 0)]	;# Maximum Number of Allowed Cycles for a Burst
set		AT91_MATRIX_DEFMSTR_TYPE	[expr (3    << 16)]	;# Default Master Type
set			AT91_MATRIX_DEFMSTR_TYPE_NONE	[expr (0 << 16)]
set			AT91_MATRIX_DEFMSTR_TYPE_LAST	[expr (1 << 16)]
set			AT91_MATRIX_DEFMSTR_TYPE_FIXED	[expr (2 << 16)]
set		AT91_MATRIX_FIXED_DEFMSTR	[expr (0xf  << 18)]	;# Fixed Index of Default Master
set		AT91_MATRIX_ARBT		[expr (3    << 24)]	;# Arbitration Type
set			AT91_MATRIX_ARBT_ROUND_ROBIN	[expr (0 << 24)]
set			AT91_MATRIX_ARBT_FIXED_PRIORITY	[expr (1 << 24)]

set AT91_MATRIX_PRAS0	[expr ($AT91_MATRIX + 0x80)]	;# Priority Register A for Slave 0
set AT91_MATRIX_PRBS0	[expr ($AT91_MATRIX + 0x84)]	;# Priority Register B for Slave 0
set AT91_MATRIX_PRAS1	[expr ($AT91_MATRIX + 0x88)]	;# Priority Register A for Slave 1
set AT91_MATRIX_PRBS1	[expr ($AT91_MATRIX + 0x8C)]	;# Priority Register B for Slave 1
set AT91_MATRIX_PRAS2	[expr ($AT91_MATRIX + 0x90)]	;# Priority Register A for Slave 2
set AT91_MATRIX_PRBS2	[expr ($AT91_MATRIX + 0x94)]	;# Priority Register B for Slave 2
set AT91_MATRIX_PRAS3	[expr ($AT91_MATRIX + 0x98)]	;# Priority Register A for Slave 3
set AT91_MATRIX_PRBS3	[expr ($AT91_MATRIX + 0x9C)]	;# Priority Register B for Slave 3
set AT91_MATRIX_PRAS4	[expr ($AT91_MATRIX + 0xA0)]	;# Priority Register A for Slave 4
set AT91_MATRIX_PRBS4	[expr ($AT91_MATRIX + 0xA4)]	;# Priority Register B for Slave 4
set AT91_MATRIX_PRAS5	[expr ($AT91_MATRIX + 0xA8)]	;# Priority Register A for Slave 5
set AT91_MATRIX_PRBS5	[expr ($AT91_MATRIX + 0xAC)]	;# Priority Register B for Slave 5
set AT91_MATRIX_PRAS6	[expr ($AT91_MATRIX + 0xB0)]	;# Priority Register A for Slave 6
set AT91_MATRIX_PRBS6	[expr ($AT91_MATRIX + 0xB4)]	;# Priority Register B for Slave 6
set AT91_MATRIX_PRAS7	[expr ($AT91_MATRIX + 0xB8)]	;# Priority Register A for Slave 7
set AT91_MATRIX_PRBS7	[expr ($AT91_MATRIX + 0xBC)]	;# Priority Register B for Slave 7
set		AT91_MATRIX_M0PR		[expr (3 << 0)]		;# Master 0 Priority
set		AT91_MATRIX_M1PR		[expr (3 << 4)]		;# Master 1 Priority
set		AT91_MATRIX_M2PR		[expr (3 << 8)]		;# Master 2 Priority
set		AT91_MATRIX_M3PR		[expr (3 << 12)]	;# Master 3 Priority
set		AT91_MATRIX_M4PR		[expr (3 << 16)]	;# Master 4 Priority
set		AT91_MATRIX_M5PR		[expr (3 << 20)]	;# Master 5 Priority
set		AT91_MATRIX_M6PR		[expr (3 << 24)]	;# Master 6 Priority
set		AT91_MATRIX_M7PR		[expr (3 << 28)]	;# Master 7 Priority
set		AT91_MATRIX_M8PR		[expr (3 << 0)]		;# Master 8 Priority (in Register B)

set AT91_MATRIX_MRCR	[expr ($AT91_MATRIX + 0x100)]	;# Master Remap Control Register
set		AT91_MATRIX_RCB0		[expr (1 << 0)]	;# Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master)
set		AT91_MATRIX_RCB1		[expr (1 << 1)]	;# Remap Command for AHB Master 1 (ARM926EJ-S Data Master)
set		AT91_MATRIX_RCB2		[expr (1 << 2)]
set		AT91_MATRIX_RCB3		[expr (1 << 3)]
set		AT91_MATRIX_RCB4		[expr (1 << 4)]
set		AT91_MATRIX_RCB5		[expr (1 << 5)]
set		AT91_MATRIX_RCB6		[expr (1 << 6)]
set		AT91_MATRIX_RCB7		[expr (1 << 7)]
set		AT91_MATRIX_RCB8		[expr (1 << 8)]

set AT91_MATRIX_TCMR	[expr ($AT91_MATRIX + 0x114)]	;# TCM Configuration Register
set		AT91_MATRIX_ITCM_SIZE		[expr (0xf << 0)]	;# Size of ITCM enabled memory block
set			AT91_MATRIX_ITCM_0		[expr (0 << 0)]
set			AT91_MATRIX_ITCM_16		[expr (5 << 0)]
set			AT91_MATRIX_ITCM_32		[expr (6 << 0)]
set		AT91_MATRIX_DTCM_SIZE		[expr (0xf << 4)]	;# Size of DTCM enabled memory block
set			AT91_MATRIX_DTCM_0		[expr (0 << 4)]
set			AT91_MATRIX_DTCM_16		[expr (5 << 4)]
set			AT91_MATRIX_DTCM_32		[expr (6 << 4)]

set AT91_MATRIX_EBI0CSA	[expr ($AT91_MATRIX + 0x120)]	;# EBI0 Chip Select Assignment Register
set		AT91_MATRIX_EBI0_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
set			AT91_MATRIX_EBI0_CS1A_SMC		[expr (0 << 1)]
set			AT91_MATRIX_EBI0_CS1A_SDRAMC		[expr (1 << 1)]
set		AT91_MATRIX_EBI0_CS3A		[expr (1 << 3)]	;# Chip Select 3 Assignmen
set			AT91_MATRIX_EBI0_CS3A_SMC		[expr (0 << 3)]
set			AT91_MATRIX_EBI0_CS3A_SMC_SMARTMEDIA	[expr (1 << 3)]
set		AT91_MATRIX_EBI0_CS4A		[expr (1 << 4)]	;# Chip Select 4 Assignment
set			AT91_MATRIX_EBI0_CS4A_SMC		[expr (0 << 4)]
set			AT91_MATRIX_EBI0_CS4A_SMC_CF1		[expr (1 << 4)]
set		AT91_MATRIX_EBI0_CS5A		[expr (1 << 5)]	;# Chip Select 5 Assignment
set			AT91_MATRIX_EBI0_CS5A_SMC		[expr (0 << 5)]
set			AT91_MATRIX_EBI0_CS5A_SMC_CF2		[expr (1 << 5)]
set		AT91_MATRIX_EBI0_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration
set		AT91_MATRIX_EBI0_VDDIOMSEL	[expr (1 << 16)]	;# Memory voltage selection
set			AT91_MATRIX_EBI0_VDDIOMSEL_1_8V		[expr (0 << 16)]
set			AT91_MATRIX_EBI0_VDDIOMSEL_3_3V		[expr (1 << 16)]

set AT91_MATRIX_EBI1CSA	[expr ($AT91_MATRIX + 0x124)]	;# EBI1 Chip Select Assignment Register
set		AT91_MATRIX_EBI1_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
set			AT91_MATRIX_EBI1_CS1A_SMC		[expr (0 << 1)]
set			AT91_MATRIX_EBI1_CS1A_SDRAMC		[expr (1 << 1)]
set		AT91_MATRIX_EBI1_CS2A		[expr (1 << 3)]	;# Chip Select 3 Assignment
set			AT91_MATRIX_EBI1_CS2A_SMC		[expr (0 << 3)]
set			AT91_MATRIX_EBI1_CS2A_SMC_SMARTMEDIA	[expr (1 << 3)]
set		AT91_MATRIX_EBI1_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration
set		AT91_MATRIX_EBI1_VDDIOMSEL	[expr (1 << 16)]	;# Memory voltage selection
set			AT91_MATRIX_EBI1_VDDIOMSEL_1_8V		[expr (0 << 16)]
set			AT91_MATRIX_EBI1_VDDIOMSEL_3_3V		[expr (1 << 16)]
uplevel #0 [list source [find chip/atmel/at91/at91sam9_sdramc.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91_pmc.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91_pio.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91_rstc.cfg]]
uplevel #0 [list source [find chip/atmel/at91/at91_wdt.cfg]]

proc at91sam9_reset_start { } {

	arm7_9 fast_memory_access disable

	jtag_rclk 8
	halt
	wait_halt 10000
	set rstc_mr_val [expr $::AT91_RSTC_KEY]
	set rstc_mr_val [expr ($rstc_mr_val | (5 << 8))]
	set rstc_mr_val [expr ($rstc_mr_val | $::AT91_RSTC_URSTEN)]
	mww $::AT91_RSTC_MR $rstc_mr_val	;# RSTC_MR : enable user reset.
}

proc at91sam9_reset_init { config } {

	mww $::AT91_WDT_MR $config(wdt_mr_val)	;# disable watchdog

	set ckgr_mor [expr ($::AT91_PMC_MOSCEN | (255 << 8))]

	mww $::AT91_CKGR_MOR $ckgr_mor	;# CKGR_MOR - enable main osc.
	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_MOSCS] != $::AT91_PMC_MOSCS } { sleep 1 }

	set pllar_val	[expr $::AT91_PMC_PLLA_WR_ERRATA] ;# Bit 29 must be 1 when prog
	set pllar_val	[expr ($pllar_val | $::AT91_PMC_OUT)]
	set pllar_val	[expr ($pllar_val | $::AT91_PMC_PLLCOUNT)]
	set pllar_val	[expr ($pllar_val | ($config(master_pll_mul) - 1) << 16)]
	set pllar_val	[expr ($pllar_val | $config(master_pll_div))]

	mww $::AT91_CKGR_PLLAR $pllar_val	 ;# CKGR_PLLA - (18.432MHz/13)*141 = 199.9 MHz
	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_LOCKA] != $::AT91_PMC_LOCKA } { sleep 1 }

	;# PCK/2 = MCK Master Clock from PLLA
	set mckr_val	[expr $::AT91_PMC_CSS_PLLA]
	set mckr_val	[expr ($mckr_val | $::AT91_PMC_PRES_1)]
	set mckr_val	[expr ($mckr_val | $::AT91SAM9_PMC_MDIV_2)]
	set mckr_val	[expr ($mckr_val | $::AT91_PMC_PDIV_1)]

	mww $::AT91_PMC_MCKR $mckr_val	;# PMC_MCKR (MCLK: 0x102 - (CLK/2)MHZ, 0x202 - (CLK/3)MHz)
	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_MCKRDY] != $::AT91_PMC_MCKRDY } { sleep 1 }

	## switch JTAG clock to highspeed clock
	jtag_rclk 0

	arm7_9 dcc_downloads enable	;# Enable faster DCC downloads
	arm7_9 fast_memory_access enable

	set rstc_mr_val [expr ($::AT91_RSTC_KEY)]
	set rstc_mr_val [expr ($rstc_mr_val | $::AT91_RSTC_URSTEN)]
	mww $::AT91_RSTC_MR $rstc_mr_val	;# user reset enable

	if { [info exists config(sdram_piod)] } {
		set pdr_addr	[expr ($::AT91_PIOD + $::PIO_PDR)]
		set pudr_addr	[expr ($::AT91_PIOD + $::PIO_PUDR)]
		set asr_addr	[expr ($::AT91_PIOD + $::PIO_ASR)]
		mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
		mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
		mww $asr_addr 0xffff0000
	} else {
		set pdr_addr	[expr ($::AT91_PIOC + $::PIO_PDR)]
		set pudr_addr	[expr ($::AT91_PIOC + $::PIO_PUDR)]
		mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
		mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
	}

	mww $config(matrix_ebicsa_addr) $config(matrix_ebicsa_val)
	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_NORMAL	;# SDRAMC_MR Mode register
	mww $::AT91_SDRAMC_TR	$config(sdram_tr_val)		;# SDRAMC_TR - Refresh Timer register
	mww $::AT91_SDRAMC_CR	$config(sdram_cr_val)		;# SDRAMC_CR - Configuration register
	mww $::AT91_SDRAMC_MDR	$::AT91_SDRAMC_MD_SDRAM		;# Memory Device Register -> SDRAM
	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_PRECHARGE	;# SDRAMC_MR
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_REFRESH	;# SDRC_MR
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_LMR		;# SDRC_MR
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_NORMAL	;# SDRC_MR
	mww $config(sdram_base)	0				;# SDRAM_BASE
	mww $::AT91_SDRAMC_TR	1200				;# SDRAM_TR
	mww $config(sdram_base)	0				;# SDRAM_BASE

	mww $::AT91_MATRIX 0xf		;# MATRIX_MCFG - REMAP all masters
}

# SDRAM Controller (SDRAMC) registers
set AT91_SDRAMC_MR		[expr ($AT91_SDRAMC + 0x00)]	;# SDRAM Controller Mode Register
set		AT91_SDRAMC_MODE	[expr (0xf << 0)]	;# Command Mode
set			AT91_SDRAMC_MODE_NORMAL		0
set			AT91_SDRAMC_MODE_NOP		1
set			AT91_SDRAMC_MODE_PRECHARGE	2
set			AT91_SDRAMC_MODE_LMR		3
set			AT91_SDRAMC_MODE_REFRESH	4
set			AT91_SDRAMC_MODE_EXT_LMR	5
set			AT91_SDRAMC_MODE_DEEP		6

set AT91_SDRAMC_TR		[expr ($AT91_SDRAMC + 0x04)]	;# SDRAM Controller Refresh Timer Register
set		AT91_SDRAMC_COUNT	[expr (0xfff << 0)]		;# Refresh Timer Counter

set AT91_SDRAMC_CR		[expr ($AT91_SDRAMC + 0x08)]	;# SDRAM Controller Configuration Register
set		AT91_SDRAMC_NC		[expr (3 << 0)]		;# Number of Column Bits
set			AT91_SDRAMC_NC_8	[expr (0 << 0)]
set			AT91_SDRAMC_NC_9	[expr (1 << 0)]
set			AT91_SDRAMC_NC_10	[expr (2 << 0)]
set			AT91_SDRAMC_NC_11	[expr (3 << 0)]
set		AT91_SDRAMC_NR		[expr (3 << 2)]		;# Number of Row Bits
set			AT91_SDRAMC_NR_11	[expr (0 << 2)]
set			AT91_SDRAMC_NR_12	[expr (1 << 2)]
set			AT91_SDRAMC_NR_13	[expr (2 << 2)]
set		AT91_SDRAMC_NB		[expr (1 << 4)]		;# Number of Banks
set			AT91_SDRAMC_NB_2	[expr (0 << 4)]
set			AT91_SDRAMC_NB_4	[expr (1 << 4)]
set		AT91_SDRAMC_CAS		[expr (3 << 5)]		;# CAS Latency
set			AT91_SDRAMC_CAS_1	[expr (1 << 5)]
set			AT91_SDRAMC_CAS_2	[expr (2 << 5)]
set			AT91_SDRAMC_CAS_3	[expr (3 << 5)]
set		AT91_SDRAMC_DBW		[expr (1 << 7)]		;# Data Bus Width
set			AT91_SDRAMC_DBW_32	[expr (0 << 7)]
set			AT91_SDRAMC_DBW_16	[expr (1 << 7)]
set		AT91_SDRAMC_TWR		[expr (0xf <<  8)]		;# Write Recovery Delay
set		AT91_SDRAMC_TRC		[expr (0xf << 12)]		;# Row Cycle Delay
set		AT91_SDRAMC_TRP		[expr (0xf << 16)]		;# Row Precharge Delay
set		AT91_SDRAMC_TRCD	[expr (0xf << 20)]		;# Row to Column Delay
set		AT91_SDRAMC_TRAS	[expr (0xf << 24)]		;# Active to Precharge Delay
set		AT91_SDRAMC_TXSR	[expr (0xf << 28)]		;# Exit Self Refresh to Active Delay

set AT91_SDRAMC_LPR		[expr ($AT91_SDRAMC + 0x10)]	;# SDRAM Controller Low Power Register
set		AT91_SDRAMC_LPCB		[expr (3 << 0)]	;# Low-power Configurations
set			AT91_SDRAMC_LPCB_DISABLE		0
set			AT91_SDRAMC_LPCB_SELF_REFRESH		1
set			AT91_SDRAMC_LPCB_POWER_DOWN		2
set			AT91_SDRAMC_LPCB_DEEP_POWER_DOWN	3
set		AT91_SDRAMC_PASR		[expr (7 << 4)]	;# Partial Array Self Refresh
set		AT91_SDRAMC_TCSR		[expr (3 << 8)]	;# Temperature Compensated Self Refresh
set		AT91_SDRAMC_DS			[expr (3 << 10)]	;# Drive Strength
set		AT91_SDRAMC_TIMEOUT		[expr (3 << 12)]	;# Time to define when Low Power Mode is enabled
set			AT91_SDRAMC_TIMEOUT_0_CLK_CYCLES	[expr (0 << 12)]
set			AT91_SDRAMC_TIMEOUT_64_CLK_CYCLES	[expr (1 << 12)]
set			AT91_SDRAMC_TIMEOUT_128_CLK_CYCLES	[expr (2 << 12)]

set AT91_SDRAMC_IER		[expr ($AT91_SDRAMC + 0x14)]	;# SDRAM Controller Interrupt Enable Register
set AT91_SDRAMC_IDR		[expr ($AT91_SDRAMC + 0x18)]	;# SDRAM Controller Interrupt Disable Register
set AT91_SDRAMC_IMR		[expr ($AT91_SDRAMC + 0x1C)]	;# SDRAM Controller Interrupt Mask Register
set AT91_SDRAMC_ISR		[expr ($AT91_SDRAMC + 0x20)]	;# SDRAM Controller Interrupt Status Register
set		AT91_SDRAMC_RES		[expr (1 << 0)]		;# Refresh Error Status

set AT91_SDRAMC_MDR		[expr ($AT91_SDRAMC + 0x24)]	;# SDRAM Memory Device Register
set		AT91_SDRAMC_MD		[expr (3 << 0)]		;# Memory Device Type
set			AT91_SDRAMC_MD_SDRAM		0
set			AT91_SDRAMC_MD_LOW_POWER_SDRAM	1
set		AT91_SMC_READMODE	[expr (1 <<  0)]		;# Read Mode
set		AT91_SMC_WRITEMODE	[expr (1 <<  1)]		;# Write Mode
set		AT91_SMC_EXNWMODE	[expr (3 <<  4)]		;# NWAIT Mode
set			AT91_SMC_EXNWMODE_DISABLE	[expr (0 << 4)]
set			AT91_SMC_EXNWMODE_FROZEN	[expr (2 << 4)]
set			AT91_SMC_EXNWMODE_READY		[expr (3 << 4)]
set		AT91_SMC_BAT		[expr (1 <<  8)]		;# Byte Access Type
set			AT91_SMC_BAT_SELECT		[expr (0 << 8)]
set			AT91_SMC_BAT_WRITE		[expr (1 << 8)]
set		AT91_SMC_DBW		[expr (3 << 12)]		;# Data Bus Width */
set			AT91_SMC_DBW_8			[expr (0 << 12)]
set			AT91_SMC_DBW_16			[expr (1 << 12)]
set			AT91_SMC_DBW_32			[expr (2 << 12)]
set		AT91_SMC_TDFMODE	[expr (1 << 20)]		;# TDF Optimization - Enabled
set		AT91_SMC_PMEN		[expr (1 << 24)]		;# Page Mode Enabled
set		AT91_SMC_PS		[expr (3 << 28)]		;# Page Size
set			AT91_SMC_PS_4			[expr (0 << 28)]
set			AT91_SMC_PS_8			[expr (1 << 28)]
set			AT91_SMC_PS_16			[expr (2 << 28)]
set			AT91_SMC_PS_32			[expr (3 << 28)]
# External Memory Map
set AT91_CHIPSELECT_0	0x10000000
set AT91_CHIPSELECT_1	0x20000000
set AT91_CHIPSELECT_2	0x30000000
set AT91_CHIPSELECT_3	0x40000000
set AT91_CHIPSELECT_4	0x50000000
set AT91_CHIPSELECT_5	0x60000000
set AT91_CHIPSELECT_6	0x70000000
set AT91_CHIPSELECT_7	0x80000000

if [info exists AT91C_MAINOSC_FREQ] {
    # user set this... let it be.
} {
    # 18.432mhz is a common thing...
    set AT91C_MAINOSC_FREQ 18432000
}
global AT91C_MAINOSC_FREQ

if [info exists AT91C_SLOWOSC_FREQ] {
    # user set this... let it be.
} {
    # 32khz is the norm
    set AT91C_SLOWOSC_FREQ 32768
}
global AT91C_SLOWOSC_FREQ

set RTTC_RTMR [expr $AT91C_BASE_RTTC + 0x00]
set RTTC_RTAR [expr $AT91C_BASE_RTTC + 0x04]
set RTTC_RTVR [expr $AT91C_BASE_RTTC + 0x08]
set RTTC_RTSR [expr $AT91C_BASE_RTTC + 0x0c]
global RTTC_RTMR
global RTTC_RTAR
global RTTC_RTVR
global RTTC_RTSR

proc show_RTTC_RTMR_helper { NAME ADDR VAL } {
    set rtpres [expr $VAL & 0x0ffff]
    global BIT16 BIT17
    if { $rtpres == 0 } {
	set rtpres 65536;
    }
    global AT91C_SLOWOSC_FREQ
    # Nasty hack, make this a float by tacking a .0 on the end
    # otherwise, jim makes the value an integer
    set f [expr $AT91C_SLOWOSC_FREQ.0 / $rtpres.0]
    echo [format "\tPrescale value: 0x%04x (%5d) => %f Hz" $rtpres $rtpres $f]
    if { $VAL & $BIT16 } {
	echo "\tBit16 -> Alarm IRQ Enabled"
    } else {
	echo "\tBit16 -> Alarm IRQ Disabled"
    }
    if { $VAL & $BIT17 } {
	echo "\tBit17 -> RTC Inc IRQ Enabled"
    } else {
	echo "\tBit17 -> RTC Inc IRQ Disabled"
    }
    # Bit 18 is write only.
}

proc show_RTTC_RTSR_helper { NAME ADDR VAL } {
    global BIT0 BIT1
    if { $VAL & $BIT0 } {
	echo "\tBit0 -> ALARM PENDING"
    } else {
	echo "\tBit0 -> alarm not pending"
    }
    if { $VAL & $BIT1 } {
	echo "\tBit0 -> RTINC PENDING"
    } else {
	echo "\tBit0 -> rtinc not pending"
    }
}

proc show_RTTC { } {

    show_mmr32_reg RTTC_RTMR
    show_mmr32_reg RTTC_RTAR
    show_mmr32_reg RTTC_RTVR
    show_mmr32_reg RTTC_RTSR
}
# Setup register
#
# ncs_read_setup
# nrd_setup
# ncs_write_setup
# set nwe_setup
#
#
# Pulse register
#
# ncs_read_pulse
# nrd_pulse
# ncs_write_pulse
# nwe_pulse
#
#
# Cycle register
#
# read_cycle 0
# write_cycle 0
#
#
# Mode register
#
# mode
# tdf_cycles
proc sam9_smc_config { cs smc_config } {
	;# Setup Register for CS n
	set AT91_SMC_SETUP [expr ($::AT91_SMC + 0x00 + ((cs)*0x10))]
	set val [expr ($smc_config(nwe_setup) << 0)]
	set val [expr ($val | $smc_config(ncs_write_setup) << 8]
	set val [expr ($val | $smc_config(nrd_setup)) << 16]
	set val [expr ($val | $smc_config(ncs_read_setup) << 24]
	mww $AT91_SMC_SETUP $val

	;# Pulse Register for CS n
	set AT91_SMC_PULSE [expr ($::AT91_SMC + 0x04 + ((cs)*0x10))]
	set val [expr ($smc_config(nwe_pulse) << 0)]
	set val [expr ($val | $smc_config(ncs_write_pulse) << 8]
	set val [expr ($val | $smc_config(nrd_pulse) << 16]
	set val [expr ($val | $smc_config(ncs_read_pulse) << 24]
	mww $AT91_SMC_PULSE $val

	;# Cycle Register for CS n
	set AT91_SMC_CYCLE [expr ($::AT91_SMC + 0x08 + ((cs)*0x10))]
	set val [expr ($smc_config(write_cycle) << 0)]
	set val [expr ($val | $smc_config(read_cycle) << 16]
	mww $AT91_SMC_CYCLE $val

	;# Mode Register for CS n
	set AT91_SMC_MODE [expr ($::AT91_SMC + 0x0c + ((cs)*0x10))]
	set val [expr ($smc_config(mode) << 0)]
	set val [expr ($val | $smc_config(tdf_cycles) << 16]
	mww $AT91_SMC_MODE $val
}
# the DBGU and USARTs are 'almost' indentical'
set DBGU_CR         [expr $AT91C_BASE_DBGU + 0x00000000]
set DBGU_MR         [expr $AT91C_BASE_DBGU + 0x00000004]
set DBGU_IER        [expr $AT91C_BASE_DBGU + 0x00000008]
set DBGU_IDR        [expr $AT91C_BASE_DBGU + 0x0000000C]
set DBGU_IMR        [expr $AT91C_BASE_DBGU + 0x00000010]
set DBGU_CSR        [expr $AT91C_BASE_DBGU + 0x00000014]
set DBGU_RHR        [expr $AT91C_BASE_DBGU + 0x00000018]
set DBGU_THR        [expr $AT91C_BASE_DBGU + 0x0000001C]
set DBGU_BRGR       [expr $AT91C_BASE_DBGU + 0x00000020]
# no RTOR
# no TTGR
# no FIDI
# no NER
set DBGU_CIDR       [expr $AT91C_BASE_DBGU + 0x00000040]
set DBGU_EXID       [expr $AT91C_BASE_DBGU + 0x00000044]
set DBGU_FNTR       [expr $AT91C_BASE_DBGU + 0x00000048]


set USx_CR           0x00000000
set USx_MR           0x00000004
set USx_IER          0x00000008
set USx_IDR          0x0000000C
set USx_IMR          0x00000010
set USx_CSR          0x00000014
set USx_RHR          0x00000018
set USx_THR          0x0000001C
set USx_BRGR         0x00000020
set USx_RTOR         0x00000024
set USx_TTGR         0x00000028
set USx_FIDI         0x00000040
set USx_NER          0x00000044
set USx_IF           0x0000004C

# Create all the uarts that exist..
# we blow up if there are >9


proc show_mmr_USx_MR_helper { NAME ADDR VAL } {
    # First - just print it

    set x [show_normalize_bitfield $VAL 3 0]
    if { $x == 0 } {
	echo "\tNormal operation"
    } else {
	echo [format "\tNon Normal operation mode: 0x%02x" $x]
    }

    set x [show_normalize_bitfield $VAL 11 9]
    set s "unknown"
    switch -exact $x {
	0 { set s "Even" }
	1 { set s "Odd" }
	2 { set s "Force=0" }
	3 { set s "Force=1" }
	* {
	    set $x [expr $x & 6]
	    switch -exact $x {
		4 { set s "None" }
		6 { set s "Multidrop Mode" }
	    }
	}
    }
    echo [format "\tParity: %s " $s]

    set x [expr 5 + [show_normalize_bitfield $VAL 7 6]]
    echo [format "\tDatabits: %d" $x]

    set x [show_normalize_bitfield $VAL 13 12]
    switch -exact $x {
	0 { echo "\tStop bits: 1" }
	1 { echo "\tStop bits: 1.5" }
	2 { echo "\tStop bits: 2" }
	3 { echo "\tStop bits: Illegal/Reserved" }
    }
}

# For every possbile usart...
foreach WHO { US0 US1 US2 US3 US4 US5 US6 US7 US8 US9 } {
    set n AT91C_BASE_[set WHO]
    set str ""

    # Only if it exists on the chip
    if [ info exists $n ] {
	# Hence: $n - is like AT91C_BASE_USx
	# For every sub-register
	foreach REG {CR MR IER IDR IMR CSR RHR THR BRGR RTOR TTGR FIDI NER IF}	{
	    # vn = variable name
	    set vn [set WHO]_[set REG]
	    # vn = USx_IER
	    # vv = variable value
	    set vv [expr $$n + [set USx_[set REG]]]
	    # And VV is the address in memory of that register


	    # make that VN a GLOBAL so others can find it
	    global $vn
	    set $vn $vv

	    # Create a command for this specific register.
	    proc show_$vn { } "show_mmr32_reg $vn"

	    # Add this command to the Device(as a whole) command
	    set str "$str\nshow_$vn"
	}
	# Now - create the DEVICE(as a whole) command
	set fn show_$WHO
	proc $fn { } $str
    }
}

# The Debug Uart is special..
set str ""


# For every sub-register
foreach REG {DBGU_CR DBGU_MR DBGU_IER DBGU_IDR DBGU_IMR
    DBGU_CSR DBGU_RHR DBGU_THR DBGU_BRGR DBGU_CIDR DBGU_EXID DBGU_FNTR} {

    # Create a command for this specific register.
    proc show_$REG { } "show_mmr32_reg $REG"

    # Add this command to the Device(as a whole) command
    set str "$str\nshow_$REG"
}

# Now - create the DEVICE(as a whole) command
proc show_DBGU { } $str

unset str

proc show_DBGU_MR_helper { NAME ADDR VAL } { show_mmr_USx_MR_helper $NAME $ADDR $VAL }
# Quirks to bypass missing SRST on JTAG connector
# EVALSPEAr310 Rev. 2.0
# http://www.st.com/spear
#
# Date:      2010-08-17
# Author:    Antonio Borneo <borneo.antonio@gmail.com>

# For boards that have JTAG SRST not connected.
# We use "arm9 vector_catch reset" to catch button reset event.


$_TARGETNAME configure -event reset-assert sp_reset_assert
$_TARGETNAME configure -event reset-deassert-post sp_reset_deassert_post

# keeps the name of the SPEAr target
global sp_target_name
set sp_target_name $_TARGETNAME

# Keeps the argument of "reset" command (run, init, halt).
global sp_reset_mode
set sp_reset_mode ""

# Helper procedure. Returns 0 is target is halted.
proc sp_is_halted {} {
	global sp_target_name

	return [expr [string compare [$sp_target_name curstate] "halted" ] == 0]
}

# wait for reset button to be pressed, causing CPU to get halted
proc sp_reset_deassert_post {} {
	global sp_reset_mode

	set bar(0) |
	set bar(1) /
	set bar(2) -
	set bar(3) \\

	poll on
	echo "====> Press reset button on the board <===="
	for {set i 0} { [sp_is_halted] == 0 } { set i [expr $i + 1]} {
		echo -n "$bar([expr $i & 3])\r"
		sleep 200
	}

	# Remove catch reset event
	arm9 vector_catch none

	# CPU is halted, but we typed "reset run" ...
	if { [string compare $sp_reset_mode "run"] == 0 } {
		resume
	}
}

# Override reset-assert, since no SRST available
# Catch reset event
proc sp_reset_assert {} {
	arm9 vector_catch reset
}

# Override default init_reset{mode} to catch parameter "mode"
proc init_reset {mode} {
	global sp_reset_mode

	set sp_reset_mode $mode

	# We need to detect CPU get halted, so exit from halt
	if { [sp_is_halted] } {
		echo "Resuming CPU to detect reset"
		resume
	}

	# Execute default init_reset{mode}
	jtag arp_init-reset
}
# Generic init scripts for all ST SPEAr3xx family
# http://www.st.com/spear
#
# Date:      2010-09-23
# Author:    Antonio Borneo <borneo.antonio@gmail.com>


# Initialize internal clock
# Default:
# - Crystal =  24 MHz
# - PLL1    = 332 MHz
# - PLL2    = 332 MHz
# - CPU_CLK = 332 MHz
# - DDR_CLK = 332 MHz async
# - HCLK    = 166 MHz
# - PCLK    =  83 MHz
proc sp3xx_clock_default {} {
	mww 0xfca00000 0x00000002	;# set sysclk slow
	mww 0xfca00014 0x0ffffff8	;# set pll timeout to minimum (100us ?!?)

	# DDRCORE disable to change frequency
	set val [expr ([mrw 0xfca8002c] & ~0x20000000) | 0x40000000]
	mww 0xfca8002c $val
	mww 0xfca8002c $val ;# Yes, write twice!

	# programming PLL1
	mww 0xfca8000c 0xa600010c	;# M=166 P=1 N=12
	mww 0xfca80008 0x00001c0a	;# power down
	mww 0xfca80008 0x00001c0e	;# enable
	mww 0xfca80008 0x00001c06	;# strobe
	mww 0xfca80008 0x00001c0e
	while { [expr [mrw 0xfca80008] & 0x01] == 0x00 } { sleep 1 }

	# programming PLL2
	mww 0xfca80018 0xa600010c	;# M=166, P=1, N=12
	mww 0xfca80014 0x00001c0a	;# power down
	mww 0xfca80014 0x00001c0e	;# enable
	mww 0xfca80014 0x00001c06	;# strobe
	mww 0xfca80014 0x00001c0e
	while { [expr [mrw 0xfca80014] & 0x01] == 0x00 } { sleep 1 }

	mww 0xfca80028 0x00000082	;# enable plltimeen
	mww 0xfca80024 0x00000511	;# set hclkdiv="/2" & pclkdiv="/2"

	mww 0xfca00000 0x00000004	;# setting SYSCTL to NORMAL mode
	while { [expr [mrw 0xfca00000] & 0x20] != 0x20 } { sleep 1 }

	# Select source of DDR clock
	#mmw 0xfca80020 0x10000000 0x70000000 ;# PLL1
	mmw 0xfca80020 0x30000000 0x70000000 ;# PLL2

	# DDRCORE enable after change frequency
	mmw 0xfca8002c 0x20000000 0x00000000
}

proc sp3xx_common_init {} {
	mww 0xfca8002c 0xfffffff8	;# enable clock of all peripherals
	mww 0xfca80038 0x00000000	;# remove reset of all peripherals

	mww 0xfca80034 0x0000ffff	;# enable all RAS clocks
	mww 0xfca80040 0x00000000	;# remove all RAS resets

	mww 0xfca800e4 0x78000008	;# COMP1V8_REG
	mww 0xfca800ec 0x78000008	;# COMP3V3_REG

	mww 0xfc000000 0x10000f5f	;# init SMI and set HW mode
	mww 0xfc000000 0x00000f5f

	# Initialize Bus Interconnection Matrix
	# All ports Round-Robin and lowest priority
	mww 0xfca8007c 0x80000007
	mww 0xfca80080 0x80000007
	mww 0xfca80084 0x80000007
	mww 0xfca80088 0x80000007
	mww 0xfca8008c 0x80000007
	mww 0xfca80090 0x80000007
	mww 0xfca80094 0x80000007
	mww 0xfca80098 0x80000007
	mww 0xfca8009c 0x80000007
}


# Specific init scripts for ST SPEAr300
proc sp300_init {} {
	mww 0x99000000 0x00003fff	;# RAS function enable
}


# Specific init scripts for ST SPEAr310
proc sp310_init {} {
	mww 0xb4000008 0x00002ff4	;# RAS function enable

	mww 0xfca80050 0x00000001	;# Enable clk mem port 1

	mww 0xfca8013c 0x2f7bc210	;# plgpio_pad_drv
	mww 0xfca80140 0x017bdef6
}

proc sp310_emi_init {} {
	# set EMI pad strength
	mmw 0xfca80134 0x0e000000 0x00000000
	mmw 0xfca80138 0x0e739ce7 0x00000000
	mmw 0xfca8013c 0x00039ce7 0x00000000

	# set safe EMI timing as in BootROM
	#mww 0x4f000000 0x0000000f	;# tAP_0_reg
	#mww 0x4f000004 0x00000000	;# tSDP_0_reg
	#mww 0x4f000008 0x000000ff	;# tDPw_0_reg
	#mww 0x4f00000c 0x00000111	;# tDPr_0_reg
	#mww 0x4f000010 0x00000002	;# tDCS_0_reg

	# set fast EMI timing as in Linux
	mww 0x4f000000 0x00000010	;# tAP_0_reg
	mww 0x4f000004 0x00000005	;# tSDP_0_reg
	mww 0x4f000008 0x0000000a	;# tDPw_0_reg
	mww 0x4f00000c 0x0000000a	;# tDPr_0_reg
	mww 0x4f000010 0x00000005	;# tDCS_0_re

	# 32bit wide, 8/16/32bit access
	mww 0x4f000014 0x0000000e	;# control_0_reg
	mww 0x4f000094 0x0000003f	;# ack_reg
}


# Specific init scripts for ST SPEAr320
proc sp320_init {} {
	mww 0xb300000c 0xffffac04	;# RAS function enable
	mww 0xb3000010 0x00000001	;# RAS mode select
}
# Init scripts to configure DDR controller of SPEAr3xx
# http://www.st.com/spear
# Original values taken from XLoader source code
#
# Date:      2010-09-23
# Author:    Antonio Borneo <borneo.antonio@gmail.com>


proc sp3xx_ddr_init {ddr_type {ddr_chips 1}} {
	if { $ddr_chips != 1 && $ddr_chips != 2 } {
		error "Only 1 or 2 DDR chips permitted. Wrong value "$ddr_chips
	}

	if { $ddr_type == "mt47h64m16_3_333_cl5_async" } {
		ddr_spr3xx_mt47h64m16_3_333_cl5_async $ddr_chips
		set ddr_size 0x08000000
	## add here new DDR chip definition. Prototype:
	#} elseif { $ddr_type == "?????" } {
	#	????? $ddr_chips
	#	set ddr_size 0x?????
	} else {
		error "sp3xx_ddr_init: unrecognized DDR type "$ddr_type
	}

	# MPMC START
	mww 0xfc60001c 0x01000100

	if { $ddr_chips == 2 } {
		echo [format \
			"Double chip DDR memory. Total memory size 0x%08x byte" \
			[expr 2 * $ddr_size]]
	} else {
		echo [format \
			"Single chip DDR memory. Memory size 0x%08x byte" \
			$ddr_size]
	}
}


# from Xloader file ddr/spr300_mt47h64m16_3_333_cl5_async.S
proc ddr_spr3xx_mt47h64m16_3_333_cl5_async {ddr_chips} {
	# DDR_PAD_REG
	mww 0xfca800f0 0x00003aa5

	# Use "1:2 sync" only when DDR clock source is PLL1 and
	# HCLK is half of PLL1
	mww 0xfc600000 0x00000001	;# MEMCTL_AHB_SET_00 # This is async
	mww 0xfc600004 0x00000000	;# MEMCTL_AHB_SET_01
#	mww 0xfc600000 0x02020201	;# MEMCTL_AHB_SET_00 # This is 1:2 sync
#	mww 0xfc600004 0x02020202	;# MEMCTL_AHB_SET_01

	mww 0xfc600008 0x01000000	;# MEMCTL_RFSH_SET_00
	mww 0xfc60000c 0x00000101	;# MEMCTL_DLL_SET_00
	mww 0xfc600010 0x00000101	;# MEMCTL_GP_00
	mww 0xfc600014 0x01000000	;# MEMCTL_GP_01
	mww 0xfc600018 0x00010001	;# MEMCTL_GP_02
	mww 0xfc60001c 0x00000100	;# MEMCTL_GP_03
	mww 0xfc600020 0x00010001	;# MEMCTL_GP_04
	if { $ddr_chips == 2 } {
		mww 0xfc600024 0x01020203	;# MEMCTL_GP_05
		mww 0xfc600028 0x01000102	;# MEMCTL_GP_06
		mww 0xfc60002c 0x02000202	;# MEMCTL_AHB_SET_02
	} else {
		mww 0xfc600024 0x00000201	;# MEMCTL_GP_05
		mww 0xfc600028 0x02000001	;# MEMCTL_GP_06
		mww 0xfc60002c 0x02000201	;# MEMCTL_AHB_SET_02
	}
	mww 0xfc600030 0x04040105	;# MEMCTL_AHB_SET_03
	mww 0xfc600034 0x03030302	;# MEMCTL_AHB_SET_04
	mww 0xfc600038 0x02040101	;# MEMCTL_AHB_SET_05
	mww 0xfc60003c 0x00000002	;# MEMCTL_AHB_SET_06
	mww 0xfc600044 0x03000405	;# MEMCTL_DQS_SET_0
	mww 0xfc600048 0x03040002	;# MEMCTL_TIME_SET_01
	mww 0xfc60004c 0x04000305	;# MEMCTL_TIME_SET_02
	mww 0xfc600050 0x0505053f	;# MEMCTL_AHB_RELPR_00
	mww 0xfc600054 0x05050505	;# MEMCTL_AHB_RELPR_01
	mww 0xfc600058 0x04040405	;# MEMCTL_AHB_RELPR_02
	mww 0xfc60005c 0x04040404	;# MEMCTL_AHB_RELPR_03
	mww 0xfc600060 0x03030304	;# MEMCTL_AHB_RELPR_04
	mww 0xfc600064 0x03030303	;# MEMCTL_AHB_RELPR_05
	mww 0xfc600068 0x02020203	;# MEMCTL_AHB_RELPR_06
	mww 0xfc60006c 0x02020202	;# MEMCTL_AHB_RELPR_07
	mww 0xfc600070 0x01010102	;# MEMCTL_AHB_RELPR_08
	mww 0xfc600074 0x01010101	;# MEMCTL_AHB_RELPR_09
	mww 0xfc600078 0x00000001	;# MEMCTL_AHB_RELPR_10
	mww 0xfc600088 0x0a0c0a00	;# MEMCTL_DQS_SET_1
	mww 0xfc60008c 0x0000023f	;# MEMCTL_GP_07
	mww 0xfc600090 0x00050a00	;# MEMCTL_GP_08
	mww 0xfc600094 0x11000000	;# MEMCTL_GP_09
	mww 0xfc600098 0x00001302	;# MEMCTL_GP_10
	mww 0xfc60009c 0x00001c1c	;# MEMCTL_DLL_SET_01
	mww 0xfc6000a0 0x7c000000	;# MEMCTL_DQS_OUT_SHIFT
	mww 0xfc6000a4 0x005c0000	;# MEMCTL_WR_DQS_SHIFT
	mww 0xfc6000a8 0x2b050e00	;# MEMCTL_TIME_SET_03
	mww 0xfc6000ac 0x00640064	;# MEMCTL_AHB_PRRLX_00
	mww 0xfc6000b0 0x00640064	;# MEMCTL_AHB_PRRLX_01
	mww 0xfc6000b4 0x00000064	;# MEMCTL_AHB_PRRLX_02
	mww 0xfc6000b8 0x00000000	;# MEMCTL_OUTRANGE_LGTH
	mww 0xfc6000bc 0x00200020	;# MEMCTL_AHB_RW_SET_00
	mww 0xfc6000c0 0x00200020	;# MEMCTL_AHB_RW_SET_01
	mww 0xfc6000c4 0x00200020	;# MEMCTL_AHB_RW_SET_02
	mww 0xfc6000c8 0x00200020	;# MEMCTL_AHB_RW_SET_03
	mww 0xfc6000cc 0x00200020	;# MEMCTL_AHB_RW_SET_04
	mww 0xfc6000d8 0x00000a24	;# MEMCTL_TREF
	mww 0xfc6000dc 0x00000000	;# MEMCTL_EMRS3_DATA
	mww 0xfc6000e0 0x5b1c00c8	;# MEMCTL_TIME_SET_04
	mww 0xfc6000e4 0x00c8002e	;# MEMCTL_TIME_SET_05
	mww 0xfc6000e8 0x00000000	;# MEMCTL_VERSION
	mww 0xfc6000ec 0x0001046b	;# MEMCTL_TINIT
	mww 0xfc6000f0 0x00000000	;# MEMCTL_OUTRANGE_ADDR_01
	mww 0xfc6000f4 0x00000000	;# MEMCTL_OUTRANGE_ADDR_02
	mww 0xfc600104 0x001c0000	;# MEMCTL_DLL_DQS_DELAY_BYPASS_0
	mww 0xfc600108 0x0019001c	;# MEMCTL_DLL_SET_02
	mww 0xfc60010c 0x00100000	;# MEMCTL_DLL_SET_03
	mww 0xfc600110 0x001e007a	;# MEMCTL_DQS_SET_2
	mww 0xfc600188 0x00000000	;# MEMCTL_USER_DEF_REG_0
	mww 0xfc60018c 0x00000000	;# MEMCTL_USER_DEF_REG_1
	mww 0xfc600190 0x01010001	;# MEMCTL_GP_11
	mww 0xfc600194 0x01000000	;# MEMCTL_GP_12
	mww 0xfc600198 0x00000001	;# MEMCTL_GP_13
	mww 0xfc60019c 0x00400000	;# MEMCTL_GP_14
	mww 0xfc6001a0 0x00000000	;# MEMCTL_EMRS2_DATA_X
	mww 0xfc6001a4 0x00000000	;# MEMCTL_LWPWR_CNT
	mww 0xfc6001a8 0x00000000	;# MEMCTL_LWPWR_REG
	mww 0xfc6001ac 0x00860000	;# MEMCTL_GP_15
	mww 0xfc6001b0 0x00000002	;# MEMCTL_TPDEX
}
source [find bitsbytes.tcl]
source [find cpu/arm/cortex_m3.tcl]
source [find memory.tcl]
source [find mmr_helpers.tcl]

source [find chip/st/stm32/stm32_regs.tcl]
source [find chip/st/stm32/stm32_rcc.tcl]

set RCC_CR            [expr $RCC_BASE + 0x00]
set RCC_CFGR          [expr $RCC_BASE + 0x04]
set RCC_CIR           [expr $RCC_BASE + 0x08]
set RCC_APB2RSTR      [expr $RCC_BASE + 0x0c]
set RCC_APB1RSTR      [expr $RCC_BASE + 0x10]
set RCC_AHBENR        [expr $RCC_BASE + 0x14]
set RCC_APB2ENR       [expr $RCC_BASE + 0x18]
set RCC_APB1ENR       [expr $RCC_BASE + 0x1c]
set RCC_BDCR          [expr $RCC_BASE + 0x20]
set RCC_CSR           [expr $RCC_BASE + 0x24]


proc show_RCC_CR { } {
    if [ catch { set val [show_mmr32_reg RCC_CR] } msg ] {
	error $msg
    }

    show_mmr_bitfield  0  0 $val HSI      { OFF ON }
    show_mmr_bitfield  1  1 $val HSIRDY   { NOTRDY RDY  }
    show_mmr_bitfield  7  3 $val HSITRIM  { _NUMBER_ }
    show_mmr_bitfield 15  8 $val HSICAL   { _NUMBER_ }
    show_mmr_bitfield 16 16 $val HSEON    { OFF ON }
    show_mmr_bitfield 17 17 $val HSERDY   { NOTRDY RDY  }
    show_mmr_bitfield 18 18 $val HSEBYP   { NOTBYPASSED BYPASSED }
    show_mmr_bitfield 19 19 $val CSSON    { OFF ON }
    show_mmr_bitfield 24 24 $val PLLON    { OFF ON }
    show_mmr_bitfield 25 25 $val PLLRDY   { NOTRDY RDY }
}

proc show_RCC_CFGR { } {
    if [ catch { set val [show_mmr32_reg RCC_CFGR] } msg ] {
	error $msg
    }


    show_mmr_bitfield  1  0 $val  SW     { HSI HSE PLL ILLEGAL }
    show_mmr_bitfield  3  2 $val  SWS    { HSI HSE PLL ILLEGAL }
    show_mmr_bitfield  7  4 $val  HPRE   { sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_1 sysclk_div_2 sysclk_div_4 sysclk_div_8 sysclk_div_16 sysclk_div_64 sysclk_div_128 sysclk_div_256 sysclk_div_512 }
    show_mmr_bitfield 10  8 $val  PPRE1  { hclk_div1 hclk_div1 hclk_div1 hclk_div1 hclk_div2 hclk_div4 hclk_div8 hclk_div16 }
    show_mmr_bitfield 13 11 $val  PPRE2  { hclk_div1 hclk_div1 hclk_div1 hclk_div1 hclk_div2 hclk_div4 hclk_div8 hclk_div16 }
    show_mmr_bitfield 15 14 $val  ADCPRE { pclk2_div1 pclk2_div1 pclk2_div1 pclk2_div1 pclk2_div2 pclk2_div4 pclk2_div8 pclk2_div16 }
    show_mmr_bitfield 16 16 $val  PLLSRC { HSI_div_2 HSE }
    show_mmr_bitfield 17 17 $val  PLLXTPRE { hse_div1 hse_div2 }
    show_mmr_bitfield 21 18 $val  PLLMUL { x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x16 }
    show_mmr_bitfield 22 22 $val  USBPRE { div1 div1_5 }
    show_mmr_bitfield 26 24 $val  MCO    { none none none none SysClk HSI HSE PLL_div2 }
}


proc show_RCC_CIR { } {
    if [ catch { set val [show_mmr32_reg RCC_CIR] } msg ] {
	error $msg
    }

}

proc show_RCC_APB2RSTR { } {
    if [ catch { set val [ show_mmr32_reg RCC_APB2RSTR] } msg ] {
	error $msg
    }
    for { set x 0 } { $x < 32 } { incr x } {
	set bits($x) xxx
    }
    set bits(15) adc3
    set bits(14) usart1
    set bits(13) tim8
    set bits(12) spi1
    set bits(11) tim1
    set bits(10) adc2
    set bits(9) adc1
    set bits(8) iopg
    set bits(7) iopf
    set bits(6) iope
    set bits(5) iopd
    set bits(4) iopc
    set bits(3) iopb
    set bits(2) iopa
    set bits(1) xxx
    set bits(0) afio
    show_mmr32_bits bits $val
}

proc show_RCC_APB1RSTR { } {
    if [ catch { set val [ show_mmr32_reg RCC_APB1RSTR] } msg ] {
	error $msg
    }
    set bits(31) xxx
    set bits(30) xxx
    set bits(29) dac
    set bits(28) pwr
    set bits(27) bkp
    set bits(26) xxx
    set bits(25) can
    set bits(24) xxx
    set bits(23) usb
    set bits(22) i2c2
    set bits(21) i2c1
    set bits(20) uart5
    set bits(19) uart4
    set bits(18) uart3
    set bits(17) uart2
    set bits(16) xxx
    set bits(15) spi3
    set bits(14) spi2
    set bits(13) xxx
    set bits(12) xxx
    set bits(11) wwdg
    set bits(10) xxx
    set bits(9) xxx
    set bits(8) xxx
    set bits(7) xxx
    set bits(6) xxx
    set bits(5) tim7
    set bits(4) tim6
    set bits(3) tim5
    set bits(2) tim4
    set bits(1) tim3
    set bits(0) tim2
    show_mmr32_bits bits $val

}

proc show_RCC_AHBENR   { } {
    if [ catch { set val [ show_mmr32_reg RCC_AHBENR  ] } msg ] {
	error $msg
    }
    set bits(31) xxx
    set bits(30) xxx
    set bits(29) xxx
    set bits(28) xxx
    set bits(27) xxx
    set bits(26) xxx
    set bits(25) xxx
    set bits(24) xxx
    set bits(23) xxx
    set bits(22) xxx
    set bits(21) xxx
    set bits(20) xxx
    set bits(19) xxx
    set bits(18) xxx
    set bits(17) xxx
    set bits(16) xxx
    set bits(15) xxx
    set bits(14) xxx
    set bits(13) xxx
    set bits(12) xxx
    set bits(11) xxx
    set bits(10) sdio
    set bits(9) xxx
    set bits(8) fsmc
    set bits(7) xxx
    set bits(6) crce
    set bits(5) xxx
    set bits(4) flitf
    set bits(3) xxx
    set bits(2) sram
    set bits(1) dma2
    set bits(0) dma1
    show_mmr32_bits bits $val
}

proc show_RCC_APB2ENR  { } {
    if [ catch { set val [ show_mmr32_reg RCC_APB2ENR ] } msg ] {
	error $msg
    }
    set bits(31) xxx
    set bits(30) xxx
    set bits(29) xxx
    set bits(28) xxx
    set bits(27) xxx
    set bits(26) xxx
    set bits(25) xxx
    set bits(24) xxx
    set bits(23) xxx
    set bits(22) xxx
    set bits(21) xxx
    set bits(20) xxx
    set bits(19) xxx
    set bits(18) xxx
    set bits(17) xxx
    set bits(16) xxx
    set bits(15) adc3
    set bits(14) usart1
    set bits(13) tim8
    set bits(12) spi1
    set bits(11) tim1
    set bits(10) adc2
    set bits(9) adc1
    set bits(8) iopg
    set bits(7) iopf
    set bits(6) iope
    set bits(5) iopd
    set bits(4) iopc
    set bits(3) iopb
    set bits(2) iopa
    set bits(1) xxx
    set bits(0) afio
    show_mmr32_bits bits $val

}

proc show_RCC_APB1ENR  { } {
    if [ catch { set val [ show_mmr32_reg RCC_APB1ENR ] } msg ] {
	error $msg
    }
    set bits(31) xxx
    set bits(30) xxx
    set bits(29) dac
    set bits(28) pwr
    set bits(27) bkp
    set bits(26) xxx
    set bits(25) can
    set bits(24) xxx
    set bits(23) usb
    set bits(22) i2c2
    set bits(21) i2c1
    set bits(20) usart5
    set bits(19) usart4
    set bits(18) usart3
    set bits(17) usart2
    set bits(16) xxx
    set bits(15) spi3
    set bits(14) spi2
    set bits(13) xxx
    set bits(12) xxx
    set bits(11) wwdg
    set bits(10) xxx
    set bits(9) xxx
    set bits(8) xxx
    set bits(7) xxx
    set bits(6) xxx
    set bits(5) tim7
    set bits(4) tim6
    set bits(3) tim5
    set bits(2) tim4
    set bits(1) tim3
    set bits(0) tim2
    show_mmr32_bits bits $val
}

proc show_RCC_BDCR     { } {
    if [ catch { set val [ show_mmr32_reg RCC_BDCR    ] } msg ] {
	error $msg
    }
    for { set x 0 } { $x < 32 } { incr x } {
	set bits($x) xxx
    }
    set bits(0) lseon
    set bits(1) lserdy
    set bits(2) lsebyp
    set bits(8) rtcsel0
    set bits(9) rtcsel1
    set bits(15) rtcen
    set bits(16) bdrst
    show_mmr32_bits bits $val
}

proc show_RCC_CSR      { } {
    if [ catch { set val [ show_mmr32_reg RCC_CSR     ] } msg ] {
	error $msg
    }
    for { set x 0 } { $x < 32 } { incr x } {
	set bits($x) xxx
    }
    set bits(0) lsion
    set bits(1) lsirdy
    set bits(24) rmvf
    set bits(26) pin
    set bits(27) por
    set bits(28) sft
    set bits(29) iwdg
    set bits(30) wwdg
    set bits(31) lpwr
    show_mmr32_bits bits $val
}

proc show_RCC { } {

    show_RCC_CR
    show_RCC_CFGR
    show_RCC_CIR
    show_RCC_APB2RSTR
    show_RCC_APB1RSTR
    show_RCC_AHBENR
    show_RCC_APB2ENR
    show_RCC_APB1ENR
    show_RCC_BDCR
    show_RCC_CSR
}
# /* Peripheral and SRAM base address in the alias region */
set PERIPH_BB_BASE        0x42000000
set SRAM_BB_BASE          0x22000000

# /*Peripheral and SRAM base address in the bit-band region */
set SRAM_BASE             0x20000000
set PERIPH_BASE           0x40000000

# /*FSMC registers base address */
set FSMC_R_BASE           0xA0000000

# /*Peripheral memory map */
set APB1PERIPH_BASE       [set PERIPH_BASE]
set APB2PERIPH_BASE       [expr $PERIPH_BASE + 0x10000]
set AHBPERIPH_BASE        [expr $PERIPH_BASE + 0x20000]

set TIM2_BASE             [expr $APB1PERIPH_BASE + 0x0000]
set TIM3_BASE             [expr $APB1PERIPH_BASE + 0x0400]
set TIM4_BASE             [expr $APB1PERIPH_BASE + 0x0800]
set TIM5_BASE             [expr $APB1PERIPH_BASE + 0x0C00]
set TIM6_BASE             [expr $APB1PERIPH_BASE + 0x1000]
set TIM7_BASE             [expr $APB1PERIPH_BASE + 0x1400]
set RTC_BASE              [expr $APB1PERIPH_BASE + 0x2800]
set WWDG_BASE             [expr $APB1PERIPH_BASE + 0x2C00]
set IWDG_BASE             [expr $APB1PERIPH_BASE + 0x3000]
set SPI2_BASE             [expr $APB1PERIPH_BASE + 0x3800]
set SPI3_BASE             [expr $APB1PERIPH_BASE + 0x3C00]
set USART2_BASE           [expr $APB1PERIPH_BASE + 0x4400]
set USART3_BASE           [expr $APB1PERIPH_BASE + 0x4800]
set UART4_BASE            [expr $APB1PERIPH_BASE + 0x4C00]
set UART5_BASE            [expr $APB1PERIPH_BASE + 0x5000]
set I2C1_BASE             [expr $APB1PERIPH_BASE + 0x5400]
set I2C2_BASE             [expr $APB1PERIPH_BASE + 0x5800]
set CAN_BASE              [expr $APB1PERIPH_BASE + 0x6400]
set BKP_BASE              [expr $APB1PERIPH_BASE + 0x6C00]
set PWR_BASE              [expr $APB1PERIPH_BASE + 0x7000]
set DAC_BASE              [expr $APB1PERIPH_BASE + 0x7400]

set AFIO_BASE             [expr $APB2PERIPH_BASE + 0x0000]
set EXTI_BASE             [expr $APB2PERIPH_BASE + 0x0400]
set GPIOA_BASE            [expr $APB2PERIPH_BASE + 0x0800]
set GPIOB_BASE            [expr $APB2PERIPH_BASE + 0x0C00]
set GPIOC_BASE            [expr $APB2PERIPH_BASE + 0x1000]
set GPIOD_BASE            [expr $APB2PERIPH_BASE + 0x1400]
set GPIOE_BASE            [expr $APB2PERIPH_BASE + 0x1800]
set GPIOF_BASE            [expr $APB2PERIPH_BASE + 0x1C00]
set GPIOG_BASE            [expr $APB2PERIPH_BASE + 0x2000]
set ADC1_BASE             [expr $APB2PERIPH_BASE + 0x2400]
set ADC2_BASE             [expr $APB2PERIPH_BASE + 0x2800]
set TIM1_BASE             [expr $APB2PERIPH_BASE + 0x2C00]
set SPI1_BASE             [expr $APB2PERIPH_BASE + 0x3000]
set TIM8_BASE             [expr $APB2PERIPH_BASE + 0x3400]
set USART1_BASE           [expr $APB2PERIPH_BASE + 0x3800]
set ADC3_BASE             [expr $APB2PERIPH_BASE + 0x3C00]

set SDIO_BASE             [expr $PERIPH_BASE + 0x18000]

set DMA1_BASE             [expr $AHBPERIPH_BASE + 0x0000]
set DMA1_Channel1_BASE    [expr $AHBPERIPH_BASE + 0x0008]
set DMA1_Channel2_BASE    [expr $AHBPERIPH_BASE + 0x001C]
set DMA1_Channel3_BASE    [expr $AHBPERIPH_BASE + 0x0030]
set DMA1_Channel4_BASE    [expr $AHBPERIPH_BASE + 0x0044]
set DMA1_Channel5_BASE    [expr $AHBPERIPH_BASE + 0x0058]
set DMA1_Channel6_BASE    [expr $AHBPERIPH_BASE + 0x006C]
set DMA1_Channel7_BASE    [expr $AHBPERIPH_BASE + 0x0080]
set DMA2_BASE             [expr $AHBPERIPH_BASE + 0x0400]
set DMA2_Channel1_BASE    [expr $AHBPERIPH_BASE + 0x0408]
set DMA2_Channel2_BASE    [expr $AHBPERIPH_BASE + 0x041C]
set DMA2_Channel3_BASE    [expr $AHBPERIPH_BASE + 0x0430]
set DMA2_Channel4_BASE    [expr $AHBPERIPH_BASE + 0x0444]
set DMA2_Channel5_BASE    [expr $AHBPERIPH_BASE + 0x0458]
set RCC_BASE              [expr $AHBPERIPH_BASE + 0x1000]
set CRC_BASE              [expr $AHBPERIPH_BASE + 0x3000]

# /*Flash registers base address */
set FLASH_R_BASE          [expr $AHBPERIPH_BASE + 0x2000]
# /*Flash Option Bytes base address */
set OB_BASE               0x1FFFF800

# /*FSMC Bankx registers base address */
set FSMC_Bank1_R_BASE     [expr $FSMC_R_BASE + 0x0000]
set FSMC_Bank1E_R_BASE    [expr $FSMC_R_BASE + 0x0104]
set FSMC_Bank2_R_BASE     [expr $FSMC_R_BASE + 0x0060]
set FSMC_Bank3_R_BASE     [expr $FSMC_R_BASE + 0x0080]
set FSMC_Bank4_R_BASE     [expr $FSMC_R_BASE + 0x00A0]

# /*Debug MCU registers base address */
set DBGMCU_BASE           0xE0042000

# /*System Control Space memory map */
set SCS_BASE              0xE000E000

set SysTick_BASE          [expr $SCS_BASE + 0x0010]
set NVIC_BASE             [expr $SCS_BASE + 0x0100]
set SCB_BASE              [expr $SCS_BASE + 0x0D00]
source [find chip/ti/lm3s/lm3s_regs.tcl]
#*****************************************************************************
#
# The following are defines for the System Control register addresses.
#
#*****************************************************************************

set SYSCTL_DID0             0x400FE000  ;# Device Identification 0
set SYSCTL_DID1             0x400FE004  ;# Device Identification 1
set SYSCTL_DC0              0x400FE008  ;# Device Capabilities 0
set SYSCTL_DC1              0x400FE010  ;# Device Capabilities 1
set SYSCTL_DC2              0x400FE014  ;# Device Capabilities 2
set SYSCTL_DC3              0x400FE018  ;# Device Capabilities 3
set SYSCTL_DC4              0x400FE01C  ;# Device Capabilities 4
set SYSCTL_DC5              0x400FE020  ;# Device Capabilities 5
set SYSCTL_DC6              0x400FE024  ;# Device Capabilities 6
set SYSCTL_DC7              0x400FE028  ;# Device Capabilities 7
set SYSCTL_DC8              0x400FE02C  ;# Device Capabilities 8 ADC
                                        ;# Channels
set SYSCTL_PBORCTL          0x400FE030  ;# Brown-Out Reset Control
set SYSCTL_LDOPCTL          0x400FE034  ;# LDO Power Control
set SYSCTL_SRCR0            0x400FE040  ;# Software Reset Control 0
set SYSCTL_SRCR1            0x400FE044  ;# Software Reset Control 1
set SYSCTL_SRCR2            0x400FE048  ;# Software Reset Control 2
set SYSCTL_RIS              0x400FE050  ;# Raw Interrupt Status
set SYSCTL_IMC              0x400FE054  ;# Interrupt Mask Control
set SYSCTL_MISC             0x400FE058  ;# Masked Interrupt Status and
                                        ;# Clear
set SYSCTL_RESC             0x400FE05C  ;# Reset Cause
set SYSCTL_RCC              0x400FE060  ;# Run-Mode Clock Configuration
set SYSCTL_PLLCFG           0x400FE064  ;# XTAL to PLL Translation
set SYSCTL_GPIOHSCTL        0x400FE06C  ;# GPIO High-Speed Control
set SYSCTL_GPIOHBCTL        0x400FE06C  ;# GPIO High-Performance Bus
                                        ;# Control
set SYSCTL_RCC2             0x400FE070  ;# Run-Mode Clock Configuration 2
set SYSCTL_MOSCCTL          0x400FE07C  ;# Main Oscillator Control
set SYSCTL_RCGC0            0x400FE100  ;# Run Mode Clock Gating Control
                                        ;# Register 0
set SYSCTL_RCGC1            0x400FE104  ;# Run Mode Clock Gating Control
                                        ;# Register 1
set SYSCTL_RCGC2            0x400FE108  ;# Run Mode Clock Gating Control
                                        ;# Register 2
set SYSCTL_SCGC0            0x400FE110  ;# Sleep Mode Clock Gating Control
                                        ;# Register 0
set SYSCTL_SCGC1            0x400FE114  ;# Sleep Mode Clock Gating Control
                                        ;# Register 1
set SYSCTL_SCGC2            0x400FE118  ;# Sleep Mode Clock Gating Control
                                        ;# Register 2
set SYSCTL_DCGC0            0x400FE120  ;# Deep Sleep Mode Clock Gating
                                        ;# Control Register 0
set SYSCTL_DCGC1            0x400FE124  ;# Deep-Sleep Mode Clock Gating
                                        ;# Control Register 1
set SYSCTL_DCGC2            0x400FE128  ;# Deep Sleep Mode Clock Gating
                                        ;# Control Register 2
set SYSCTL_DSLPCLKCFG       0x400FE144  ;# Deep Sleep Clock Configuration
set SYSCTL_CLKVCLR          0x400FE150  ;# Clock Verification Clear
set SYSCTL_PIOSCCAL         0x400FE150  ;# Precision Internal Oscillator
                                        ;# Calibration
set SYSCTL_PIOSCSTAT        0x400FE154  ;# Precision Internal Oscillator
                                        ;# Statistics
set SYSCTL_LDOARST          0x400FE160  ;# Allow Unregulated LDO to Reset
                                        ;# the Part
set SYSCTL_I2SMCLKCFG       0x400FE170  ;# I2S MCLK Configuration
set SYSCTL_DC9              0x400FE190  ;# Device Capabilities 9 ADC
                                        ;# Digital Comparators
set SYSCTL_NVMSTAT          0x400FE1A0  ;# Non-Volatile Memory Information

set SYSCTL_RCC_USESYSDIV    0x00400000  ;# Enable System Clock Divider
set SYSCTL_RCC2_BYPASS2     0x00000800  ;# PLL Bypass 2
set SYSCTL_RCC_MOSCDIS      0x00000001  ;# Main Oscillator Disable

set SYSCTL_SRCR0            0x400FE040  ;# Software Reset Control 0
set SYSCTL_SRCR1            0x400FE044  ;# Software Reset Control 1
set SYSCTL_SRCR2            0x400FE048  ;# Software Reset Control 2

set SYSCTL_MISC             0x400FE058  ;# Masked Interrupt Status and Clear

set FLASH_FMA               0x400FD000  ;# Flash Memory Address
set FLASH_FMD               0x400FD004  ;# Flash Memory Data
set FLASH_FMC               0x400FD008  ;# Flash Memory Control
set FLASH_FCRIS             0x400FD00C  ;# Flash Controller Raw Interrupt Status
set FLASH_FCIM              0x400FD010  ;# Flash Controller Interrupt Mask
set FLASH_FCMISC            0x400FD014  ;# Flash Controller Masked Interrupt Status and Clear
set FLASH_FMC2              0x400FD020  ;#  Flash Memory Control 2
set FLASH_FWBVAL            0x400FD030  ;# Flash Write Buffer Valid
# Altera MAXV 5M24OZ/5M570Z CPLD
# see MAX V Device Handbook
# Table 6-3: 32-Bit MAX V Device IDCODE
# Version     Part Number             Manuf. ID        LSB
# 0000        0010 0000 1010 0111     000 0110 1110    1
jtag newtap 5m570z tap -expected-id 0x020a60dd -irlen 10
# Altera MAXII EPM240T100C CPLD
# see MAX II Device Handbook
# Table 3-3: 32-Bit MAX II Device IDCODE
# Version     Part Number             Manuf. ID        LSB
# 0000        0010 0000 1010 0001     000 0110 1110    1
jtag newtap epm240 tap -expected-id 0x020a10dd -irlen 10
set _USER1 0x02

if { [info exists JTAGSPI_IR] } {
	set _JTAGSPI_IR $JTAGSPI_IR
} else {
	set _JTAGSPI_IR $_USER1
}

if { [info exists TARGETNAME] } {
	set _TARGETNAME $TARGETNAME
} else {
	set _TARGETNAME $_CHIPNAME.proxy
}

if { [info exists FLASHNAME] } {
	set _FLASHNAME $FLASHNAME
} else {
	set _FLASHNAME $_CHIPNAME.spi
}

target create $_TARGETNAME testee -chain-position $_CHIPNAME.tap
flash bank $_FLASHNAME jtagspi 0 0 0 0 $_TARGETNAME $_JTAGSPI_IR

proc jtagspi_init {chain_id proxy_bit} {
	# load proxy bitstream $proxy_bit and probe spi flash
	global _FLASHNAME
	pld load $chain_id $proxy_bit
	reset halt
	flash probe $_FLASHNAME
}

proc jtagspi_program {bin addr} {
	# write and verify binary file $bin at offset $addr
	global _FLASHNAME
	flash write_image erase $bin $addr
	flash verify_bank $_FLASHNAME $bin $addr
}
# Lattice ispMACH 4000ZE family, device LC4032ZE
# just configure a tap
jtag newtap LC4032ZE tap -irlen 8 -expected-id  0x01806043
# xilinx spartan6
# http://www.xilinx.com/support/documentation/user_guides/ug380.pdf

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xc6s
}

# the 4 top bits (28:31) are the die stepping. ignore it.
jtag newtap $_CHIPNAME tap -irlen 6 -ignore-version \
	-expected-id 0x04000093 \
	-expected-id 0x04001093 \
	-expected-id 0x04002093 \
	-expected-id 0x04004093 \
	-expected-id 0x04024093 \
	-expected-id 0x04008093 \
	-expected-id 0x04028093 \
	-expected-id 0x0400E093 \
	-expected-id 0x0402E093 \
	-expected-id 0x04011093 \
	-expected-id 0x04031093 \
	-expected-id 0x0401D093 \
	-expected-id 0x0403D093

pld device virtex2 $_CHIPNAME.tap

set XC6S_CFG_IN 0x05
set XC6S_JSHUTDOWN 0x0d
set XC6S_JPROGRAM 0x0b
set XC6S_JSTART 0x0c
set XC6S_BYPASS 0x3f

proc xc6s_program {tap} {
	global XC6S_JSHUTDOWN XC6S_JPROGRAM XC6S_JSTART XC6S_BYPASS
	irscan $tap $XC6S_JSHUTDOWN
	irscan $tap $XC6S_JPROGRAM
	irscan $tap $XC6S_JSTART
	irscan $tap $XC6S_BYPASS
}

#xtp038 and xc3sprog approach
proc xc6s_program_iprog {tap} {
	global XC6S_JSHUTDOWN XC6S_JSTART XC6S_BYPASS XC6S_CFG_IN
	irscan $tap $XC6S_JSHUTDOWN
	runtest 16
	irscan $tap $XC6S_CFG_IN
	# xtp038 IPROG 16bit flipped
	drscan $tap 16 0xffff 16 0x9955 16 0x66aa 16 0x850c 16 0x7000 16 0x0004
	irscan $tap $XC6S_JSTART
	runtest 32
	irscan $tap $XC6S_BYPASS
	runtest 1
}

set XC6S_ISC_ENABLE 0x10
set XC6S_ISC_DISABLE 0x16
set XC6S_ISC_DNA 0x30

# Get the "Device DNA" from the Spartan 6.
# Most Xilinx FPGA devices contain an embedded, unique device identifier called
# the "Device DNA". The identifier is nonvolatile, permanently programmed into
# the FPGA, and is unchangeable providing a great serial / tracking number.
proc xc6s_get_dna {tap} {
	global XC6S_ISC_ENABLE XC6S_ISC_DISABLE XC6S_ISC_DNA
	irscan $tap $XC6S_ISC_ENABLE
	runtest 64
	irscan $tap $XC6S_ISC_DNA
	# Device DNA is 57 bits long, but we can only read 32bits at a time
	# with OpenOCD.
	set dna [drscan $tap 16 0 16 0 16 0 9 0]
	runtest 64
	irscan $tap $XC6S_ISC_DISABLE
	runtest 64

	# Convert the binary data into the order impact uses
	scan $dna "%x %x %x %x" v1 v2 v3 v4
	set bin_dna [string reverse [concat [format "%09b" $v4][format "%016b" $v3][format "%016b" $v2][format "%016b" $v1]]]

	# Return a hex version of binary
	scan [format "0b%s" $bin_dna] "%i" hex_dna
	return $hex_dna
}

# Print out the "Device DNA" in the same format that impact uses.
proc xc6s_print_dna {tap} {
	set hex_dna [xc6s_get_dna $tap]

	puts [format "DNA = %57b (0x%x)\n" $hex_dna $hex_dna]
}
# xilinx series 7 (artix, kintex, virtex)
# http://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xc7
}

# the 4 top bits (28:31) are the die stepping/revisions. ignore it.
jtag newtap $_CHIPNAME tap -irlen 6 -ignore-version \
	-expected-id 0x03622093 \
	-expected-id 0x03620093 \
	-expected-id 0x037C4093 \
	-expected-id 0x0362F093 \
	-expected-id 0x037C8093 \
	-expected-id 0x037C7093 \
	-expected-id 0x037C3093 \
	-expected-id 0x0362E093 \
	-expected-id 0x037C2093 \
	-expected-id 0x0362D093 \
	-expected-id 0x0362C093 \
	-expected-id 0x03632093 \
	-expected-id 0x03631093 \
	-expected-id 0x03636093 \
	-expected-id 0x03647093 \
	-expected-id 0x0364C093 \
	-expected-id 0x03651093 \
	-expected-id 0x03747093 \
	-expected-id 0x03656093 \
	-expected-id 0x03752093 \
	-expected-id 0x03751093 \
	-expected-id 0x03671093 \
	-expected-id 0x036B3093 \
	-expected-id 0x036B7093 \
	-expected-id 0x036BB093 \
	-expected-id 0x036BF093 \
	-expected-id 0x03667093 \
	-expected-id 0x03682093 \
	-expected-id 0x03687093 \
	-expected-id 0x03692093 \
	-expected-id 0x03691093 \
	-expected-id 0x03696093 \
	-expected-id 0x036D5093 \
	-expected-id 0x036D9093 \
	-expected-id 0x036DB093

pld device virtex2 $_CHIPNAME.tap 1

set XC7_JSHUTDOWN 0x0d
set XC7_JPROGRAM 0x0b
set XC7_JSTART 0x0c
set XC7_BYPASS 0x3f

proc xc7_program {tap} {
	global XC7_JSHUTDOWN XC7_JPROGRAM XC7_JSTART XC7_BYPASS
	irscan $tap $XC7_JSHUTDOWN
	irscan $tap $XC7_JPROGRAM
	runtest 60000
	#JSTART prevents this from working...
	#irscan $tap $XC7_JSTART
	runtest 2000
	irscan $tap $XC7_BYPASS
	runtest 2000
}
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xcf
}

# IDs acquired from Xilinx's DS123.pdf
# XCF08P <v>5057093
# XCF16P <v>5058093
# XCF32P <v>5059093
# The 4 top bits (28:31) are the device revision. Ignore it.
jtag newtap $_CHIPNAME flash -irlen 16 -ignore-version \
	-expected-id 0x05057093 \
	-expected-id 0x05058093 \
	-expected-id 0x05059093

target create xcf.flash testee -chain-position $_CHIPNAME.flash
flash bank XCF_P xcf 0 0 0 0 xcf.flash
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xcf
}

# IDs acquired from Xilinx's DS123.pdf
# XCF01S <v>5044093
# XCF02S <v>5045093
# XCF04S <v>5046093
# The 4 top bits (28:31) are the device revision. Ignore it.
jtag newtap $_CHIPNAME flash -irlen 8 -ignore-version \
	-expected-id 0x05044093 \
	-expected-id 0x05045093 \
	-expected-id 0x05046093

target create xcf.flash testee -chain-position $_CHIPNAME.flash
flash bank XCF_S xcf 0 0 0 0 xcf.flash
#xilinx coolrunner xcr3256
#simple device - just configure a tap
jtag newtap xcr tap -irlen 5 -ircapture 0x01 -irmask 0x1f -expected-id  0x0494c093
# Xilinx Ultrascale (Kintex, Virtex, Zynq)
# https://www.xilinx.com/support/documentation/user_guides/ug570-ultrascale-configuration.pdf

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xcu
}

# The cvarious chips in the Ultrascale family have different IR length.
# Set $CHIP before including this file to determine the device.
array set _XCU_DATA {
	XCKU025 {0x03824093 6}
	XCKU035 {0x03823093 6}
	XCKU040 {0x03822093 6}
	XCKU060 {0x03919093 6}
	XCKU095 {0x03844093 6}
	XCKU3P {0x04A63093 6}
	XCKU5P {0x04A62093 6}
	XCKU9P {0x0484A093 6}
	XCKU11P {0x04A4E093 6}
	XCKU13P {0x04A52093 6}
	XCKU15P {0x04A56093 6}
	XCVU065 {0x03939093 6}
	XCVU080 {0x03843093 6}
	XCVU095 {0x03842093 6}
	XCVU3P {0x04B39093 6}
	XCKU085 {0x0380F093 12}
	XCKU115 {0x0390D093 12}
	XCVU125 {0x0392D093 12}
	XCVU5P {0x04B2B093 12}
	XCVU7P {0x04B29093 12}
	XCVU160 {0x03933093 18}
	XCVU190 {0x03931093 18}
	XCVU440 {0x0396D093 18}
	XCVU9P {0x04B31093 18}
	XCVU11P {0x04B49093 18}
	XCVU13P {0x04B51093 24}
}

if { ![info exists CHIP] } {
	error "set CHIP to one of "[concat [array names _XCU_DATA]]
}

if { ![llength [array names _XCU_DATA $CHIP]] } {
	error "unknown CHIP: "$CHIP
}

set _EXPID [lindex $_XCU_DATA($CHIP) 0]
set _IRLEN [lindex $_XCU_DATA($CHIP) 1]

# the 4 top bits (28:31) are the die stepping/revisions. ignore it.
jtag newtap $_CHIPNAME tap -irlen $_IRLEN -ignore-version -expected-id $_EXPID

pld device virtex2 $_CHIPNAME.tap 1

set XCU_JSHUTDOWN 0x0d
set XCU_JPROGRAM 0x0b
set XCU_JSTART 0x0c
set XCU_BYPASS 0x3f

proc xcu_program {tap} {
	global XCU_JSHUTDOWN XCU_JPROGRAM XCU_JSTART XCU_BYPASS
	irscan $tap $XCU_JSHUTDOWN
	irscan $tap $XCU_JPROGRAM
	runtest 60000
	#JSTART prevents this from working...
	#irscan $tap $XCU_JSTART
	runtest 2000
	irscan $tap $XCU_BYPASS
	runtest 2000
}
#  Copyright (C) 2015, 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

# Things common to all ARCs

# It is assumed that target is already halted.
proc arc_common_reset { {target ""} } {
        if { $target != "" } {
                targets $target
        }

        halt

        # 1. Interrupts are disabled (STATUS32.IE)
        # 2. The status register flags are cleared.
        # All fields, except the H bit, are set to 0 when the processor is Reset.

        arc jtag set-aux-reg 0xA 0x1

        # 3. The loop count, loop start, and loop end registers are cleared.
        arc jtag set-core-reg 60 0
        arc jtag set-aux-reg 0x2 0
        arc jtag set-aux-reg 0x3 0

        # Program execution begins at the address referenced by the four byte reset
        # vector located at the interrupt vector base address, which is the first
        # entry (offset 0x00) in the vector table.
        set int_vector_base [arc jtag get-aux-reg 0x25]
        set start_pc ""
        mem2array start_pc 32 $int_vector_base 1
        arc jtag set-aux-reg 0x6 $start_pc(0)

        # It is OK to do uncached writes - register cache will be invalidated by
        # the reset_assert() function.
}

# vim:expandtab:
#  Copyright (C) 2015, 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

source [find cpu/arc/v2.tcl]

proc arc_em_examine_target { {target ""} } {
	# Will set current target
	arc_v2_examine_target $target
}

proc arc_em_init_regs { } {
	arc_v2_init_regs

	[target current] configure \
		-event examine-end "arc_em_examine_target [target current]"
}

# Scripts in "target" folder should call this function instead of direct
# invocation of arc_common_reset.
proc arc_em_reset { {target ""} } {
	arc_v2_reset $target

	# Set DEBUG.ED bit to enable clock in actionpoint module.
	# This is specific to ARC EM.
	set debug [arc jtag get-aux-reg 5]
	if { !($debug & (1 << 20)) } {
		arc jtag set-aux-reg 5 [expr $debug | (1 << 20)]
	}
}
#  Copyright (C) 2015, 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

source [find cpu/arc/v2.tcl]

proc arc_hs_examine_target { target } {
	# Will set current target for us.
	arc_v2_examine_target $target
}

proc arc_hs_init_regs { } {
	arc_v2_init_regs

	[target current] configure \
		-event examine-end "arc_hs_examine_target [target current]"
}

# Scripts in "target" folder should call this function instead of direct
# invocation of arc_common_reset.
proc arc_hs_reset { {target ""} } {
	arc_v2_reset $target

	# Invalidate L2 cache if there is one.
	set l2_config [$target arc jtag get-aux-reg 0x901]
	# Will return 0, if cache is not present and register doesn't exist.
	set l2_ctrl [$target arc jtag get-aux-reg 0x903]
	if { ($l2_config != 0) && (($l2_ctrl & 1) == 0) } {
		puts "L2 cache is present and not disabled"

		# Wait until BUSY bit is 0.
		puts "Invalidating L2 cache..."
		$target arc jtag set-aux-reg 0x905 1
		# Dummy read of SLC_AUX_CACHE_CTRL bit, as described in:
		# https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/arch/arc?id=c70c473396cbdec1168a6eff60e13029c0916854
		set l2_ctrl [$target arc jtag get-aux-reg 0x903]
		set l2_ctrl [$target arc jtag get-aux-reg 0x903]
		while { ($l2_ctrl & 0x100) != 0 } {
			set l2_ctrl [$target arc jtag get-aux-reg 0x903]
		}

		# Flush cache if needed. If SLC_AUX_CACHE_CTRL.IM is 1, then invalidate
		# operation already flushed everything.
		if { ($l2_ctrl & 0x40) == 0 } {
			puts "Flushing L2 cache..."
			$target arc jtag set-aux-reg 0x904 1
			set l2_ctrl [$target arc jtag get-aux-reg 0x903]
			set l2_ctrl [$target arc jtag get-aux-reg 0x903]
			while { [expr $l2_ctrl & 0x100] != 0 } {
				set l2_ctrl [$target arc jtag get-aux-reg 0x903]
			}
		}

		puts "L2 cache has been flushed and invalidated."
	}
}
#  Copyright (C) 2015, 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

source [find cpu/arc/common.tcl]

# Currently 'examine_target' can only read JTAG registers and set properties -
# but it shouldn't write any of registers - writes will be cached, but cache
# will be invalidated before flushing after examine_target, and changes will be
# lost.  Perhaps that would be fixed later - perhaps writes shouldn't be cached
# after all.  But if write to register is really needed from TCL - then it
# should be done via "arc jtag" for now.
proc arc_v2_examine_target { {target ""} } {
	# Set current target, because OpenOCD event handlers don't do this for us.
	if { $target != "" } {
		targets $target
	}

	# Those registers always exist. DEBUG and DEBUGI are formally optional,
	# however they come with JTAG interface, and so far there is no way
	# OpenOCD can communicate with target without JTAG interface.
	arc set-reg-exists identity pc status32 bta debug lp_start lp_end \
		eret erbta erstatus ecr efa

	# 32 core registers
	arc set-reg-exists \
		r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 \
		r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 \
		gp fp sp ilink r30 blink lp_count pcl

	# Actionpoints
	if { [arc get-reg-field ap_build version] == 5 } {
		set ap_build_type [arc get-reg-field ap_build type]
		# AP_BUILD.TYPE > 0b0110 is reserved in current ISA.
		# Current ISA supports up to 8 actionpoints.
		if { $ap_build_type < 8 } {
			# Two LSB bits of AP_BUILD.TYPE define amount of actionpoints:
			# 0b00 - 2 actionpoints
			# 0b01 - 4 actionpoints
			# 0b10 - 8 actionpoints
			# 0b11 - reserved.
			set ap_num [expr 0x2 << ($ap_build_type & 3)]
			# Expression on top may produce 16 action points - which is a
			# reserved value for now.
			if { $ap_num < 16 } {
				# Enable actionpoint registers
				for {set i 0} {$i < $ap_num} {incr i} {
					arc set-reg-exists ap_amv$i ap_amm$i ap_ac$i
				}

				# Set amount of actionpoints
				arc num-actionpoints $ap_num
			}
		}
	}

	# DCCM
	set dccm_version [arc get-reg-field dccm_build version]
	if { $dccm_version == 3 || $dccm_version == 4 } {
		arc set-reg-exists aux_dccm
	}

	# ICCM
	if { [arc get-reg-field iccm_build version] == 4 } {
		arc set-reg-exists aux_iccm
	}

	# MPU
	if { [arc get-reg-field mpu_build version] >= 2 &&
		 [arc get-reg-field mpu_build version] <= 4 } {
		arc set-reg-exists mpu_en mpu_ecr
		set mpu_regions [arc get-reg-field mpu_build regions]
		for {set i 0} {$i < $mpu_regions} {incr i} {
			arc set-reg-exists mpu_rdp$i mpu_rdb$i
		}

		# Secure MPU
		if { [arc get-reg-field mpu_build version] == 4 } {
			arc set-reg-exists mpu_index mpu_rstart mpu_rend mpu_rper
		}
	}
}

proc arc_v2_init_regs { } {
	# XML features
	set core_feature "org.gnu.gdb.arc.core.v2"
	set aux_min_feature "org.gnu.gdb.arc.aux-minimal"
	set aux_other_feature "org.gnu.gdb.arc.aux-other"

	# Describe types
	# Types are sorted alphabetically according to their name.
	arc add-reg-type-struct -name ap_build_t -bitfield version 0 7 \
		-bitfield type 8 11
	arc add-reg-type-struct -name ap_control_t -bitfield at 0 3 -bitfield tt 4 5 \
		-bitfield m 6 6 -bitfield p 7 7 -bitfield aa 8 8 -bitfield q 9 9
	# Cycles field added in version 4.
	arc add-reg-type-struct -name dccm_build_t -bitfield version 0 7 \
		-bitfield size0 8 11 -bitfield size1 12 15 -bitfield cycles 17 19

	arc add-reg-type-struct -name debug_t \
		-bitfield fh 1 1   -bitfield ah 2 2   -bitfield asr 3 10 \
		-bitfield is 11 11 -bitfield ep 19 19 -bitfield ed 20 20 \
		-bitfield eh 21 21 -bitfield ra 22 22 -bitfield zz 23 23 \
		-bitfield sm 24 26 -bitfield ub 28 28 -bitfield bh 29 29 \
		-bitfield sh 30 30 -bitfield ld 31 31

	arc add-reg-type-struct -name ecr_t \
		-bitfield parameter 0 7 \
		-bitfield cause 8 15 \
		-bitfield vector 16 23 \
		-bitfield U 30 30 \
		-bitfield P 31 31
	arc add-reg-type-struct -name iccm_build_t -bitfield version 0 7 \
		-bitfield iccm0_size0  8 11 -bitfield iccm1_size0 12 15 \
		-bitfield iccm0_size1 16 19 -bitfield iccm1_size1 20 23
	arc add-reg-type-struct -name identity_t \
		-bitfield arcver 0 7 -bitfield arcnum 8 15 -bitfield chipid 16 31
	arc add-reg-type-struct -name isa_config_t -bitfield version 0 7 \
		-bitfield pc_size 8 11 -bitfield lpc_size 12 15 -bitfield addr_size 16 19 \
		-bitfield b 20 20 -bitfield a 21 21 -bitfield n 22 22 -bitfield l 23 23 \
		-bitfield c 24 27 -bitfield d 28 31
	arc add-reg-type-struct -name mpu_build_t -bitfield version 0 7 \
		-bitfield regions 8 15 \
		-bitfield s 16 16 \
		-bitfield i 17 17
	arc add-reg-type-struct -name mpu_ecr_t \
		-bitfield MR 0 7 \
		-bitfield VT 8 9 \
		-bitfield EC_CODE 16 31
	arc add-reg-type-struct -name mpu_en_t \
		-bitfield UE  3  3 -bitfield UW   4  4 -bitfield UR 5 5 \
		-bitfield KE  6  6 -bitfield KW   7  7 -bitfield KR 8 8 \
		-bitfield S  15 15 -bitfield SID 16 23 \
		-bitfield EN 30 30
	arc add-reg-type-struct -name mpu_index_t \
		-bitfield I 0 3 -bitfield M 30 30 -bitfield D 31 31
	arc add-reg-type-struct -name mpu_rper_t \
		-bitfield V 0 0 \
		-bitfield UE 3 3 -bitfield UW 4 4 -bitfield UR 5 5 \
		-bitfield KE 6 6 -bitfield KW 7 7 -bitfield KR 8 8 \
		-bitfield S 15 15 -bitfield SID 16 23
	arc add-reg-type-flags -name status32_t \
		-flag   H  0 -flag E0   1 -flag E1   2 -flag E2  3 \
		-flag  E3  4 -flag AE   5 -flag DE   6 -flag  U  7 \
		-flag   V  8 -flag  C   9 -flag  N  10 -flag  Z 11 \
		-flag   L 12 -flag DZ  13 -flag SC  14 -flag ES 15 \
		-flag RB0 16 -flag RB1 17 -flag RB2 18 \
		-flag  AD 19 -flag US  20 -flag IE  31

	# Core registers
	set core_regs {
		r0       0  uint32
		r1       1  uint32
		r2       2  uint32
		r3       3  uint32
		r4       4  uint32
		r5       5  uint32
		r6       6  uint32
		r7       7  uint32
		r8       8  uint32
		r9       9  uint32
		r10      10 uint32
		r11      11 uint32
		r12      12 uint32
		r13      13 uint32
		r14      14 uint32
		r15      15 uint32
		r16      16 uint32
		r17      17 uint32
		r18      18 uint32
		r19      19 uint32
		r20      20 uint32
		r21      21 uint32
		r22      23 uint32
		r23      24 uint32
		r24      24 uint32
		r25      25 uint32
		gp       26 data_ptr
		fp       27 data_ptr
		sp       28 data_ptr
		ilink    29 code_ptr
		r30      30 uint32
		blink    31 code_ptr
		r32      32 uint32
		r33      33 uint32
		r34      34 uint32
		r35      35 uint32
		r36      36 uint32
		r37      37 uint32
		r38      38 uint32
		r39      39 uint32
		r40      40 uint32
		r41      41 uint32
		r42      42 uint32
		r43      43 uint32
		r44      44 uint32
		r45      45 uint32
		r46      46 uint32
		r47      47 uint32
		r48      48 uint32
		r49      49 uint32
		r50      50 uint32
		r51      51 uint32
		r52      52 uint32
		r53      53 uint32
		r54      54 uint32
		r55      55 uint32
		r56      56 uint32
		r57      57 uint32
		accl     58 uint32
		acch     59 uint32
		lp_count 60 uint32
		limm     61 uint32
		reserved 62 uint32
		pcl      63 code_ptr
	}
	foreach {reg count type} $core_regs {
		arc add-reg -name $reg -num $count -core -type $type -g \
			-feature $core_feature
	}

	# AUX min
	set aux_min {
		0x6 pc       code_ptr
		0x2 lp_start code_ptr
		0x3 lp_end   code_ptr
		0xA status32 status32_t
	}
	foreach {num name type} $aux_min {
		arc add-reg -name $name -num $num -type $type -feature $aux_min_feature -g
	}

	# AUX other
	set aux_other {
		0x004 identity	identity_t
		0x005 debug		debug_t
		0x018 aux_dccm	int
		0x208 aux_iccm	int

		0x220 ap_amv0	uint32
		0x221 ap_amm0	uint32
		0x222 ap_ac0	ap_control_t
		0x223 ap_amv1	uint32
		0x224 ap_amm1	uint32
		0x225 ap_ac1	ap_control_t
		0x226 ap_amv2	uint32
		0x227 ap_amm2	uint32
		0x228 ap_ac2	ap_control_t
		0x229 ap_amv3	uint32
		0x22A ap_amm3	uint32
		0x22B ap_ac3	ap_control_t
		0x22C ap_amv4	uint32
		0x22D ap_amm4	uint32
		0x22E ap_ac4	ap_control_t
		0x22F ap_amv5	uint32
		0x230 ap_amm5	uint32
		0x231 ap_ac5	ap_control_t
		0x232 ap_amv6	uint32
		0x233 ap_amm6	uint32
		0x234 ap_ac6	ap_control_t
		0x235 ap_amv7	uint32
		0x236 ap_amm7	uint32
		0x237 ap_ac7	ap_control_t

		0x400 eret		code_ptr
		0x401 erbta		code_ptr
		0x402 erstatus	status32_t
		0x403 ecr		ecr_t
		0x404 efa		data_ptr

		0x409 mpu_en	mpu_en_t

		0x412 bta		code_ptr

		0x420 mpu_ecr	mpu_ecr_t
		0x422 mpu_rdb0	int
		0x423 mpu_rdp0	int
		0x424 mpu_rdb1	int
		0x425 mpu_rdp1	int
		0x426 mpu_rdb2	int
		0x427 mpu_rdp2	int
		0x428 mpu_rdb3	int
		0x429 mpu_rdp3	int
		0x42A mpu_rdb4	int
		0x42B mpu_rdp4	int
		0x42C mpu_rdb5	int
		0x42D mpu_rdp5	int
		0x42E mpu_rdb6	int
		0x42F mpu_rdp6	int
		0x430 mpu_rdb7	int
		0x431 mpu_rdp7	int
		0x432 mpu_rdb8	int
		0x433 mpu_rdp8	int
		0x434 mpu_rdb9	int
		0x435 mpu_rdp9	int
		0x436 mpu_rdb10	int
		0x437 mpu_rdp10	int
		0x438 mpu_rdb11	int
		0x439 mpu_rdp11	int
		0x43A mpu_rdb12	int
		0x43B mpu_rdp12	int
		0x43C mpu_rdb13	int
		0x43D mpu_rdp13	int
		0x43E mpu_rdb14	int
		0x43F mpu_rdp14	int
		0x440 mpu_rdb15	int
		0x441 mpu_rdp15	int
		0x448 mpu_index	mpu_index_t
		0x449 mpu_rstart uint32
		0x44A mpu_rend	uint32
		0x44B mpu_rper	mpu_rper_t
		0x44C mpu_probe uint32
	}
	foreach {num name type} $aux_other {
		arc add-reg -name $name -num $num -type $type -feature $aux_other_feature
	}

	# AUX BCR
	set bcr {
		0x6D mpu_build
		0x74 dccm_build
		0x76 ap_build
		0x78 iccm_build
		0xC1 isa_config
	}
	foreach {num reg} $bcr {
		arc add-reg -name $reg -num $num -type ${reg}_t -bcr -feature $aux_other_feature
	}

	[target current] configure \
		-event examine-end "arc_v2_examine_target [target current]"
}

proc arc_v2_reset { {target ""} } {
	arc_common_reset $target

	# Disable all actionpoints.  Cannot write via regcache yet, because it will
	# not be flushed and all changes to registers will get lost.  Therefore has
	# to write directly via JTAG layer...
	set num_ap [arc num-actionpoints]
	for {set i 0} {$i < $num_ap} {incr i} {
		arc jtag set-aux-reg [expr 0x222 + $i * 3] 0
	}
}
set CPU_TYPE   arm
set CPU_NAME   arm7tdmi
set CPU_ARCH   armv4t
set CPU_MAX_ADDRESS 0xFFFFFFFF
set CPU_NBITS  32
set CPU_TYPE   arm
set CPU_NAME   arm920
set CPU_ARCH   armv4t
set CPU_MAX_ADDRESS 0xFFFFFFFF
set CPU_NBITS  32
set CPU_TYPE   arm
set CPU_NAME   arm946
set CPU_ARCH   armv5te
set CPU_MAX_ADDRESS 0xFFFFFFFF
set CPU_NBITS  32
set CPU_TYPE   arm
set CPU_NAME   arm966
set CPU_ARCH   armv5te
set CPU_MAX_ADDRESS 0xFFFFFFFF
set CPU_NBITS  32
set CPU_TYPE   arm
set CPU_NAME   cortex_m3
set CPU_ARCH   armv7
set CPU_MAX_ADDRESS 0xFFFFFFFF
set CPU_NBITS  32
# see MAX 10 FPGA Device Architecture
# Table 3-1: IDCODE Information for MAX 10 Devices
# Intel MAX 10M02 0x31810dd
# Intel MAX 10M04 0x318a0dd
# Intel MAX 10M08 0x31820dd
# Intel MAX 10M16 0x31830dd
# Intel MAX 10M25 0x31840dd
# Intel MAX 10M40 0x318d0dd
# Intel MAX 10M50 0x31850dd
# Intel MAX 10M02 0x31010dd
# Intel MAX 10M04 0x310a0dd
# Intel MAX 10M08 0x31020dd
# Intel MAX 10M16 0x31030dd
# Intel MAX 10M25 0x31040dd
# Intel MAX 10M40 0x310d0dd
# Intel MAX 10M50 0x31050dd

jtag newtap 10m50 tap -irlen 10 -expected-id 0x31810dd -expected-id 0x318a0dd \
	-expected-id 0x31820dd -expected-id 0x31830dd -expected-id 0x31840dd \
	-expected-id 0x318d0dd -expected-id 0x31850dd -expected-id 0x31010dd \
	-expected-id 0x310a0dd -expected-id 0x31020dd -expected-id 0x31030dd \
	-expected-id 0x31040dd -expected-id 0x310d0dd -expected-id 0x31050dd
# Altera Cyclone III EP3C10
# see Cyclone III Device Handbook, Volume 1;
# Table 145. 32-Bit Cyclone III Device IDCODE
jtag newtap ep3c10 tap -expected-id 0x020f10dd -irlen 10
proc xilinx_dna_addr {chip} {
	array set addrs {
		Spartan6 0x30
		Series7 0x17
	}
	return $addrs($chip)
}

# Get the "Device DNA".
# Most Xilinx FPGA devices contain an embedded, unique device identifier.
# The identifier is nonvolatile, permanently programmed into
# the FPGA, and is unchangeable providing a great serial / tracking number.
# This function returns the DNA as a 64 bit integer with the 7 LSBs zeroed.
# This is compatible with the FUSE DNA which contains all 64 bits.
proc xilinx_get_dna {tap chip} {
	set XC7_ISC_ENABLE 0x10
	set XC7_ISC_DISABLE 0x16
	set XC7_ISC_DNA [xilinx_dna_addr $chip]

	irscan $tap $XC7_ISC_ENABLE
	runtest 64
	irscan $tap $XC7_ISC_DNA
	scan [drscan $tap 32 0 32 0] "%08x %08x" hi lo
	runtest 64
	irscan $tap $XC7_ISC_DISABLE
	runtest 64
	# openocd interprets DR scans as LSB first, bit-reverse it
	return [scan [string reverse [format "%032b%032bb0" $lo $hi]] "%i"]
}

# Print out the "Device DNA" in the same format that impact uses.
proc xilinx_print_dna {dna} {
	set dna [expr $dna >> 64 - 57]
	echo [format "DNA = %057b (0x%016x)" $dna $dna]
}

proc xc7_get_dna {tap} {
	return [xilinx_get_dna $tap Series7]
}

proc xc6s_get_dna {tap} {
	return [xilinx_get_dna $tap Spartan6]
}
# Xilinx XADC support for 7 Series FPGAs
#
# The 7 Series FPGAs contain an on-chip 12 bit ADC that can probe die
# temperature, internal power supply rail voltages as well as external
# voltages. The XADC is available both from fabric as well as through the
# JTAG TAP.
#
# This code implements access through the JTAG TAP.
#
# https://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf

# build a 32 bit DRP command for the XADC DR
proc xadc_cmd {cmd addr data} {
	array set cmds {
		NOP 0x00
		READ 0x01
		WRITE 0x02
	}
	return [expr ($cmds($cmd) << 26) | ($addr << 16) | ($data << 0)]
}

# XADC register addresses
# Some addresses (status registers 0-3) have special function when written to.
proc XADC {key} {
	array set addrs {
		TEMP 0x00
		LOCK 0x00
		VCCINT 0x01
		VCCAUX 0x02
		VAUXEN 0x02
		VPVN 0x03
		RESET 0x03
		VREFP 0x04
		VREFN 0x05
		VCCBRAM 0x06
		SUPAOFFS 0x08
		ADCAOFFS 0x09
		ADCAGAIN 0x0a
		VCCPINT 0x0d
		VCCPAUX 0x0e
		VCCODDR 0x0f
		VAUX0 0x10
		VAUX1 0x11
		VAUX2 0x12
		VAUX3 0x13
		VAUX4 0x14
		VAUX5 0x15
		VAUX6 0x16
		VAUX7 0x17
		VAUX8 0x18
		VAUX9 0x19
		VAUX10 0x1a
		VAUX11 0x1b
		VAUX12 0x1c
		VAUX13 0x1d
		VAUX14 0x1e
		VAUX15 0x1f
		SUPBOFFS 0x30
		ADCBOFFS 0x31
		ADCBGAIN 0x32
		FLAG 0x3f
		CFG0 0x40
		CFG1 0x41
		CFG2 0x42
		SEQ0 0x48
		SEQ1 0x49
		SEQ2 0x4a
		SEQ3 0x4b
		SEQ4 0x4c
		SEQ5 0x4d
		SEQ6 0x4e
		SEQ7 0x4f
		ALARM0 0x50
		ALARM1 0x51
		ALARM2 0x52
		ALARM3 0x53
		ALARM4 0x54
		ALARM5 0x55
		ALARM6 0x56
		ALARM7 0x57
		ALARM8 0x58
		ALARM9 0x59
		ALARM10 0x5a
		ALARM11 0x5b
		ALARM12 0x5c
		ALARM13 0x5d
		ALARM14 0x5e
		ALARM15 0x5f
	}
	return $addrs($key)
}

# Select the XADC DR
proc xadc_select {tap} {
	set XADC_IR 0x37
	irscan $tap $XADC_IR
	runtest 10
}

# XADC transfer
proc xadc_xfer {tap cmd addr data} {
	set ret [drscan $tap 32 [xadc_cmd $cmd $addr $data]]
	runtest 10
	return [expr 0x$ret]
}

# XADC register write
proc xadc_write {tap addr data} {
	xadc_xfer $tap WRITE $addr $data
}

# XADC register read, non-pipelined
proc xadc_read {tap addr} {
	xadc_xfer $tap READ $addr 0
	return [xadc_xfer $tap NOP 0 0]
}

# convert 16 bit register code from ADC measurement on
# external voltages (VAUX) to Volt
proc xadc_volt {code} {
	return [expr $code * 1./(1 << 16)]
}

# convert 16 bit temperature measurement to Celsius
proc xadc_temp {code} {
	return [expr $code * 503.975/(1 << 16) - 273.15]
}

# convert 16 bit suppply voltage measurement to Volt
proc xadc_sup {code} {
	return [expr $code * 3./(1 << 16)]
}

# perform a single channel measurement using default settings
proc xadc_single {tap ch} {
	set cfg0 [xadc_read $tap [XADC CFG0]]
	set cfg1 [xadc_read $tap [XADC CFG1]]
	# set channel
	xadc_write $tap [XADC CFG0] $cfg0
	# single channel, disable the sequencer
	xadc_write $tap [XADC CFG1] 0x3000
	# leave some time for the conversion
	runtest 100
	set ret [xadc_read $tap [XADC $ch]]
	# restore CFG0/1
	xadc_write $tap [XADC CFG0] $cfg0
	xadc_write $tap [XADC CFG1] $cfg1
	return $ret
}

# measure all internal voltages
proc xadc_report {tap} {
	xadc_select $tap
	echo "TEMP [format %.2f [xadc_temp [xadc_single $tap TEMP]]] C"
	foreach ch [list VCCINT VCCAUX VCCBRAM VPVN VREFP VREFN \
		VCCPINT VCCPAUX VCCODDR] {
		echo "$ch [format %.3f [xadc_sup [xadc_single $tap $ch]]] V"
	}
}
#
# Altera USB-Blaster
#
# http://www.altera.com/literature/ug/ug_usb_blstr.pdf
#

adapter driver usb_blaster
usb_blaster_lowlevel_driver ftdi
# These are already the defaults.
# usb_blaster_vid_pid 0x09FB 0x6001
# usb_blaster_device_desc "USB-Blaster"
#
# Altera USB-Blaster II
#

adapter driver usb_blaster
usb_blaster_vid_pid 0x09fb 0x6010 0x09fb 0x6810
usb_blaster_lowlevel_driver ublast2
usb_blaster_firmware /path/to/quartus/blaster_6810.hex
#
# Olimex ARM-JTAG-EW
#
# http://www.olimex.com/dev/arm-jtag-ew.html
#

adapter driver arm-jtag-ew
#
# Various Atmel AT91RM9200 boards
#
# TODO: URL?
#

adapter driver at91rm9200
at91rm9200_device rea_ecr
#
# Buspirate with OpenOCD support
#
# http://dangerousprototypes.com/bus-pirate-manual/
#

adapter driver buspirate

# you need to specify port on which BP lives
#buspirate_port /dev/ttyUSB0

# communication speed setting
buspirate_speed normal ;# or fast

# voltage regulator Enabled = 1 Disabled = 0
#buspirate_vreg 0

# pin mode normal or open-drain (jtag only)
#buspirate_mode normal

# pullup state Enabled = 1 Disabled = 0
#buspirate_pullup 0

# this depends on the cable, you are safe with this option
reset_config srst_only
#
# CALAO Systems USB-A9260 common -C01 -C02 setup
#
# http://www.calao-systems.com/
#
# See calao-usb-a9260-c01.cfg and calao-usb-a9260-c02.cfg.
#

adapter srst delay 200
jtag_ntrst_delay 200
#
# Amontec Chameleon POD
#
# http://www.amontec.com/chameleon.shtml
#

adapter driver parport
parport_cable chameleon
#
# ARM CMSIS-DAP compliant adapter
#
# http://www.keil.com/support/man/docs/dapdebug/
#

adapter driver cmsis-dap

# Optionally specify the serial number of CMSIS-DAP usb device.
#cmsis_dap_serial 02200201E6661E601B98E3B9
# SPDX-License-Identifier: GPL-2.0-or-later

# Use DLN-2 GPIO through linuxgpiod
#
# +-----------+-------------+-------------+
# | signal    | DLN-2       | gpio offset |
# +-----------+-------------+-------------+
# | nSRST     | J3.1  (PA0) | 0           |
# | TDO       | J3.2  (PA1) | 1           |
# | TCK/SWCLK | J3.3  (PA2) | 2           |
# | TMS/SWDIO | J3.4  (PA3) | 3           |
# | TDI       | J3.5  (PA4) | 4           |
# | nTRST     | J3.6  (PA5) | 5           |
# | LED       | J3.7  (PA6) | 6           |
# | GND       | J3.12 (GND) |             |
# +-----------+-------------+-------------+

adapter driver linuxgpiod

linuxgpiod_gpiochip 0
linuxgpiod_jtag_nums 2 3 4 1
linuxgpiod_trst_num 5
linuxgpiod_swd_nums 2 3
linuxgpiod_srst_num 0
linuxgpiod_led_num 6

reset_config trst_and_srst separate srst_push_pull
#
# Dummy interface (for testing purposes)
#

adapter driver dummy
#
# eStick
#
# http://code.google.com/p/estick-jtag/
#

adapter driver opendous
#
# ST FlashLINK JTAG parallel cable
#
# http://www.st.com/internet/evalboard/product/94023.jsp
# http://www.st.com/stonline/products/literature/um/7889.pdf
#

if { [info exists PARPORTADDR] } {
   set _PARPORTADDR $PARPORTADDR
} else {
   set _PARPORTADDR 0
}

adapter driver parport
parport_port $_PARPORTADDR
parport_cable flashlink
adapter driver ft232r
adapter speed 1000
#
# www.100ask.org OpenJTAG
#
# http://www.100ask.net/OpenJTAG.html
#
# Schematics are available from
# https://blog.matthiasbock.net/wp-content/uploads/2015/04/100ask-JTAGv3.pdf
#

adapter driver ftdi
ftdi_device_desc "USB<=>JTAG&RS232"
ftdi_vid_pid 0x1457 0x5118

ftdi_layout_init 0x0f08 0x0f1b
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
#
# Axiom axm0432
#
# http://www.axman.com
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Symphony SoundBite"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0c08 0x0c2b
ftdi_layout_signal nTRST -data 0x0800
ftdi_layout_signal nSRST -data 0x0400
# FTDI USB Hi-Speed to MPSSE Cable
#
# http://www.ftdichip.com/Products/Cables/USBMPSSE.htm
#
# C232HM-DDHSL-0 and C232HM-EDSL-0 provide 3.3V and 5V on pin 1 (Red),
# respectively.
#
# Adapter: http://www.ftdichip.com/Support/Documents/DataSheets/Cables/DS_C232HM_MPSSE_CABLE.PDF
# Chip: http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232H.pdf
# See pinout/colors at end of this file.
#
# Tech notes:
# http://www.ftdichip.com/Support/Documents/AppNotes/AN_135_MPSSE_Basics.pdf
# http://www.ftdichip.com/Support/Documents/AppNotes/AN_129_FTDI_Hi_Speed_USB_To_JTAG_Example.pdf

adapter driver ftdi
#ftdi_device_desc "C232HM-DDHSL-0"
#ftdi_device_desc "C232HM-EDHSL-0"

# Common PID for FT232H
ftdi_vid_pid 0x0403 0x6014

# Layout
# High data byte 0x40 configures red LED on ACBUS6 initially high (unlit, since active-low)
# Low data byte 0x08 configures TMS on ACBUS3 initially high (asserted); TCK, TDI low
# High direction byte 0x40 configures red LED on ACBUS6 as high (output)
# Low direction byte 0x0b configures TDO on ACBUS2 as low (input)
ftdi_layout_init 0x4008 0x400b

# ---A*BUS-------CCCCCCCC|DDDDDDDD
# --------\______76543210|76543210
# LED	0x4000 = 01000000|00000000 = ACBUS6
#GPIOL0	0x0010 = 00000000|00010000 = ADBUS4
#GPIOL1	0x0020 = 00000000|00100000 = ADBUS5
#GPIOL2	0x0040 = 00000000|01000000 = ADBUS6
#GPIOL3	0x0080 = 00000000|10000000 = ADBUS7
# -ndata treats the LED as active-low for expected behavior (toggle when transferring)
ftdi_layout_signal LED -ndata 0x4000
# Available for aliasing as desired
ftdi_layout_signal GPIOL0 -data 0x0010 -oe 0x0010
ftdi_layout_signal GPIOL1 -data 0x0020 -oe 0x0020
ftdi_layout_signal GPIOL2 -data 0x0040 -oe 0x0040
ftdi_layout_signal GPIOL3 -data 0x0080 -oe 0x0080

# C232HM		FT232H	JTAG/Other
# Num	Color	Name	Func
# 1		Red		VCC		Optionally, can power the board if it is not using its own power supply.
# 2		Orange	ADBUS0	TCK
# 3		Yellow  ADBUS1	TDI
# 4		Green	ADBUS2	TDO
# 5		Brown   ADBUS3	TMS
# 6		Grey	ADBUS4	GPIOL0
# 7		Purple	ADBUS5	GPIOL1
# 8		White	ADBUS6	GPIOL2
# 9		Blue	ADBUS7	GPIOL3
# 10	Black	GND		Connect to ground
#
# CALAO Systems USB-A9260-C01
#
# http://www.calao-systems.com/
#

echo "WARNING!"
echo "This file was not tested with real interface, but is assumed to work as this"
echo "interface uses the same layout as configs that were verified. Please report your"
echo "experience with this file to openocd-devel mailing list, so it could be marked"
echo "as working or fixed."

adapter driver ftdi
ftdi_device_desc "USB-A9260"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800

script interface/calao-usb-a9260.cfg
script target/at91sam9260minimal.cfg
#
# CALAO Systems USB-A9260-C02
#
# http://www.calao-systems.com/
#

echo "WARNING!"
echo "This file was not tested with real interface, but is assumed to work as this"
echo "interface uses the same layout as configs that were verified. Please report your"
echo "experience with this file to openocd-devel mailing list, so it could be marked"
echo "as working or fixed."

adapter driver ftdi
ftdi_device_desc "USB-A9260"
ftdi_vid_pid 0x0403 0x6001

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800

script interface/calao-usb-a9260.cfg
script target/at91sam9260minimal.cfg
#
# Hitex Cortino
#
# http://www.hitex.com/index.php?id=cortino
#

adapter driver ftdi
ftdi_device_desc "Cortino"
ftdi_vid_pid 0x0640 0x0032

ftdi_layout_init 0x0108 0x010b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200
# this supports JTAG-HS1 and JTAG-SMT1
# (the later being the OEM on-board version)

adapter driver ftdi
ftdi_device_desc "Digilent Adept USB Device"
ftdi_vid_pid 0x0403 0x6010
# channel 1 does not have any functionality
ftdi_channel 0
# just TCK TDI TDO TMS, no reset
ftdi_layout_init 0x0088 0x008b
reset_config none
# this supports JTAG-HS2 (and apparently Nexys4 as well)

adapter driver ftdi
ftdi_device_desc "Digilent Adept USB Device"
ftdi_vid_pid 0x0403 0x6014

ftdi_channel 0
ftdi_layout_init 0x00e8 0x60eb

reset_config none
#
# Digilent JTAG-HS3
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6014
ftdi_device_desc "Digilent USB Device"

# From Digilent support:
# The SRST pin is [...] 0x20 and 0x10 is the /OE (active low output enable)

ftdi_layout_init 0x2088 0x308b
ftdi_layout_signal nSRST -data 0x2000 -noe 0x1000
#
# Digilent JTAG-SMT2
#
# http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,395,1053&Prod=JTAG-SMT2
#
# Config is based on data from
# http://electronix.ru/forum/index.php?showtopic=114633&view=findpost&p=1215497 and ZedBoard schematics
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6014

ftdi_layout_init 0x2088 0x3f8b
ftdi_layout_signal nSRST -data 0x2000
ftdi_layout_signal GPIO2 -data 0x2000
ftdi_layout_signal GPIO1 -data 0x0200
ftdi_layout_signal GPIO0 -data 0x0100
#
# Digilent JTAG-SMT2-NC
#
# http://store.digilentinc.com/jtag-smt2-nc-surface-mount-programming-module/
# https://reference.digilentinc.com/_media/jtag_smt2nc/jtag-smt2-nc_rm.pdf
#
# Based on reference sheet (above) and Xilinx KCU105 schematics
# https://www.xilinx.com/products/boards-and-kits/kcu105.html#documentation
#
# Note that the digilent_jtag_smt2 layout does not work and hangs while
# the ftdi_device_desc from digilent_hs2 is wrong.

adapter driver ftdi
ftdi_device_desc "Digilent USB Device"
ftdi_vid_pid 0x0403 0x6014
ftdi_channel 0
ftdi_layout_init 0x00e8 0x60eb
reset_config none
#
# DLP Design DLP-USB1232H USB-to-UART/FIFO interface module
#
# http://www.dlpdesign.com/usb/usb1232h.shtml
#
# Schematics for OpenOCD usage:
# http://randomprojects.org/wiki/DLP-USB1232H_and_OpenOCD_based_JTAG_adapter
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on schematics and code"
echo "in ft2232.c. Please report your experience with this file to openocd-devel"
echo "mailing list, so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0040 -oe 0x0040
#
# Dangerous Prototypes - Bus Blaster
#
# The Bus Blaster has a configurable buffer between the FTDI FT2232H and the
# JTAG header which allows it to emulate various debugger types. It comes
# configured as a JTAGkey device.
#
# http://dangerousprototypes.com/docs/Bus_Blaster
#

echo "Info : If you need SWD support, flash KT-Link buffer from https://github.com/bharrisau/busblaster
and use dp_busblaster_kt-link.cfg instead"

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
#
# Dangerous Prototypes - Bus Blaster (with KT-Link buffer)
#
# The Bus Blaster has a configurable buffer between the FTDI FT2232H
# and the JTAG header which allows it to emulate various debugger
# types. This config works with KT-Link compatible implementation from
# https://github.com/bharrisau/busblaster and is SWD-enabled.
#
# http://dangerousprototypes.com/docs/Bus_Blaster
#

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x8c28 0xff3b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
ftdi_layout_signal LED -ndata 0x8000
ftdi_layout_signal SWD_EN -ndata 0x0020 -oe 0x2000
ftdi_layout_signal SWDIO_OE -ndata 0x1000
#
# FlossJTAG
#
# http://github.com/esden/floss-jtag
#
# This is the pre v0.3 Floss-JTAG compatible config file. It can also be used
# for newer versions of Floss-JTAG with empty or not populated EEPROM. If you
# have several Floss-JTAG connected you have to use the USB ID to select a
# specific one.
#
# If you have a Floss-JTAG WITH EEPROM that is programmed, use the
# flossjtag.cfg file.
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0040 -oe 0x0040
#
# FlossJTAG
#
# http://github.com/esden/floss-jtag
#
# This is the v0.3 and v1.0 Floss-JTAG compatible config file. It relies on the
# existence of an EEPROM on Floss-JTAG containing a name. If you have several
# Floss-JTAG adapters connected you can use the serial number to select a
# specific device.
#
# If your Floss-JTAG does not have an EEPROM, or the EEPROM is empty, use the
# flossjtag-noeeprom.cfg file.
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_device_desc "FLOSS-JTAG"
#ftdi_serial "FJ000001"

ftdi_layout_init 0x0008 0x180b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0040 -oe 0x0040
ftdi_layout_signal LED -data 0x0800
ftdi_layout_signal LED2 -data 0x1000
#
# TinCanTools Flyswatter
#
# http://www.tincantools.com/product.php?productid=16134
#

adapter driver ftdi
ftdi_device_desc "Flyswatter"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0818 0x0cfb
ftdi_layout_signal nTRST -data 0x0010
ftdi_layout_signal nSRST -oe 0x0020
ftdi_layout_signal LED -data 0x0c00
#
# TinCanTools Flyswatter2
#
# http://www.tincantools.com/product.php?productid=16153
#

adapter driver ftdi
ftdi_device_desc "Flyswatter2"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0538 0x057b
ftdi_layout_signal LED -ndata 0x0400
ftdi_layout_signal nTRST -data 0x0010
ftdi_layout_signal nSRST -data 0x0020 -noe 0x0100
#
# ADAFRUIT FTDI FT232H as a SWD direct connect interface
# Any FT232H based board may work
#
# http://www.ftdichip.com/Products/ICs/FT232H.htm
#
#

adapter driver ftdi

ftdi_vid_pid 0x0403 0x6014

# data MSB..LSB       direction (1:out) MSB..LSB
# 0000'0000'0011'0000 0000'0000'0011'1011
ftdi_layout_init 0x0030 0x003b
# 0xfff8 0xfffb
# Those signal are only required on some platforms or may required to be
# enabled explicitly (e.g. nrf5x chips).
ftdi_layout_signal nSRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nTRST -data 0x0020 -oe 0x0020

# swd enable
ftdi_layout_signal SWD_EN -data 0
# tri-state (configure as input) TDO/TIO when reading
ftdi_layout_signal SWDIO_OE -data 0

transport select swd

# re-configure TDO as tri-state
#ftdi_layout_signal TDO -data 0x0002 -oe 0x0002
#ftdi_layout_signal TDI -data 0x0004

# Adafruit      FT232H    JTAG       SWD
# Name  Pin     Name      Func       Func
#  D0   J1-3    ADBUS0    TCK        SWDCLK
#  D1   J1-4    ADBUS1    TDO/DI     SWDIO
#  D2   J1-5    ADBUS2    TDI/DO     SWDIO
#  D3   J1-6    ADBUS3    TMS        N/A
#  D4   J1-7    ADBUS4    (GPIOL0)   /nSRST  optional module reset
#  D5   J1-8    ADBUS5    (GPIOL1)   /nTRST  optional target reset
#  D6   J1-9    ADBUS6    (GPIOL2)
#  D7   J1-10   ADBUS7    (GPIOL3)
#  C0   J2-1    ACBUS0    (GPIOH0)
#  C1   J2-2    ACBUS1    (GPIOH1)
#  C2   J2-3    ACBUS2    (GPIOH2)
#  C3   J2-4    ACBUS3    (GPIOH3)
#  C4   J2-5    ACBUS4    (GPIOH4)
#  C5   J2-6    ACBUS5    (GPIOH5)
#  C6   J2-7    ACBUS6    (GPIOH6)
#  C7   J2-8    ACBUS7    (GPIOH7)
#  C8   J2-9    ACBUS8
#  C9   J2-10   ACBUS9
#
# Gateworks GW16042 JTAG Dongle
#
# http://www.gateworks.com/
#
# Layout:  FTDI FT2232H
#   ADBUS0 TCK
#   ADBUS1 TDI
#   ADBUS2 TDO (input)
#   ADBUS3 TMS
#   ADBUS4 nTRST
#   ADBUS5 nSRST
#   ADBUS6 OE (active high) for TRST, TDI, TMS, TCK
#   ADBUS7 NC
#   ACBUS0-7 NC
#   BDBUS0 RXD
#   BDBUS1 TXD (input)
#

adapter driver ftdi
ftdi_device_desc "USB-JTAG"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0058 0x007b
ftdi_layout_signal nTRST -data 0x0010
ftdi_layout_signal nSRST -oe 0x0020
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Hofstdtler Industrie-Electronic (HIE) JTAG Debugger
#
# https://www.hofstaedtler.com/jtag
#

adapter driver ftdi
ftdi_channel 0
ftdi_vid_pid 0x0403 0x6014
ftdi_device_desc "HIE JTAG Debugger"

ftdi_layout_init 0x0c08 0x4f1b

# define both Reset signals
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800

# Toggle USB LED
ftdi_layout_signal LED -ndata 0x4000
#
# Hilscher NXHX 10-ETM
#
# http://de.hilscher.com/products_details_hardware.html?p_id=P_4ce145a5983e6
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "NXHX 10-ETM"
ftdi_vid_pid 0x0640 0x0028

ftdi_layout_init 0x0308 0x030b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200
#
# Hilscher NXHX 500-ETM
#
# http://de.hilscher.com/files_design/8/NXHX500-ETM_description_Rev01_EN.pdf
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "NXHX 500-ETM"
ftdi_vid_pid 0x0640 0x0028

ftdi_layout_init 0x0308 0x030b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200
#
# Hilscher NXHX 500-RE
#
# http://de.hilscher.com/products_details_hardware.html?p_id=P_461ff2053bad1&bs=20
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "NXHX 500-RE"
ftdi_vid_pid 0x0640 0x0028

ftdi_layout_init 0x0308 0x030b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200
#
# Hilscher NXHX 50-ETM
#
# http://de.hilscher.com/files_design/8/NXHX50-ETM_description_Rev01_EN.pdf
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "NXHX 50-ETM"
ftdi_vid_pid 0x0640 0x0028

ftdi_layout_init 0x0308 0x030b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200
#
# Hilscher NXHX 50-RE
#
# http://de.hilscher.com/products_details_hardware.html?p_id=P_483c0f582ad36&bs=20
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "NXHX50-RE"
ftdi_vid_pid 0x0640 0x0028

ftdi_layout_init 0x0308 0x030b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200
#
# Hitex LPC1768-Stick
#
# http://www.hitex.com/?id=1602
#


adapter driver ftdi
ftdi_device_desc "LPC1768-Stick"
ftdi_vid_pid 0x0640 0x0026

ftdi_layout_init 0x0388 0x038b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0080 -noe 0x200
#
# Hitex STR9-comStick
#
# http://www.hitex.com/index.php?id=383
#

adapter driver ftdi
ftdi_device_desc "STR9-comStick"
ftdi_vid_pid 0x0640 0x002c

ftdi_layout_init 0x0108 0x010b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200
#
# Section5 ICEBear
#
# http://section5.ch/icebear
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "ICEbear JTAG adapter"
ftdi_vid_pid 0x0403 0xc140

ftdi_layout_init 0x0028 0x002b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0020
#
# Configuration file for NXP MC-IMX8MP-EVK on-board internal JTAG
#
# Using this interface requires enabling "remote mode" for the board using the
# NXP bcu tool (see https://github.com/NXPmicro/bcu)
#
#	bcu set_gpio remote_en 1 -board=imx8mpevk
#
# The REMOTE_EN gpio is accessible through the same FTDI adapter but it's
# behind an I2C GPIO expander.
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6011
ftdi_channel 0

ftdi_layout_init 0x00f8 0x000b

ftdi_layout_signal RESET_B	-data 0x0010 -oe 0x0010
# Called SYS_nRST in schematics
ftdi_layout_signal nSRST	-data 0x0020 -oe 0x0020
ftdi_layout_signal IO_nRST	-data 0x0040 -oe 0x0040
ftdi_layout_signal ONOFF_B	-data 0x0080 -oe 0x0080

ftdi_layout_signal GPIO1	-data 0x0100 -oe 0x0100
ftdi_layout_signal GPIO2	-data 0x0200 -oe 0x0200
ftdi_layout_signal GPIO3	-data 0x0400 -oe 0x0400
ftdi_layout_signal GPIO4	-data 0x0800 -oe 0x0800
#
# In-Circuit's ICprog OpenOCD JTAG Adapter
# https://shop.in-circuit.de/product_info.php?products_id=112
#
# Schematics available at
# http://wiki.in-circuit.de/images/0/06/610000158A_openocd.pdf
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nSRST -noe 0x0400 -data 0x0800
ftdi_layout_signal nTRST -noe 0x0100 -data 0x0200
#
# This is the integrated adapter as found on the IoT-LAB boards
# https://github.com/iot-lab/iot-lab/wiki
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0040 -oe 0x0040
# isodebug v1
# 5 kV isolated JTAG/SWD + UART adapter by Unjo AB

adapter driver ftdi
ftdi_vid_pid 0x22b7 0x150d

ftdi_layout_init 0x0ff8 0xfffb

ftdi_layout_signal LED -ndata 0x0100
ftdi_layout_signal nTRST -data 0x0200
ftdi_layout_signal nSRST -noe 0x0400
ftdi_layout_signal SWDIO_OE -data 0x0008

# Mode signals, either of these needs to be high to drive the JTAG/SWD pins.
# The power-on state is low for both signals but the init setting above sets
# JTAG_EN high.
ftdi_layout_signal SWD_EN -data 0x1000
ftdi_layout_signal JTAG_EN -data 0x0800

# In SWD mode, the JTAG_EN signal doubles as SWO_EN_N which switches the
# second FTDI channel UART RxD to the SWO pin instead of the separate RxD
# pin. Note that the default init state has this pin high so when OpenOCD
# starts in SWD mode, SWO is by default disabled. To enable SWO tracing,
# issue the command 'ftdi_set_signal SWO_EN 1' where tracing is configured.
# To switch back to using the separate UART, SWO_EN needs to be disabled
# before exiting OpenOCD, or the adapter replugged.
ftdi_layout_signal SWO_EN -nalias JTAG_EN
#
# DISTORTEC JTAG-lock-pick Tiny 2
#
# http://www.distortec.com
#

adapter driver ftdi
ftdi_device_desc "JTAG-lock-pick Tiny 2"
ftdi_vid_pid 0x0403 0x8220

ftdi_layout_init 0x8c28 0xff3b
ftdi_layout_signal SWD_EN -ndata 0x0020 -oe 0x2000
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
ftdi_layout_signal SWDIO_OE -ndata 0x1000
ftdi_layout_signal LED -ndata 0x8000
#
# Amontec JTAGkey
#
# http://www.amontec.com/jtagkey.shtml
#

adapter driver ftdi
ftdi_device_desc "Amontec JTAGkey"
ftdi_vid_pid 0x0403 0xcff8

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
#
# Amontec JTAGkey2
#
# http://www.amontec.com/jtagkey2.shtml
#

adapter driver ftdi
ftdi_device_desc "Amontec JTAGkey-2"
ftdi_vid_pid 0x0403 0xcff8

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
#
# Amontec JTAGkey2P
#
# http://www.amontec.com/jtagkey2p.shtml
#

adapter driver ftdi
ftdi_device_desc "Amontec JTAGkey-2P"
ftdi_vid_pid 0x0403 0xcff8

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
#
# Kristech KT-Link
#
# http://www.kristech.eu
#

adapter driver ftdi
ftdi_device_desc "KT-LINK"
ftdi_vid_pid 0x0403 0xbbe2

ftdi_layout_init 0x8c28 0xff3b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
ftdi_layout_signal LED -data 0x8000
ftdi_layout_signal SWD_EN -ndata 0x0020 -oe 0x2000
ftdi_layout_signal SWDIO_OE -ndata 0x1000
#
# Lisa/L
#
# http://paparazzi.enac.fr/wiki/Lisa
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on schematics and code"
echo "in ft2232.c. Please report your experience with this file to openocd-devel"
echo "mailing list, so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Lisa/L"
ftdi_vid_pid 0x0403 0x6010
ftdi_channel 1

ftdi_layout_init 0x0008 0x180b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0040 -oe 0x0040
ftdi_layout_signal LED -data 0x1800
#
# Luminary Micro Stellaris LM3S9B9x Evaluation Kits
# In-Circuit Debug Interface (ICDI) Board
#
# Essentially all Luminary debug hardware is the same, (with both
# JTAG and SWD support compatible with ICDI boards.  This ICDI adapter
# configuration is JTAG-only, but the same hardware handles SWD too.
#
# This is a discrete ftdi based debug board which supports ARM's
# JTAG/SWD connectors in both backwards-compatible 20-pin format and
# in the new-style compact 10-pin.  There's also an 8-pin connector
# with serial port support.  It's included with LM3S9B9x eval boards.
#
# http://www.luminarymicro.com/products/ek-lm3s9b90.html
# http://www.luminarymicro.com/products/ek-lm3s9b92.html
#

adapter driver ftdi
ftdi_device_desc "Luminary Micro ICDI Board"
ftdi_vid_pid 0x0403 0xbcda

ftdi_layout_init 0x00a8 0x00eb
ftdi_layout_signal nSRST -noe 0x0020
ftdi_layout_signal SWD_EN -ndata 0x0080
ftdi_layout_signal SWDIO_OE -data 0x0008
#
# Luminary Micro Stellaris LM3S811 Evaluation Kit
#
# http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
#
# NOTE:  this is only for boards *before* Rev C, which adds support
# for SWO tracing with ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN signals.
# The "evb_lm3s811" layout doesn't set up those signals.
#
# Rev C boards work more like the other Stellaris eval boards.  They
# need to use the "luminary_icdi" layout to work correctly.
#

adapter driver ftdi
ftdi_device_desc "LM3S811 Evaluation Board"
ftdi_vid_pid 0x0403 0xbcd9

ftdi_layout_init 0x0088 0x008b
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
ftdi_layout_signal SWD_EN -ndata 0x0080
ftdi_layout_signal SWDIO_OE -data 0x0008
#
# Luminary Micro Stellaris Evaluation Kits
#
# http://www.luminarymicro.com/products/evaluation_kits.html
#
# There are a number of evaluation kits for Stellaris Cortex-M3 chips.
# Currently they all bundle ftdi based debug support.  When that is
# used (instead of an external adapter), use this config file in one
# of these two modes:
#
# - Eval board debug ... debug of the Stellaris chip via port A.
#
# - Other board debug ... same thing, but the board acts as a debug
#   adapter for another board (using a standard ARM JTAG connector).
#   The Stellaris chip stays in reset.
#
# Those support both JTAG and SWD.  SWD is an ARM-only two-wire debug
# protocol; in 2009, OpenOCD does not support SWD.
#
# Port B of the ftdi chip is normally used as a serial link to the
# Stellaris chip.  On most boards (but not older LM3S811 eval boards),
# when SWD is used Port B may instead be used to read low-bandwidth
# "SWO trace" data, including so-called "printf style" output from
# firmware via the ITM module as well as profile data.
#

adapter driver ftdi
ftdi_device_desc "Stellaris Evaluation Board"
ftdi_vid_pid 0x0403 0xbcd9

ftdi_layout_init 0x00a8 0x00eb
ftdi_layout_signal nSRST -noe 0x0020
ftdi_layout_signal SWD_EN -ndata 0x0080
ftdi_layout_signal SWDIO_OE -data 0x0008
#
# DENX M53EVK
#
# http://www.denx-cs.de/?q=M53EVK
#

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_channel 0
ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
#
# MBFTDI
#
# http://www.marsohod.org/prodmbftdi
#
# Also the Marsohod2 and the Marsohod3 boards
# include a built-in MBFTDI for FPGA programming.
# See http://www.marsohod.org/prodmarsohod2
# and http://www.marsohod.org/plata-marsokhod3 for details.
#

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0008 0x000b
#
# Supports SWD using the FT2232H or FT4232H minimodule.
# Each can support 2 SWD interfaces.
#
# FT2232H or FT4232H minimodule channel 0 (Channel A)
# Connector  FTDI              Target
# Pin        Name
# ---------  ------            ------
# CN2-11     VIO               VDD_IO (Or connect to CN2-5 on the minimodule instead for a 3V3 interface)
# CN2-2      GND               GND
# CN2-7      ADBUS0 (TCK)      SWCLK
# CN2-9      ADBUS2 (TDI/TDO)  SWDIO
# CN2-10     ADBUS1 (TDO/TDI)  SWDIO
# CN2-14     ADBUS4 (GPIOL0)   nRESET
#
# FT2232H minimodule channel 1 (Channel B)
# FTDI       Target
# ----       ------
# CN2-11  -  VDD_IO
# CN2-2   -  GND
# CN3-26  -  SWCLK
# CN3-25  -  SWDIO
# CN3-24  -  SWDIO
# CN3-21  -  nRESET
#
# FT4232H minimodule channel 1 (Channel B)
# FTDI       Target
# ----       ------
# CN2-11  -  VDD_IO
# CN2-2   -  GND
# CN2-18  -  SWCLK
# CN2-17  -  SWDIO
# CN2-20  -  SWDIO
# CN2-22  -  nRESET
#

adapter driver ftdi

#Select your module type and channel

#ftdi_device_desc "FT2232H MiniModule"
ftdi_vid_pid 0x0403 0x6010
#ftdi_channel 1

#ftdi_device_desc "FT4232H MiniModule"
#ftdi_vid_pid 0x0403 0x6011
#ftdi_channel 1

ftdi_layout_init 0x0000 0x000b
ftdi_layout_signal nSRST -data 0x0010 -oe 0x0010
ftdi_layout_signal SWD_EN -data 0
ftdi_layout_signal SWDIO_OE -data 0

transport select swd
#
# FTDI MiniModule
#
# http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf
#

adapter driver ftdi
ftdi_device_desc "FT2232H MiniModule"
ftdi_vid_pid 0x0403 0x6010

# Every pin set as high impedance except TCK, TDI, TDO and TMS
ftdi_layout_init 0x0008 0x000b

# nSRST defined on pin CN2-13 of the MiniModule (pin ADBUS5 [AD5] on the FT2232H chip)
# This choice is arbitrary. Use other GPIO pin if desired.
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
# https://www.scarabhardware.com/minispartan6/
# https://github.com/scarabhardware/miniSpartan6-plus/raw/master/miniSpartan6%2B_Rev_B.pdf
adapter driver ftdi
# The miniSpartan6+ sadly doesn't have a custom device description, so we just
# have to hope you got it right.
#ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010
# interface 1 is the uart
ftdi_channel 0
# just TCK TDI TDO TMS, no reset
ftdi_layout_init 0x0008 0x000b
reset_config none
# this generally works fast: the fpga can handle 30MHz, the spi flash can handle
# 54MHz with simple read, no dummy cycles, and wait-for-write-completion
adapter speed 30000
#
# Openmoko USB JTAG/RS232 adapter
#
# http://wiki.openmoko.org/wiki/Debug_Board_v3
#

adapter driver ftdi
ftdi_device_desc "Debug Board for Neo1973"
ftdi_vid_pid 0x1457 0x5118

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
ftdi_layout_signal nNOR_WP -data 0x0010 -oe 0x0010
#
# NGX ARM USB JTAG
#
# http://shop.ngxtechnologies.com/product_info.php?cPath=26&products_id=30
#

echo "WARNING!"
echo "This file was not tested with real interface, but is assumed to work as this"
echo "interface uses the same layout as configs that were verified. Please report your"
echo "experience with this file to openocd-devel mailing list, so it could be marked"
echo "as working or fixed."

adapter driver ftdi
ftdi_device_desc "NGX JTAG"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
#
# Olimex ARM JTAG SWD adapter
# https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-SWD/
#

transport select swd

ftdi_layout_signal SWD_EN -nalias nTRST
ftdi_layout_signal SWDIO_OE -alias TMS
#
# Olimex ARM-USB-OCD-H
#
# http://www.olimex.com/dev/arm-usb-ocd-h.html
#

adapter driver ftdi
ftdi_device_desc "Olimex OpenOCD JTAG ARM-USB-OCD-H"
ftdi_vid_pid 0x15ba 0x002b

ftdi_layout_init 0x0908 0x0b1b
ftdi_layout_signal nSRST -oe 0x0200
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal LED -data 0x0800
#
# Olimex ARM-USB-OCD
#
# http://www.olimex.com/dev/arm-usb-ocd.html
#

adapter driver ftdi
ftdi_device_desc "Olimex OpenOCD JTAG"
ftdi_vid_pid 0x15ba 0x0003

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nSRST -oe 0x0200
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal LED -data 0x0800
#
# Olimex ARM-USB-TINY-H
#
# http://www.olimex.com/dev/arm-usb-tiny-h.html
#

adapter driver ftdi
ftdi_device_desc "Olimex OpenOCD JTAG ARM-USB-TINY-H"
ftdi_vid_pid 0x15ba 0x002a

ftdi_layout_init 0x0808 0x0a1b
ftdi_layout_signal nSRST -oe 0x0200
ftdi_layout_signal nTRST -data 0x0100 -oe 0x0100
ftdi_layout_signal LED -data 0x0800
#
# Olimex ARM-USB-TINY
#
# http://www.olimex.com/dev/arm-usb-tiny.html
#

adapter driver ftdi
ftdi_device_desc "Olimex OpenOCD JTAG TINY"
ftdi_vid_pid 0x15ba 0x0004

ftdi_layout_init 0x0808 0x0a1b
ftdi_layout_signal nSRST -oe 0x0200
ftdi_layout_signal nTRST -data 0x0100 -oe 0x0100
ftdi_layout_signal LED -data 0x0800
#
# Joern Kaipf's OOCDLink
#
# http://www.joernonline.de/contrexx2/cms/index.php?page=126
#

echo "WARNING!"
echo "This file was not tested with real interface, but is assumed to work as this"
echo "interface uses the same layout as configs that were verified. Please report your"
echo "experience with this file to openocd-devel mailing list, so it could be marked"
echo "as working or fixed."

adapter driver ftdi
ftdi_device_desc "OOCDLink"
ftdi_vid_pid 0x0403 0xbaf8

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
#
# Opendous
#
# http://code.google.com/p/opendous/wiki/JTAG
#
# According to the website, it is similar to jtagkey, but it uses channel B
# (and it has a different pid number).
#

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010
ftdi_channel 1

ftdi_layout_init 0x0c08 0x0f1b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
#
# embedded projects openocd usb adapter v3
#
# http://shop.embedded-projects.net/index.php?module=artikel&action=artikel&id=14
#

adapter driver ftdi
ftdi_device_desc "Dual RS232-HS"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
#
# Hubert Hoegl's USB to JTAG
#
# http://www.hs-augsburg.de/~hhoegl/proj/usbjtag/usbjtag.html
#

adapter driver ftdi
ftdi_device_desc "Dual RS232"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
#
# Marvell OpenRD
#
# http://www.marvell.com/products/embedded_processors/developer/kirkwood/openrd.jsp
#

adapter driver ftdi
ftdi_device_desc "OpenRD JTAGKey FT2232D B"
ftdi_vid_pid 0x0403 0x9e90
ftdi_channel 0

ftdi_layout_init 0x0608 0x0f1b
ftdi_layout_signal nTRST -data 0x0200
ftdi_layout_signal nSRST -noe 0x0400
# http://pipistrello.saanlima.com/
# http://www.saanlima.com/download/pipistrello-v2.0/pipistrello_v2_schematic.pdf
adapter driver ftdi
ftdi_device_desc "Pipistrello LX45"
ftdi_vid_pid 0x0403 0x6010
# interface 1 is the uart
ftdi_channel 0
# just TCK TDI TDO TMS, no reset
ftdi_layout_init 0x0008 0x000b
reset_config none
# this generally works fast: the fpga can handle 30MHz, the spi flash can handle
# 54MHz with simple read, no dummy cycles, and wait-for-write-completion
adapter speed 10000
#
# Redwire Redbee-Econotag
#
# http://www.redwirellc.com/store/node/1
#
# The Redbee-Econotag has an onboard FT2232H with:
#  - FT2232H channel A wired to mc13224v JTAG
#  - FT2232H channel B wired to mc13224v UART1
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0c08 0x0c2b
ftdi_layout_signal nTRST -data 0x0800
ftdi_layout_signal nSRST -data 0x0400
#
# Redwire Redbee-USB
#
# http://www.redwirellc.com
#
# The Redbee-USB has an onboard FT2232H with:
#  - FT2232H channel B wired to mc13224v JTAG
#  - FT2232H channel A wired to mc13224v UART1
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_channel 1

ftdi_layout_init 0x0c08 0x0c2b
ftdi_layout_signal nTRST -data 0x0800
ftdi_layout_signal nSRST -data 0x0400
#
# Rowley ARM SWD Adapter
# http://sites.fastspring.com/rowley/product/armswdadapter
# https://drive.google.com/file/d/0Bzv7UpKpOQhnTUNNdzI5OUR4WGs/edit?usp=sharing
#

transport select swd

ftdi_layout_signal SWD_EN -nalias nTRST
ftdi_layout_signal SWDIO_OE -alias TMS
#
# Marvel SheevaPlug Development Kit
#
# http://www.marvell.com/products/embedded_processors/developer/kirkwood/sheevaplug.jsp
#

adapter driver ftdi
ftdi_device_desc "SheevaPlug JTAGKey FT2232D B"
ftdi_vid_pid 0x9e88 0x9e8f
ftdi_channel 0

ftdi_layout_init 0x0608 0x0f1b
ftdi_layout_signal nTRST -data 0x0200
ftdi_layout_signal nSRST -noe 0x0400
#
# Xverve Signalyzer LITE (DT-USB-SLITE)
#
# http://www.signalyzer.com
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Signalyzer LITE"
ftdi_vid_pid 0x0403 0xbca1

ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
#
# Xverve Signalyzer Tool (DT-USB-ST)
#
# http://www.signalyzer.com
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on code in ft2232.c."
echo "Please report your experience with this file to openocd-devel mailing list,"
echo "so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Signalyzer"
ftdi_vid_pid 0x0403 0xbca0

ftdi_layout_init 0x0008 0x000b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
#  Copyright (C) 2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
#  SPDX-License-Identifier: GPL-2.0-or-later

#
# Synopsys SDP Mainboard has embdded FT2232 chip, which is similar to Digilent
# HS-1, except that it uses channel B for JTAG communication, instead of
# channel A.
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_layout_init 0x0088 0x008b
ftdi_channel 1


# SPDX-License-Identifier: GPL-2.0-or-later

#
# Steppenprobe
# https://github.com/diegoherranz/steppenprobe
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010

# Initial Layout
ftdi_layout_init 0x0058 0x99fb
# Signal        Data    Direction       Notes
# TCK           0       1 (out)
# TDI           0       1 (out)
# TDO           0       0 (in)
# TMS           1       1 (out)         JTAG IEEE std recommendation
# LED           1       1 (out)         LED off
# SWD_EN        0       1 (out)         OpenOCD sets this high for SWD
# SWDIO_OE      1       1 (out)         Ext. buffer tristated
# SRST          0       1 (out)         Translates to nSRST=Z

# Unused        0       1 (out)
# GPIO_A        0       0 (in)
# GPIO_B        0       0 (in)
# Unused        0       1 (out)
# Unused        0       1 (out)
# GPIO_C        0       0 (in)
# GPIO_D        0       0 (in)
# Unused        0       1 (out)

# Signals definition
ftdi_layout_signal LED -ndata 0x0010
ftdi_layout_signal SWD_EN -data 0x0020
ftdi_layout_signal SWDIO_OE -ndata 0x0040
ftdi_layout_signal nSRST -oe 0x0080

ftdi_layout_signal GPIO_A -data 0x0200 -oe 0x0200 -input 0x0200
ftdi_layout_signal GPIO_B -data 0x0400 -oe 0x0400 -input 0x0400
ftdi_layout_signal GPIO_C -data 0x2000 -oe 0x2000 -input 0x2000
ftdi_layout_signal GPIO_D -data 0x4000 -oe 0x4000 -input 0x4000
#
# Hitex STM32-PerformanceStick
#
# http://www.hitex.com/index.php?id=340
#

adapter driver ftdi
ftdi_device_desc "STM32-PerformanceStick"
ftdi_vid_pid 0x0640 0x002d

ftdi_layout_init 0x0388 0x038b
ftdi_layout_signal nTRST -data 0x0100
ftdi_layout_signal nSRST -data 0x0080 -noe 0x200
#
# Connect TDI to SWDIO via a suitable series resistor (220-470 Ohm or
# so depending on the drive capability of the target and adapter);
# connect TDO directly to SWDIO.
#
# You also need to have reliable GND connection between the target and
# adapter. Vref of the adapter should be supplied with a voltage equal
# to the target's (preferrably connect it to Vcc). You can also
# optionally connect nSRST. Leave everything else unconnected.
#
# FTDI                          Target
# ----                          ------
# 1  - Vref   ----------------- Vcc
# 3  - nTRST  -
# 4  - GND    ----------------- GND
# 5  - TDI    ---/\470 Ohm/\--- SWDIO
# 7  - TMS    -
# 9  - TCK    ----------------- SWCLK
# 11 - RTCK   -
# 13 - TDO    ----------------- SWDIO
# 15 - nSRST  - - - - - - - - - nRESET
#

transport select swd

ftdi_layout_signal SWD_EN -data 0
#
# This is an FTDI-based debugging solution as found on some TI boards,
# e.g. CC3200 LaunchPad.
#
# The schematics are identical to luminary-icdi (including SWD
# support) but the USB IDs are different.
#

adapter driver ftdi
ftdi_vid_pid 0x0451 0xc32a

ftdi_layout_init 0x00a8 0x00eb
ftdi_layout_signal nSRST -noe 0x0020
ftdi_layout_signal SWD_EN -ndata 0x0080
ftdi_layout_signal SWDIO_OE -data 0x0008
#
# TIAO USB Multi-Protocol Adapter (TUMPA) Lite
#
# http://www.diygadget.com/tiao-usb-multi-protocol-adapter-lite-jtag-spi-i2c-serial.html
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x8a99

ftdi_layout_init 0x0038 0x087b
ftdi_layout_signal nTRST -data 0x0020 -oe 0x0020
ftdi_layout_signal nSRST -data 0x0010 -oe 0x0010
#
# TIAO USB Multi-Protocol Adapter (TUMPA)
#
# http://www.diygadget.com/tiao-usb-multi-protocol-adapter-jtag-spi-i2c-serial.html
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0x8a98 0x0403 0x6010

ftdi_layout_init 0x0038 0x087b
ftdi_layout_signal nTRST -data 0x0020
ftdi_layout_signal nSRST -data 0x0010

reset_config srst_push_pull
#
# egnite Turtelizer 2 rev B (with SRST only)
#
# http://www.ethernut.de/en/hardware/turtelizer/index.html
#

echo "WARNING!"
echo "This file was not tested with real interface, it is based on schematics and code"
echo "in ft2232.c. Please report your experience with this file to openocd-devel"
echo "mailing list, so it could be marked as working or fixed."

adapter driver ftdi
ftdi_device_desc "Turtelizer JTAG/RS232 Adapter"
ftdi_vid_pid 0x0403 0xbdc8

ftdi_layout_init 0x0008 0x0c5b
ftdi_layout_signal nSRST -oe 0x0040
ftdi_layout_signal LED -data 0x0c00
#
# egnite Turtelizer 2 revC (with TRST and SRST)
#
# http://www.ethernut.de/en/hardware/turtelizer/index.html
#

adapter driver ftdi
ftdi_device_desc "Turtelizer JTAG/RS232 Adapter"
ftdi_vid_pid 0x0403 0xbdc8

ftdi_layout_init 0x0008 0x0c7b
ftdi_layout_signal nTRST -oe 0x0020
ftdi_layout_signal nSRST -oe 0x0040
ftdi_layout_signal LED -ndata 0x0c00
#
# FTDI UM232H as a JTAG interface
#
# http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#UM232H
#
# This should also work with a UM232H-B, but that has not been tested.
# Note that UM232H and UM232H-B are 3.3V only.
#

adapter driver ftdi
#ftdi_device_desc "UM232H"
ftdi_vid_pid 0x0403 0x6014

ftdi_layout_init 0xfff8 0xfffb
ftdi_layout_signal nTRST -data 0x0100 -oe 0x0100
ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200

# UM232H        FT232H    JTAG
# Name  Pin     Name      Func
# AD0   J2-6    ADBUS0    TCK
# AD1   J2-7    ADBUS1    TDI
# AD2   J2-8    ADBUS2    TDO
# AD3   J2-9    ADBUS3    TMS
# AD4   J2-10   ADBUS4    (GPIOL0)
# AD5   J2-11   ADBUS5    (GPIOL1)
# AD6   J2-12   ADBUS6    (GPIOL2)
# AD7   J2-13   ADBUS7    (GPIOL3)
# AD0   J1-14   ACBUS0    /TRST
# AD1   J1-13   ACBUS1    /SRST
# AD2   J1-12   ACBUS2    (GPIOH2)
# AD3   J1-11   ACBUS3    (GPIOH3)
# AD4   J1-10   ACBUS4    (GPIOH4)
# AD5   J1-9    ACBUS5    (GPIOH5)
# AD6   J1-8    ACBUS6    (GPIOH6)
# AD7   J1-7    ACBUS7    (GPIOH7)
#
# Voipac VPACLink
#
# http://voipac.com/27M-JTG-000
#

echo "WARNING!"
echo "This file was not tested with real interface, but is assumed to work as this"
echo "interface uses the same layout as configs that were verified. Please report your"
echo "experience with this file to openocd-devel mailing list, so it could be marked"
echo "as working or fixed."

adapter driver ftdi
ftdi_device_desc "VPACLink"
ftdi_vid_pid 0x0403 0x6010

ftdi_layout_init 0x0508 0x0f1b
ftdi_layout_signal nTRST -data 0x0200 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0800 -noe 0x0400
#
# Texas Instruments XDS100v2
#
# http://processors.wiki.ti.com/index.php/XDS100#XDS100v2_Features
#
# Detailed documentation is available only as CPLD verilog source code
# to the registered TI users.
#

adapter driver ftdi
ftdi_vid_pid 0x0403 0xa6d0 0x0403 0x6010

ftdi_layout_init 0x0038 0x597b

#  8000 z - unused
#  4000 0 > CPLD loopback          (all target side pins high-Z)
#  2000 z < !( cable connected )   (open drain on CPLD side for $reasons)
#  1000 0 > EMU1_oe
#
#   800 0 > PWR_RST = clear power-loss flag on rising edge
#   400 z < !( power-loss flag )
#   200 z < nSRST
#   100 0 > nSRST_oe
#
#    80 z < RTCK
#    40 0 > EMU0_oe
#    20 1 > EMU_EN
#    10 1 > nTRST
#
#     8 1 > TMS
#     4 z < TDO
#     2 0 > TDI
#     1 0 > TCK
#
# As long as the power-loss flag is set, all target-side pins are
# high-Z except the EMU-pins for which the opposite holds unless
# EMU_EN is high.
#
# To use wait-in-reset, drive EMU0 low at power-on reset. If the
# target normally reuses EMU0 for other purposes, clear EMU_EN to
# keep the EMU pins high-Z until the target is power-cycled.
#
# The LED only turns off at USB suspend, which is also the only way to
# set the power-loss flag manually. (Can be done in software e.g. by
# changing the USB configuration to zero.)
#

ftdi_layout_signal nTRST -data 0x0010
ftdi_layout_signal nSRST -oe 0x0100
ftdi_layout_signal EMU_EN -data 0x0020
ftdi_layout_signal EMU0 -oe 0x0040
ftdi_layout_signal EMU1 -oe 0x1000
ftdi_layout_signal PWR_RST -data 0x0800
ftdi_layout_signal LOOPBACK -data 0x4000

echo "\nInfo : to use this adapter you MUST add ``init; ftdi_set_signal PWR_RST 1; jtag arp_init'' to the end of your config file!\n"
# note: rising edge on PWR_RST is also needed after power-cycling the
# target
#
# Texas Instruments XDS100 ver 3.0
#
# http://processors.wiki.ti.com/index.php/XDS100
#

# Version 3.0 is the same as 2.0 as far as OpenOCD is concerned
source [find interface/ftdi/xds100v2.cfg]

# The USB ids are different.
ftdi_vid_pid 0x0403 0xa6d1
#
# Config for using NXP IMX CPU
#
# This is best used with a fast enough buffer but also
# is suitable for direct connection if the target voltage
# matches to host voltage and the cable is short enough.
#
#

adapter driver imx_gpio

# For most IMX processors 0x0209c000
imx_gpio_peripheral_base 0x0209c000

# Transition delay calculation: SPEED_COEFF/khz - SPEED_OFFSET
# These depend on system clock, calibrated for IMX6UL@528MHz
# imx_gpio_speed SPEED_COEFF SPEED_OFFSET
imx_gpio_speed_coeffs 50000 50

# Each of the JTAG lines need a gpio number set: tck tms tdi tdo.
# Example configuration:
# imx_gpio_jtag_nums 6 7 8 9

# SWD interface pins: swclk swdio
# Example configuration:
imx_gpio_swd_nums 1 6

# imx_gpio_trst_num 10
# reset_config trst_only

# imx_gpio_srst_num 11
# reset_config srst_only srst_push_pull

# or if you have both connected,
# reset_config trst_and_srst srst_push_pull
#
# SEGGER J-Link
#
# http://www.segger.com/jlink.html
#

adapter driver jlink

# The serial number can be used to select a specific device in case more than
# one is connected to the host.
#
# Example: Select J-Link with serial number 123456789
#
# jlink serial 123456789
#
# Provide support for the Cadence JTAG BFM
#
# Copyright (c) 2020, Ampere Computing LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program;
#
#

adapter driver jtag_dpi

# Set the DPI JTAG server port
if { [info exists DPI_PORT] } {
   set _DPI_PORT $DPI_PORT
} else {
   set _DPI_PORT 5555
}

# Set the DPI JTAG server address
if { [info exists DPI_ADDRESS] } {
   set _DPI_ADDRESS $DPI_ADDRESS
} else {
   set _DPI_ADDRESS "127.0.0.1"
}

jtag_dpi_set_port $_DPI_PORT
jtag_dpi_set_address $_DPI_ADDRESS
adapter driver jtag_vpi

# Set the VPI JTAG server port
if { [info exists VPI_PORT] } {
   set _VPI_PORT $VPI_PORT
} else {
   set _VPI_PORT 5555
}

# Set the VPI JTAG server address
if { [info exists VPI_ADDRESS] } {
   set _VPI_ADDRESS $VPI_ADDRESS
} else {
   set _VPI_ADDRESS "127.0.0.1"
}

jtag_vpi_set_port $_VPI_PORT
jtag_vpi_set_address $_VPI_ADDRESS
#
# Cypress Semiconductor KitProg
#
# Note: This is the driver for the proprietary KitPtog protocol. If the
# KitProg is in CMSIS-DAP mode, you should either use the cmsis-dap
# interface driver or switch the KitProg to KitProg mode.
#

adapter driver kitprog

# Optionally specify the serial number of the KitProg you want to use.
#kitprog_serial 1926402735485200
#
# Andes AICE
#
# http://www.andestech.com
#

adapter driver aice
aice desc "Andes AICE adapter"
aice serial "C001-42163"
aice vid_pid 0x1CFC 0x0000
aice port aice_usb
reset_config trst_and_srst
adapter speed 24000
aice retry_times 50
aice count_to_check_dbger 30
#
# Nuvoton Nu-Link in-circuit debugger/programmer
#

adapter driver hla
hla_layout nulink
hla_device_desc "Nu-Link"
hla_vid_pid 0x0416 0x511b 0x0416 0x511c 0x0416 0x511d 0x0416 0x5200 0x0416 0x5201

# Only swd is supported
transport select hla_swd
#
# opendous-jtag
#
# http://code.google.com/p/opendous-jtag/
#

adapter driver opendous
#
# OpenJTAG
#
# www.openjtag.org
#

adapter driver openjtag
openjtag_device_desc "Open JTAG Project"
#
# P&E Micro OSBDM (aka OSJTAG) interface
#
# http://pemicro.com/osbdm/
#
adapter driver osbdm
reset_config srst_only
#
# Parallel port wiggler (many clones available) on port 0x378
#
# Addresses: 0x378/LPT1 or 0x278/LPT2 ...
#

if { [info exists PARPORTADDR] } {
   set _PARPORTADDR $PARPORTADDR
} else {
   if {$tcl_platform(platform) eq "windows"} {
      set _PARPORTADDR 0x378
   } {
      set _PARPORTADDR 0
   }
}

adapter driver parport
parport_port $_PARPORTADDR
parport_cable wiggler
#
# Xilinx Parallel Cable III 'DLC 5' (and various clones)
#
# http://www.xilinx.com/itp/xilinx4/data/docs/pac/appendixb.html
#

if { [info exists PARPORTADDR] } {
   set _PARPORTADDR $PARPORTADDR
} else {
   set _PARPORTADDR 0
}

adapter driver parport
parport_port $_PARPORTADDR
parport_cable dlc5
#
# Config for using Raspberry Pi's expansion header
#
# This is best used with a fast enough buffer but also
# is suitable for direct connection if the target voltage
# matches RPi's 3.3V and the cable is short enough.
#
# Do not forget the GND connection, pin 6 of the expansion header.
#

adapter driver bcm2835gpio

bcm2835gpio_peripheral_base 0x20000000

# Transition delay calculation: SPEED_COEFF/khz - SPEED_OFFSET
# These depend on system clock, calibrated for stock 700MHz
# bcm2835gpio_speed SPEED_COEFF SPEED_OFFSET
bcm2835gpio_speed_coeffs 113714 28

# Each of the JTAG lines need a gpio number set: tck tms tdi tdo
# Header pin numbers: 23 22 19 21
bcm2835gpio_jtag_nums 11 25 10 9

# Each of the SWD lines need a gpio number set: swclk swdio
# Header pin numbers: 23 22
bcm2835gpio_swd_nums 11 25

# If you define trst or srst, use appropriate reset_config
# Header pin numbers: TRST - 26, SRST - 18

# bcm2835gpio_trst_num 7
# reset_config trst_only

# bcm2835gpio_srst_num 24
# reset_config srst_only srst_push_pull

# or if you have both connected,
# reset_config trst_and_srst srst_push_pull
#
# Config for using Raspberry Pi's expansion header
#
# This is best used with a fast enough buffer but also
# is suitable for direct connection if the target voltage
# matches RPi's 3.3V and the cable is short enough.
#
# Do not forget the GND connection, pin 6 of the expansion header.
#

adapter driver bcm2835gpio

bcm2835gpio_peripheral_base 0x3F000000

# Transition delay calculation: SPEED_COEFF/khz - SPEED_OFFSET
# These depend on system clock, calibrated for stock 700MHz
# bcm2835gpio_speed SPEED_COEFF SPEED_OFFSET
bcm2835gpio_speed_coeffs 146203 36

# Each of the JTAG lines need a gpio number set: tck tms tdi tdo
# Header pin numbers: 23 22 19 21
bcm2835gpio_jtag_nums 11 25 10 9

# Each of the SWD lines need a gpio number set: swclk swdio
# Header pin numbers: 23 22
bcm2835gpio_swd_nums 11 25

# If you define trst or srst, use appropriate reset_config
# Header pin numbers: TRST - 26, SRST - 18

# bcm2835gpio_trst_num 7
# reset_config trst_only

# bcm2835gpio_srst_num 24
# reset_config srst_only srst_push_pull

# or if you have both connected,
# reset_config trst_and_srst srst_push_pull
#
# Raisonance RLink
#
# http://www.mcu-raisonance.com/~rlink-debugger-programmer__microcontrollers__tool~tool__T018:4cn9ziz4bnx6.html
#

adapter driver rlink
#
# BlueField SoC in-circuit debugger/programmer
#

adapter driver rshim
transport select dapdirect_swd
#
# STMicroelectronics ST-LINK/V1, ST-LINK/V2, ST-LINK/V2-1, STLINK-V3 in-circuit
# debugger/programmer
#
# This new interface driver creates a ST-Link wrapper for ARM-DAP named "dapdirect"
# Old ST-LINK/V1 and ST-LINK/V2 pre version V2J24 don't support "dapdirect"
#
# SWIM transport is natively supported
#

adapter driver st-link
st-link vid_pid 0x0483 0x3744 0x0483 0x3748 0x0483 0x374b 0x0483 0x374d 0x0483 0x374e 0x0483 0x374f 0x0483 0x3752 0x0483 0x3753

# transport select dapdirect_jtag
# transport select dapdirect_swd
# transport select swim

# Optionally specify the serial number of usb device
# e.g.
# st-link serial "\xaa\xbc\x6e\x06\x50\x75\xff\x55\x17\x42\x19\x3f"
echo "WARNING: interface/stlink-v1.cfg is deprecated, please switch to interface/stlink.cfg"
source [find interface/stlink.cfg]
echo "WARNING: interface/stlink-v2-1.cfg is deprecated, please switch to interface/stlink.cfg"
source [find interface/stlink.cfg]
echo "WARNING: interface/stlink-v2.cfg is deprecated, please switch to interface/stlink.cfg"
source [find interface/stlink.cfg]
#
# STMicroelectronics ST-LINK/V1, ST-LINK/V2, ST-LINK/V2-1, STLINK-V3 in-circuit
# debugger/programmer
#

adapter driver hla
hla_layout stlink
hla_device_desc "ST-LINK"
hla_vid_pid 0x0483 0x3744 0x0483 0x3748 0x0483 0x374b 0x0483 0x374d 0x0483 0x374e 0x0483 0x374f 0x0483 0x3752 0x0483 0x3753

# Optionally specify the serial number of ST-LINK/V2 usb device.  ST-LINK/V2
# devices seem to have serial numbers with unreadable characters.  ST-LINK/V2
# firmware version >= V2.J21.S4 recommended to avoid issues with adapter serial
# number reset issues.
# eg.
#hla_serial "\xaa\xbc\x6e\x06\x50\x75\xff\x55\x17\x42\x19\x3f"
#
# Config for using RaspberryPi's expansion header
#
# This is best used with a fast enough buffer but also
# is suitable for direct connection if the target voltage
# matches RPi's 3.3V
#
# Do not forget the GND connection, pin 6 of the expansion header.
#

adapter driver sysfsgpio

# Each of the JTAG lines need a gpio number set: tck tms tdi tdo
# Header pin numbers: 23 22 19 21
sysfsgpio_jtag_nums 11 25 10 9

# Each of the SWD lines need a gpio number set: swclk swdio
# Header pin numbers: 23 22
sysfsgpio_swd_nums 11 25

# If you define trst or srst, use appropriate reset_config
# Header pin numbers: TRST - 26, SRST - 18

# sysfsgpio_trst_num 7
# reset_config trst_only

# sysfsgpio_srst_num 24
# reset_config srst_only srst_push_pull

# or if you have both connected,
# reset_config trst_and_srst srst_push_pull
#
# TI Stellaris In-Circuit Debug Interface (ICDI) Board
#
# This is the propriety ICDI interface used on newer boards such as
# LM4F232 Evaluation Kit - http://www.ti.com/tool/ek-lm4f232
# Stellaris Launchpad - http://www.ti.com/stellaris-launchpad
# http://www.ti.com/tool/ek-lm4f232
#

adapter driver hla
hla_layout ti-icdi
hla_vid_pid 0x1cbe 0x00fd

# Optionally specify the serial number of TI-ICDI devices, for when using
# multiple devices. Serial numbers can be obtained using lsusb -v
# Ex.
#hla_serial "0F003065"
#
# Keil ULINK running OpenULINK firmware.
#
# http://www.keil.com/ulink1/
# http://article.gmane.org/gmane.comp.debugging.openocd.devel/17362
#

adapter driver ulink
# ixo-usb-jtag - Emulation of a Altera Bus Blaster I on a Cypress FX2 IC.
#
# The ixo-usb-jtag firmware can be loaded onto a bunch of different hardware
# including;
#  * Xilinx USB Platform Cable
#  * Many Digilent boards such as the Nexys, Nexys 2 and Atlys boards
#  * Many fpga4fun.com boards from such as the Saxo and Xylo boards
#  * The Numato Opsis
#
# Original version - http://www.ixo.de/info/usb_jtag/
#  Updated version - http://ixo-jtag.sourceforge.net/
#   Newest version - http://github.com/mithro/ixo-usb-jtag
#
# Procedure for using is;
#  * Get the ixo-usb-jtag firmware for your hardware (or build it yourself).
#  * Load the firmware using the fxload tool.
#  * Use openocd.
#
# Unless you burn the firmware into the EEPROM on your device, power cycling
# will require you to reload the firmware using the fxload tool. This can be
# automated by using udev rules (which can be found in the firmware
# repository).
#
# Ubuntu packages built from mithro's version (with prebuilt firmware and udev
# rules) can be found at
# https://launchpad.net/~timvideos/+archive/ubuntu/fpga-support
#
# TODO: Refactor the usb_blaster driver to allow loading firmware using any low
# level driver. Loading firmware is currently only supported on the ublast2
# driver but ixo-usb-jtag requires the ftdi driver.

adapter driver usb_blaster
usb_blaster_vid_pid 0x16C0 0x06AD
usb_blaster_device_desc "Van Ooijen Technische Informatica"
# ixo-usb-jtag is only compatible with the ublast1 protocol implemented via the
# ftdi modes, using ublast2 will cause openocd to hang.
usb_blaster_lowlevel_driver ftdi
#
# Embedded Projects USBprog
#
# http://embedded-projects.net/index.php?page_id=135
#

adapter driver usbprog
# USBprog is broken w/short TMS sequences, this is a workaround
# until the C code can be fixed.
tms_sequence long
#
# Versaloon Link -- VSLLink
#
# http://www.versaloon.com/
#

adapter driver vsllink
#
# Texas Instruments XDS110
#
# http://processors.wiki.ti.com/index.php/XDS110
# http://processors.wiki.ti.com/index.php/Emulation_Software_Package#XDS110_Support_Utilities
#

adapter driver xds110

# Use serial number option to use a specific XDS110
# when more than one are connected to the host.
#xds110_serial 00000000
# Helper for common memory read/modify/write procedures

# mrw: "memory read word", returns value of $reg
proc mrw {reg} {
	set value ""
	mem2array value 32 $reg 1
	return $value(0)
}

add_usage_text mrw "address"
add_help_text mrw "Returns value of word in memory."

# mrh: "memory read halfword", returns value of $reg
proc mrh {reg} {
	set value ""
	mem2array value 16 $reg 1
	return $value(0)
}

add_usage_text mrh "address"
add_help_text mrh "Returns value of halfword in memory."

# mrb: "memory read byte", returns value of $reg
proc mrb {reg} {
	set value ""
	mem2array value 8 $reg 1
	return $value(0)
}

add_usage_text mrb "address"
add_help_text mrb "Returns value of byte in memory."

# mmw: "memory modify word", updates value of $reg
#       $reg <== ((value & ~$clearbits) | $setbits)
proc mmw {reg setbits clearbits} {
	set old [mrw $reg]
	set new [expr ($old & ~$clearbits) | $setbits]
	mww $reg $new
}

add_usage_text mmw "address setbits clearbits"
add_help_text mmw "Modify word in memory. new_val = (old_val & ~clearbits) | setbits;"
# MEMORY
#
# All Memory regions have two components.
#    (1) A count of regions, in the form N_NAME
#    (2) An array within info about each region.
#
# The ARRAY
#
#       <NAME>(  RegionNumber ,  ATTRIBUTE )
#
# Where <NAME> is one of:
#
#     N_FLASH  & FLASH   (internal memory)
#     N_RAM    & RAM     (internal memory)
#     N_MMREGS & MMREGS  (for memory mapped registers)
#     N_XMEM   & XMEM    (off chip memory, ie: flash on cs0, sdram on cs2)
# or  N_UNKNOWN & UNKNOWN for things that do not exist.
#
# We have 1 unknown region.
set N_UNKNOWN 1
# All MEMORY regions must have these attributes
#     CS          - chip select (if internal, use -1)
set UNKNOWN(0,CHIPSELECT) -1
#     BASE        - base address in memory
set UNKNOWN(0,BASE)       0
#     LEN         - length in bytes
set UNKNOWN(0,LEN)        $CPU_MAX_ADDRESS
#     HUMAN       - human name of the region
set UNKNOWN(0,HUMAN) "unknown"
#     TYPE        - one of:
#                       flash, ram, mmr, unknown
#                    For harvard arch:
#                       iflash, dflash, iram, dram
set UNKNOWN(0,TYPE)       "unknown"
#     RWX         - access ablity
#                       unix style chmod bits
#                           0 - no access
#                           1 - execute
#                           2 - write
#                           4 - read
#                       hence: 7 - readwrite execute
set RWX_NO_ACCESS     0
set RWX_X_ONLY        $BIT0
set RWX_W_ONLY        $BIT1
set RWX_R_ONLY        $BIT2
set RWX_RW            [expr $RWX_R_ONLY + $RWX_W_ONLY]
set RWX_R_X           [expr $RWX_R_ONLY + $RWX_X_ONLY]
set RWX_RWX           [expr $RWX_R_ONLY + $RWX_W_ONLY + $RWX_X_ONLY]
set UNKNOWN(0,RWX)     $RWX_NO_ACCESS

#     WIDTH       - access width
#                      8,16,32 [0 means ANY]
set ACCESS_WIDTH_NONE 0
set ACCESS_WIDTH_8    $BIT0
set ACCESS_WIDTH_16   $BIT1
set ACCESS_WIDTH_32   $BIT2
set ACCESS_WIDTH_ANY  [expr $ACCESS_WIDTH_8 + $ACCESS_WIDTH_16 + $ACCESS_WIDTH_32]
set UNKNOWN(0,ACCESS_WIDTH) $ACCESS_WIDTH_NONE

proc iswithin { ADDRESS BASE LEN } {
    return [expr ((($ADDRESS - $BASE) >= 0) && (($BASE + $LEN - $ADDRESS) > 0))]
}

proc address_info { ADDRESS } {

    foreach WHERE { FLASH RAM MMREGS XMEM UNKNOWN } {
	if { info exists $WHERE } {
	    set lmt [set N_[set WHERE]]
	    for { set region 0 } { $region < $lmt } { incr region } {
		if { iswithin $ADDRESS $WHERE($region,BASE) $WHERE($region,LEN) } {
		    return  "$WHERE $region";
		}
	    }
	}
    }

    # Return the 'unknown'
    return "UNKNOWN 0"
}

proc memread32 {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 32 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memread32: $msg"
    }
}

proc memread16 {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 16 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memread16: $msg"
    }
}

proc memread8 {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 8 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memread8: $msg"
    }
}

proc memwrite32 {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 32 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memwrite32: $msg"
    }
}

proc memwrite16 {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 16 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memwrite16: $msg"
    }
}

proc memwrite8 {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 8 $ADDR 1  } msg ] {
	return $foo(0)
    } else {
	error "memwrite8: $msg"
    }
}

proc memread32_phys {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 32 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memread32: $msg"
    }
}

proc memread16_phys {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 16 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memread16: $msg"
    }
}

proc memread8_phys {ADDR} {
    set foo(0) 0
    if ![ catch { mem2array foo 8 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memread8: $msg"
    }
}

proc memwrite32_phys {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 32 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memwrite32: $msg"
    }
}

proc memwrite16_phys {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 16 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memwrite16: $msg"
    }
}

proc memwrite8_phys {ADDR DATA} {
    set foo(0) $DATA
    if ![ catch { array2mem foo 8 $ADDR 1 phys } msg ] {
	return $foo(0)
    } else {
	error "memwrite8: $msg"
    }
}

proc proc_exists { NAME } {
    set n [info commands $NAME]
    set l [string length $n]
    return [expr $l != 0]
}

# Give: REGISTER name - must be a global variable.
proc show_mmr32_reg { NAME } {

    global $NAME
    # we want $($NAME)
    set a [set [set NAME]]

    if ![catch { set v [memread32 $a] } msg ] {
	echo [format "%15s: (0x%08x): 0x%08x" $NAME $a $v]

	# Was a helper defined?
	set fn show_${NAME}_helper
	if [ proc_exists $fn ] {
	    # Then call it
	    $fn $NAME $a $v
	}
	return $v;
    } else {
	error [format "%s (%s)" $msg $NAME ]
    }
}


# Give: NAMES - an array of names accessible
#               in the callers symbol-scope.
#       VAL - the bits to display.

proc show_mmr32_bits { NAMES VAL } {

    upvar $NAMES MYNAMES

    set w 5
    foreach {IDX N} $MYNAMES {
	set l [string length $N]
	if { $l > $w } { set w $l }
    }

    for { set x 24 } { $x >= 0 } { incr x -8 } {
	echo -n "  "
	for { set y 7 } { $y >= 0 } { incr y -1 } {
	    set s $MYNAMES([expr $x + $y])
	    echo -n [format "%2d: %-*s | " [expr $x + $y] $w $s ]
	}
	echo ""

	echo -n "  "
	for { set y 7 } { $y >= 0 } { incr y -1 } {
	    echo -n [format "    %d%*s | " [expr !!($VAL & (1 << ($x + $y)))] [expr $w -1] ""]
	}
	echo ""
    }
}


proc show_mmr_bitfield { MSB LSB VAL FIELDNAME FIELDVALUES } {
    set width [expr (($MSB - $LSB + 1) + 7) / 4]
    set nval [show_normalize_bitfield $VAL $MSB $LSB ]
    set name0 [lindex $FIELDVALUES 0 ]
    if [ string compare $name0 _NUMBER_ ] {
	set sval [lindex $FIELDVALUES $nval]
    } else {
	set sval ""
    }
    echo [format "%-15s: %d (0x%0*x) %s" $FIELDNAME $nval $width $nval $sval ]
}
# 19861
# http://milandr.ru/index.php?mact=Products,cntnt01,details,0&cntnt01productid=236&cntnt01returnid=68

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME 19861
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      # SWD IDCODE
      set _CPUTAPID 0x2ba01477
   }
}
swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# use AHB-Lite SRAM for work area
$_TARGETNAME configure -work-area-phys 0x20100000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# can't handle overlapping memory regions
if { [info exists IMEMORY] && [string equal $IMEMORY true] } {
   flash bank ${_CHIPNAME}_info.flash mdr 0x00000000 0x01000 0 0 $_TARGETNAME 1 1 4
} else {
   flash bank $_CHIPNAME.flash mdr 0x00000000 0x20000 0 0 $_TARGETNAME 0 32 4
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# Analog Devices ADSP-SC58x (ARM Cortex-A5 plus one or two SHARC+ DSPs)
#

# Evaluation boards by Analog Devices (and designs derived from them) use a
# non-standard 10-pin 0.05" ARM Cortex Debug Connector.  In this bastardized
# implementation, pin 9 (GND or GNDDetect) has been usurped with JTAG /TRST.
#
# As a result, a standards-compliant debug pod will force /TRST active,
# putting the processor's debug interface into reset and preventing usage.
#
# A connector adapter must be employed on these boards to isolate or remap
# /TRST so that it is only asserted when intended.

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME ADSP-SC58x
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x3BA02477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create ap0.mem mem_ap -dap $_CHIPNAME.dap -ap-num 0

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -event examine-end {
   global _TARGETNAME
   sc58x_enabledebug
}

proc sc58x_enabledebug {} {
   # Enable debugging functionality by setting bits in the TAPC_DBGCTL register
   # it is not possible to halt the target unless these bits have been set
   ap0.mem mww 0x31131000 0xFFFF
}
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME aduc702x
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   # This config file was defaulting to big endian..
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

adapter srst delay 200
jtag_ntrst_delay 200

## JTAG scan chain
#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

##
## Target configuration
##
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

# allocate the entire SRAM as working area
$_TARGETNAME configure -work-area-phys 0x10000 -work-area-size 0x2000

## flash configuration
# only target number is needed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME aduc702x 0 0 0 0 $_TARGETNAME

## If you use the watchdog, the following code makes sure that the board
## doesn't reboot when halted via JTAG.  Yes, on the older generation
## AdUC702x, timer3 continues running even when the CPU is halted.

proc watchdog_service {} {
    global watchdog_hdl
    mww 0xffff036c 0
#    echo "watchdog!!"
    set watchdog_hdl [after 500 watchdog_service]
}

$_TARGETNAME configure -event reset-halt-post {  watchdog_service }
$_TARGETNAME configure -event resume-start { global watchdog_hdl; after cancel $watchdog_hdl }
#
# This file was created using as references the stm32f1x.cfg and aduc702x.cfg
#
source [find target/swj-dp.tcl]

# Chip name
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME aducm360
}

# Endianness
if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# Eventually, the whole SRAM of ADuCM360 will be used (8kB)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x2000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x2ba01477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# SWD/JTAG speed
adapter speed 1000

##
## Target configuration
##
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# allocate the working area
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME aducm360 0x00 0 0 0 $_TARGETNAME

adapter srst delay 100

cortex_m reset_config sysresetreq
# This is the config for an Allwinner V3/V3s (sun8iw8).
#
# Notes:
# - Single core ARM Cortex-A7 with a maximum frequency of 1.2 GHz.
# - Thumb-2 Technology
# - Support NEON Advanced SIMD(Single Instruction Multiple Data)instruction
#   for acceleration of media and signal processing functions
# - Support Large Physical Address Extensions(LPAE)
# - VFPv4 Floating Point Unit
# - 32KB L1 Instruction cache and 32KB L1 Data cache
# - 128KB L2 cache
# - has some integrated DDR2 RAM.
#
# Pins related for debug and bootstrap:
#   JTAG
# JTAG_TMS	PF0, SDC0_D1
# JTAG_TDI	PF1, SDC0_D0
# JTAG_TDO	PF3, SDC0_CMD
# JTAG_TCK	PF5, SDC0_D2
#   UART
# None of UART ports seems to be enabled by ROM.
# UART0_TX	PF2, SDC0_CLK		Per default disabled
# UART0_RX	PF4, SDC0_D3 		Per default disabled
# UART1_TX	PE21			Per default disabled
# UART1_RX	PE22	 		Per default disabled
# UART2_TX	PB0			Per default disabled
# UART2_RX	PB1	 		Per default disabled
#
# JTAG is enabled by default after power on on listed JTAG_* pins. So far the
# boot sequence is:
# Time		Action
# 0000ms	Power ON
# 0200ms	JTAG enabled
# 0220ms	JTAG pins switched to SD mode
#
# The time frame of 20ms can be not enough to init and halt the CPU. In this
# case I would recommend to set: "adapter speed 15000"
# To get more or less precise timings, the board should provide reset pin,
# or some bench power supply with remote function. In my case I used
# EEZ H24005 with this command to power on and halt the target:
# "exec  echo "*TRG" > /dev/ttyACM0; sleep 220; reset halt"
# After this it is possible to enable JTAG mode again from boot loader or OS.
# Following DAPs are available:
# dap[0]->MEM-AP AHB
# dap[1]->MEM-AP APB->CA7[0]
#

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME v3s
}

if { [info exists DAP_TAPID] } {
        set _DAP_TAPID $DAP_TAPID
} else {
        set _DAP_TAPID 0x5ba00477
}

# No NRST or SRST is present on the SoC. Boards may provide
# some sort of Power cycle reset for complete board or SoC.
# For this case we provide srst_pulls_trst so the board config
# only needs to set srst_only.
reset_config none srst_pulls_trst

jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

# Add Cortex A7 core
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -chain-position $_CHIPNAME.dap
if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME asm9260t
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x079264F3
}

# And srst_pulls_trst by chip design.
reset_config srst_pulls_trst

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
#
# Altera cyclone V SoC family, 5Cxxx
#
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME fpgasoc
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
        set _DAP_TAPID $DAP_TAPID
} else {
        set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

# Subsidiary TAP: fpga
if { [info exists FPGA_TAPID] } {
   set _FPGA_TAPID $FPGA_TAPID
} else {
   set _FPGA_TAPID 0x02d020dd
}
jtag newtap $_CHIPNAME.fpga tap -irlen 10 -ircapture 0x01 -irmask 0x3 -expected-id $_FPGA_TAPID


#
# Cortex-A9 target
#

# GDB target: Cortex-A9, using DAP, configuring only one core
# Base addresses of cores:
# core 0  -  0x80110000
# core 1  -  0x80112000

# Slow speed to be sure it will work
adapter speed 1000

set _TARGETNAME1 $_CHIPNAME.cpu.0
set _TARGETNAME2 $_CHIPNAME.cpu.1

# A9 core 0
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME1 cortex_a -dap $_CHIPNAME.dap \
        -coreid 0 -dbgbase 0x80110000

$_TARGETNAME1 configure -event reset-start { adapter speed 1000 }
$_TARGETNAME1 configure -event reset-assert-post "cycv_dbginit $_TARGETNAME1"


# A9 core 1
#target create $_TARGETNAME2 cortex_a -dap $_CHIPNAME.dap \
#        -coreid 1 -dbgbase 0x80112000

#$_TARGETNAME2 configure -event reset-start { adapter speed 1000 }
#$_TARGETNAME2 configure -event reset-assert-post "cycv_dbginit $_TARGETNAME2"

proc cycv_dbginit {target} {
        # General Cortex-A8/A9 debug initialisation
        cortex_a dbginit
}
# Intel (Altera) Arria10 FPGA SoC

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME arria10
}

# ARM CoreSight Debug Access Port (dap HPS)
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba00477
}
jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_TAPID

# Subsidiary TAP: fpga (tap)
# See Intel Arria 10 Handbook
# https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/hb/arria-10/a10_handbook.pdf
# Intel Arria 10 GX 160  0x02ee20dd
# Intel Arria 10 GX 220  0x02e220dd
# Intel Arria 10 GX 270  0x02ee30dd
# Intel Arria 10 GX 320  0x02e230dd
# Intel Arria 10 GX 480  0x02e240dd
# Intel Arria 10 GX 570  0x02ee50dd
# Intel Arria 10 GX 660  0x02e250dd
# Intel Arria 10 GX 900  0x02ee60dd
# Intel Arria 10 GX 1150 0x02e660dd
# Intel Arria 10 GT 900  0x02e260dd
# Intel Arria 10 GT 1150 0x02e060dd
# Intel Arria 10 SX 160  0x02e620dd
# Intel Arria 10 SX 220  0x02e020dd
# Intel Arria 10 SX 270  0x02e630dd
# Intel Arria 10 SX 320  0x02e030dd
# Intel Arria 10 SX 480  0x02e040dd
# Intel Arria 10 SX 570  0x02e650dd
# Intel Arria 10 SX 660  0x02e050dd
jtag newtap $_CHIPNAME.fpga tap -irlen 10 -expected-id 0x02ee20dd -expected-id 0x02e220dd \
	-expected-id 0x02ee30dd -expected-id 0x02e230dd -expected-id 0x02e240dd \
	-expected-id 0x02ee50dd -expected-id 0x02e250dd -expected-id 0x02ee60dd \
	-expected-id 0x02e660dd -expected-id 0x02e260dd -expected-id 0x02e060dd \
	-expected-id 0x02e620dd -expected-id 0x02e020dd -expected-id 0x02e630dd \
	-expected-id 0x02e030dd -expected-id 0x02e040dd -expected-id 0x02e650dd \
	-expected-id 0x02e050dd

set _TARGETNAME $_CHIPNAME.cpu

#
# Cortex-A9 target

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME.0 cortex_a -dap $_CHIPNAME.dap -coreid 0
target create $_TARGETNAME.1 cortex_a -dap $_CHIPNAME.dap -coreid 1 \
	-defer-examine
target smp $_TARGETNAME.0 $_TARGETNAME.1
source [find target/icepick.cfg]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME am335x
}

# set the taps to be enabled by default. this can be overridden
# by setting DEFAULT_TAPS in a separate configuration file
# or directly on the command line.
if { [info exists DEFAULT_TAPS] } {
	set _DEFAULT_TAPS "$DEFAULT_TAPS"
} else {
	set _DEFAULT_TAPS "$_CHIPNAME.tap"
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4b6b902f
}
jtag newtap $_CHIPNAME tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.tap -event tap-enable "icepick_d_tapenable $_CHIPNAME.jrc 12 0"
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap

#
# M3 DAP
#
if { [info exists M3_DAP_TAPID] } {
	set _M3_DAP_TAPID $M3_DAP_TAPID
} else {
	set _M3_DAP_TAPID 0x4b6b902f
}
jtag newtap $_CHIPNAME m3_tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M3_DAP_TAPID -disable
jtag configure $_CHIPNAME.m3_tap -event tap-enable "icepick_d_tapenable $_CHIPNAME.jrc 11 0"
dap create $_CHIPNAME.m3_dap -chain-position $_CHIPNAME.m3_tap

#
# ICEpick-D (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID 0x0b94402f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version
jtag configure $_CHIPNAME.jrc -event setup {
	global _DEFAULT_TAPS
	enable_default_taps $_DEFAULT_TAPS
}
# some TCK tycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"

#
# helper function that enables all taps passed as argument
#
proc enable_default_taps { taps } {
	foreach tap $taps {
		jtag tapenable $tap
	}
}

#
# Cortex-M3 target
#
set _TARGETNAME_2 $_CHIPNAME.m3
target create $_TARGETNAME_2 cortex_m -dap $_CHIPNAME.m3_dap

#
# Cortex-A8 target
#
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap -dbgbase 0x80001000

# SRAM: 64K at 0x4030.0000; use the first 16K
$_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x4000


# when putting the target into 'reset halt', we need to disable the watchdog as
# it would otherwise trigger while we're in JTAG
# FIXME: unify with target/am437x.cfg
source [find mem_helper.tcl]
set  WDT1_BASE_ADDR                  0x44e35000
set  WDT1_W_PEND_WSPR                [expr       $WDT1_BASE_ADDR     +  0x0034]
set  WDT1_WSPR                       [expr       $WDT1_BASE_ADDR     +  0x0048]
proc disable_watchdog { } {
	global WDT1_WSPR
	global WDT1_W_PEND_WSPR
	global _TARGETNAME

	set curstate [$_TARGETNAME curstate]

	if { [string compare $curstate halted] == 0 } {
		set WDT_DISABLE_SEQ1	0xaaaa
		set WDT_DISABLE_SEQ2	0x5555

		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ1

		# Empty body to make sure this executes as fast as possible.
		# We don't want any delays here otherwise romcode might start
		# executing and end up changing state of certain IPs.
		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }

		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ2
		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }
	}
}
$_TARGETNAME configure -event reset-end { disable_watchdog }
source [find target/icepick.cfg]
source [find mem_helper.tcl]

###############################################################################
##				AM437x Registers			     ##
###############################################################################
set  PRCM_BASE_ADDR                  0x44df0000
set  REVISION_PRM                    [expr       $PRCM_BASE_ADDR     +  0x0000]
set  PRM_IRQSTATUS_MPU               [expr       $PRCM_BASE_ADDR     +  0x0004]
set  PRM_IRQENABLE_MPU               [expr       $PRCM_BASE_ADDR     +  0x0008]
set  PRM_IRQSTATUS_M3                [expr       $PRCM_BASE_ADDR     +  0x000c]
set  PRM_IRQENABLE_M3                [expr       $PRCM_BASE_ADDR     +  0x0010]
set  PM_MPU_PWRSTCTRL                [expr       $PRCM_BASE_ADDR     +  0x0300]
set  PM_MPU_PWRSTST                  [expr       $PRCM_BASE_ADDR     +  0x0304]
set  RM_MPU_RSTST                    [expr       $PRCM_BASE_ADDR     +  0x0314]
set  RM_MPU_CONTEXT                  [expr       $PRCM_BASE_ADDR     +  0x0324]
set  PM_GFX_PWRSTCTRL                [expr       $PRCM_BASE_ADDR     +  0x0400]
set  PM_GFX_PWRSTST                  [expr       $PRCM_BASE_ADDR     +  0x0404]
set  RM_GFX_RSTCTRL                  [expr       $PRCM_BASE_ADDR     +  0x0410]
set  RM_GFX_RSTST                    [expr       $PRCM_BASE_ADDR     +  0x0414]
set  RM_GFX_CONTEXT                  [expr       $PRCM_BASE_ADDR     +  0x0424]
set  RM_RTC_CONTEXT                  [expr       $PRCM_BASE_ADDR     +  0x0524]
set  RM_WKUP_RSTCTRL                 [expr       $PRCM_BASE_ADDR     +  0x2010]
set  RM_WKUP_RSTST                   [expr       $PRCM_BASE_ADDR     +  0x2014]
set  CM_L3_AON_CLKSTCTRL             [expr       $PRCM_BASE_ADDR     +  0x2800]
set  CM_WKUP_DEBUGSS_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2820]
set  CM_L3S_TSC_CLKSTCTRL            [expr       $PRCM_BASE_ADDR     +  0x2900]
set  CM_WKUP_ADC_TSC_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2920]
set  CM_L4_WKUP_AON_CLKSTCTRL        [expr       $PRCM_BASE_ADDR     +  0x2a00]
set  CM_WKUP_L4WKUP_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x2a20]
set  CM_WKUP_WKUP_M3_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2a28]
set  CM_WKUP_SYNCTIMER_CLKCTRL       [expr       $PRCM_BASE_ADDR     +  0x2a30]
set  CM_WKUP_CLKDIV32K_CLKCTRL       [expr       $PRCM_BASE_ADDR     +  0x2a38]
set  CM_WKUP_USBPHY0_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2a40]
set  CM_WKUP_USBPHY1_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2a48]
set  CM_WKUP_CLKSTCTRL               [expr       $PRCM_BASE_ADDR     +  0x2b00]
set  CM_WKUP_TIMER0_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x2b20]
set  CM_WKUP_TIMER1_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x2b28]
set  CM_WKUP_WDT0_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x2b30]
set  CM_WKUP_WDT1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x2b38]
set  CM_WKUP_I2C0_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x2b40]
set  CM_WKUP_UART0_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x2b48]
set  CM_WKUP_SMARTREFLEX0_CLKCTRL    [expr       $PRCM_BASE_ADDR     +  0x2b50]
set  CM_WKUP_SMARTREFLEX1_CLKCTRL    [expr       $PRCM_BASE_ADDR     +  0x2b58]
set  CM_WKUP_CONTROL_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x2b60]
set  CM_WKUP_GPIO0_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x2b68]
set  CM_CLKMODE_DPLL_CORE            [expr       $PRCM_BASE_ADDR     +  0x2d20]
set  CM_IDLEST_DPLL_CORE             [expr       $PRCM_BASE_ADDR     +  0x2d24]
set  CM_CLKSEL_DPLL_CORE             [expr       $PRCM_BASE_ADDR     +  0x2d2c]
set  CM_DIV_M4_DPLL_CORE             [expr       $PRCM_BASE_ADDR     +  0x2d38]
set  CM_DIV_M5_DPLL_CORE             [expr       $PRCM_BASE_ADDR     +  0x2d3c]
set  CM_DIV_M6_DPLL_CORE             [expr       $PRCM_BASE_ADDR     +  0x2d40]
set  CM_SSC_DELTAMSTEP_DPLL_CORE     [expr       $PRCM_BASE_ADDR     +  0x2d48]
set  CM_SSC_MODFREQDIV_DPLL_CORE     [expr       $PRCM_BASE_ADDR     +  0x2d4c]
set  CM_CLKMODE_DPLL_MPU             [expr       $PRCM_BASE_ADDR     +  0x2d60]
set  CM_IDLEST_DPLL_MPU              [expr       $PRCM_BASE_ADDR     +  0x2d64]
set  CM_CLKSEL_DPLL_MPU              [expr       $PRCM_BASE_ADDR     +  0x2d6c]
set  CM_DIV_M2_DPLL_MPU              [expr       $PRCM_BASE_ADDR     +  0x2d70]
set  CM_SSC_DELTAMSTEP_DPLL_MPU      [expr       $PRCM_BASE_ADDR     +  0x2d88]
set  CM_SSC_MODFREQDIV_DPLL_MPU      [expr       $PRCM_BASE_ADDR     +  0x2d8c]
set  CM_CLKMODE_DPLL_DDR             [expr       $PRCM_BASE_ADDR     +  0x2da0]
set  CM_IDLEST_DPLL_DDR              [expr       $PRCM_BASE_ADDR     +  0x2da4]
set  CM_CLKSEL_DPLL_DDR              [expr       $PRCM_BASE_ADDR     +  0x2dac]
set  CM_DIV_M2_DPLL_DDR              [expr       $PRCM_BASE_ADDR     +  0x2db0]
set  CM_DIV_M4_DPLL_DDR              [expr       $PRCM_BASE_ADDR     +  0x2db8]
set  CM_SSC_DELTAMSTEP_DPLL_DDR      [expr       $PRCM_BASE_ADDR     +  0x2dc8]
set  CM_SSC_MODFREQDIV_DPLL_DDR      [expr       $PRCM_BASE_ADDR     +  0x2dcc]
set  CM_CLKMODE_DPLL_PER             [expr       $PRCM_BASE_ADDR     +  0x2de0]
set  CM_IDLEST_DPLL_PER              [expr       $PRCM_BASE_ADDR     +  0x2de4]
set  CM_CLKSEL_DPLL_PER              [expr       $PRCM_BASE_ADDR     +  0x2dec]
set  CM_DIV_M2_DPLL_PER              [expr       $PRCM_BASE_ADDR     +  0x2df0]
set  CM_CLKSEL2_DPLL_PER             [expr       $PRCM_BASE_ADDR     +  0x2e04]
set  CM_SSC_DELTAMSTEP_DPLL_PER      [expr       $PRCM_BASE_ADDR     +  0x2e08]
set  CM_SSC_MODFREQDIV_DPLL_PER      [expr       $PRCM_BASE_ADDR     +  0x2e0c]
set  CM_CLKDCOLDO_DPLL_PER           [expr       $PRCM_BASE_ADDR     +  0x2e14]
set  CM_CLKMODE_DPLL_DISP            [expr       $PRCM_BASE_ADDR     +  0x2e20]
set  CM_IDLEST_DPLL_DISP             [expr       $PRCM_BASE_ADDR     +  0x2e24]
set  CM_CLKSEL_DPLL_DISP             [expr       $PRCM_BASE_ADDR     +  0x2e2c]
set  CM_DIV_M2_DPLL_DISP             [expr       $PRCM_BASE_ADDR     +  0x2e30]
set  CM_SSC_DELTAMSTEP_DPLL_DISP     [expr       $PRCM_BASE_ADDR     +  0x2e48]
set  CM_SSC_MODFREQDIV_DPLL_DISP     [expr       $PRCM_BASE_ADDR     +  0x2e4c]
set  CM_CLKMODE_DPLL_EXTDEV          [expr       $PRCM_BASE_ADDR     +  0x2e60]
set  CM_IDLEST_DPLL_EXTDEV           [expr       $PRCM_BASE_ADDR     +  0x2e64]
set  CM_CLKSEL_DPLL_EXTDEV           [expr       $PRCM_BASE_ADDR     +  0x2e6c]
set  CM_DIV_M2_DPLL_EXTDEV           [expr       $PRCM_BASE_ADDR     +  0x2e70]
set  CM_CLKSEL2_DPLL_EXTDEV          [expr       $PRCM_BASE_ADDR     +  0x2e84]
set  CM_SSC_DELTAMSTEP_DPLL_EXTDEV   [expr       $PRCM_BASE_ADDR     +  0x2e88]
set  CM_SSC_MODFREQDIV_DPLL_EXTDEV   [expr       $PRCM_BASE_ADDR     +  0x2e8c]
set  CM_SHADOW_FREQ_CONFIG1          [expr       $PRCM_BASE_ADDR     +  0x2fa0]
set  CM_SHADOW_FREQ_CONFIG2          [expr       $PRCM_BASE_ADDR     +  0x2fa4]
set  CM_CLKOUT1_CTRL                 [expr       $PRCM_BASE_ADDR     +  0x4100]
set  CM_DLL_CTRL                     [expr       $PRCM_BASE_ADDR     +  0x4104]
set  CM_CLKOUT2_CTRL                 [expr       $PRCM_BASE_ADDR     +  0x4108]
set  CLKSEL_TIMER1MS_CLK             [expr       $PRCM_BASE_ADDR     +  0x4200]
set  CLKSEL_TIMER2_CLK               [expr       $PRCM_BASE_ADDR     +  0x4204]
set  CLKSEL_TIMER3_CLK               [expr       $PRCM_BASE_ADDR     +  0x4208]
set  CLKSEL_TIMER4_CLK               [expr       $PRCM_BASE_ADDR     +  0x420c]
set  CLKSEL_TIMER5_CLK               [expr       $PRCM_BASE_ADDR     +  0x4210]
set  CLKSEL_TIMER6_CLK               [expr       $PRCM_BASE_ADDR     +  0x4214]
set  CLKSEL_TIMER7_CLK               [expr       $PRCM_BASE_ADDR     +  0x4218]
set  CLKSEL_TIMER8_CLK               [expr       $PRCM_BASE_ADDR     +  0x421c]
set  CLKSEL_TIMER9_CLK               [expr       $PRCM_BASE_ADDR     +  0x4220]
set  CLKSEL_TIMER10_CLK              [expr       $PRCM_BASE_ADDR     +  0x4224]
set  CLKSEL_TIMER11_CLK              [expr       $PRCM_BASE_ADDR     +  0x4228]
set  CLKSEL_WDT1_CLK                 [expr       $PRCM_BASE_ADDR     +  0x422c]
set  CLKSEL_SYNCTIMER_CLK            [expr       $PRCM_BASE_ADDR     +  0x4230]
set  CLKSEL_MAC_CLK                  [expr       $PRCM_BASE_ADDR     +  0x4234]
set  CLKSEL_CPTS_RFT_CLK             [expr       $PRCM_BASE_ADDR     +  0x4238]
set  CLKSEL_GFX_FCLK                 [expr       $PRCM_BASE_ADDR     +  0x423c]
set  CLKSEL_GPIO0_DBCLK              [expr       $PRCM_BASE_ADDR     +  0x4240]
set  CLKSEL_LCDC_PIXEL_CLK           [expr       $PRCM_BASE_ADDR     +  0x4244]
set  CLKSEL_ICSS_OCP_CLK             [expr       $PRCM_BASE_ADDR     +  0x4248]
set  CLKSEL_DLL_AGING_CLK            [expr       $PRCM_BASE_ADDR     +  0x4250]
set  CLKSEL_USBPHY32KHZ_GCLK         [expr       $PRCM_BASE_ADDR     +  0x4260]
set  CM_MPU_CLKSTCTRL                [expr       $PRCM_BASE_ADDR     +  0x8300]
set  CM_MPU_MPU_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8320]
set  CM_GFX_L3_CLKSTCTRL             [expr       $PRCM_BASE_ADDR     +  0x8400]
set  CM_GFX_GFX_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8420]
set  CM_RTC_CLKSTCTRL                [expr       $PRCM_BASE_ADDR     +  0x8500]
set  CM_RTC_RTC_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8520]
set  CM_PER_L3_CLKSTCTRL             [expr       $PRCM_BASE_ADDR     +  0x8800]
set  CM_PER_L3_CLKCTRL               [expr       $PRCM_BASE_ADDR     +  0x8820]
set  CM_PER_AES0_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8828]
set  CM_PER_DES_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8830]
set  CM_PER_CRYPTODMA_CLKCTRL        [expr       $PRCM_BASE_ADDR     +  0x8838]
set  CM_PER_L3_INSTR_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x8840]
set  CM_PER_MSTR_EXPS_CLKCTRL        [expr       $PRCM_BASE_ADDR     +  0x8848]
set  CM_PER_OCMCRAM_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8850]
set  CM_PER_SHA0_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8858]
set  CM_PER_SLV_EXPS_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x8860]
set  CM_PER_VPFE0_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8868]
set  CM_PER_VPFE1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8870]
set  CM_PER_TPCC_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8878]
set  CM_PER_TPTC0_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8880]
set  CM_PER_TPTC1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8888]
set  CM_PER_TPTC2_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8890]
set  CM_PER_DLL_AGING_CLKCTRL        [expr       $PRCM_BASE_ADDR     +  0x8898]
set  CM_PER_L4HS_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x88a0]
set  CM_PER_L4FW_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x88a8]
set  CM_PER_L3S_CLKSTCTRL            [expr       $PRCM_BASE_ADDR     +  0x8a00]
set  CM_PER_GPMC_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8a20]
set  CM_PER_IEEE5000_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x8a28]
set  CM_PER_MCASP0_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8a38]
set  CM_PER_MCASP1_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8a40]
set  CM_PER_MMC2_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8a48]
set  CM_PER_QSPI_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8a58]
set  CM_PER_USB_OTG_SS0_CLKCTRL      [expr       $PRCM_BASE_ADDR     +  0x8a60]
set  CM_PER_USB_OTG_SS1_CLKCTRL      [expr       $PRCM_BASE_ADDR     +  0x8a68]
set  CM_PER_ICSS_CLKSTCTRL           [expr       $PRCM_BASE_ADDR     +  0x8b00]
set  CM_PER_ICSS_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8b20]
set  CM_PER_L4LS_CLKSTCTRL           [expr       $PRCM_BASE_ADDR     +  0x8c00]
set  CM_PER_L4LS_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8c20]
set  CM_PER_DCAN0_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c28]
set  CM_PER_DCAN1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c30]
set  CM_PER_EPWMSS0_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c38]
set  CM_PER_EPWMSS1_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c40]
set  CM_PER_EPWMSS2_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c48]
set  CM_PER_EPWMSS3_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c50]
set  CM_PER_EPWMSS4_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c58]
set  CM_PER_EPWMSS5_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8c60]
set  CM_PER_ELM_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8c68]
set  CM_PER_GPIO1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c78]
set  CM_PER_GPIO2_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c80]
set  CM_PER_GPIO3_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c88]
set  CM_PER_GPIO4_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c90]
set  CM_PER_GPIO5_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8c98]
set  CM_PER_HDQ1W_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8ca0]
set  CM_PER_I2C1_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8ca8]
set  CM_PER_I2C2_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8cb0]
set  CM_PER_MAILBOX0_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x8cb8]
set  CM_PER_MMC0_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8cc0]
set  CM_PER_MMC1_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8cc8]
set  CM_PER_PKA_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8cd0]
set  CM_PER_RNG_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8ce0]
set  CM_PER_SPARE0_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8ce8]
set  CM_PER_SPARE1_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8cf0]
set  CM_PER_SPI0_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8d00]
set  CM_PER_SPI1_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8d08]
set  CM_PER_SPI2_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8d10]
set  CM_PER_SPI3_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8d18]
set  CM_PER_SPI4_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8d20]
set  CM_PER_SPINLOCK_CLKCTRL         [expr       $PRCM_BASE_ADDR     +  0x8d28]
set  CM_PER_TIMER2_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d30]
set  CM_PER_TIMER3_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d38]
set  CM_PER_TIMER4_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d40]
set  CM_PER_TIMER5_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d48]
set  CM_PER_TIMER6_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d50]
set  CM_PER_TIMER7_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d58]
set  CM_PER_TIMER8_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d60]
set  CM_PER_TIMER9_CLKCTRL           [expr       $PRCM_BASE_ADDR     +  0x8d68]
set  CM_PER_TIMER10_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8d70]
set  CM_PER_TIMER11_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8d78]
set  CM_PER_UART1_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8d80]
set  CM_PER_UART2_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8d88]
set  CM_PER_UART3_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8d90]
set  CM_PER_UART4_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8d98]
set  CM_PER_UART5_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x8da0]
set  CM_PER_USBPHYOCP2SCP0_CLKCTRL   [expr       $PRCM_BASE_ADDR     +  0x8db8]
set  CM_PER_USBPHYOCP2SCP1_CLKCTRL   [expr       $PRCM_BASE_ADDR     +  0x8dc0]
set  CM_PER_EMIF_CLKSTCTRL           [expr       $PRCM_BASE_ADDR     +  0x8f00]
set  CM_PER_EMIF_CLKCTRL             [expr       $PRCM_BASE_ADDR     +  0x8f20]
set  CM_PER_DLL_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x8f28]
set  CM_PER_EMIF_FW_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x8f30]
set  CM_PER_OTFA_EMIF_CLKCTRL        [expr       $PRCM_BASE_ADDR     +  0x8f38]
set  CM_PER_DSS_CLKSTCTRL            [expr       $PRCM_BASE_ADDR     +  0x9200]
set  CM_PER_DSS_CLKCTRL              [expr       $PRCM_BASE_ADDR     +  0x9220]
set  CM_PER_CPSW_CLKSTCTRL           [expr       $PRCM_BASE_ADDR     +  0x9300]
set  CM_PER_CPGMAC0_CLKCTRL          [expr       $PRCM_BASE_ADDR     +  0x9320]
set  CM_PER_OCPWP_L3_CLKSTCTRL       [expr       $PRCM_BASE_ADDR     +  0x9400]
set  CM_PER_OCPWP_CLKCTRL            [expr       $PRCM_BASE_ADDR     +  0x9420]

set  CONTROL_BASE_ADDR               0x44e10000
set  CONTROL_STATUS                  [expr       $CONTROL_BASE_ADDR  +  0x0040]
set  DEVICE_ID                       [expr       $CONTROL_BASE_ADDR  +  0x0600]
set  DEV_FEATURE                     [expr       $CONTROL_BASE_ADDR  +  0x0604]
set  DEV_ATTRIBUTE                   [expr       $CONTROL_BASE_ADDR  +  0x0610]
set  MAC_ID0_LO                      [expr       $CONTROL_BASE_ADDR  +  0x0630]
set  MAC_ID0_HI                      [expr       $CONTROL_BASE_ADDR  +  0x0634]
set  MAC_ID1_LO                      [expr       $CONTROL_BASE_ADDR  +  0x0638]
set  MAC_ID1_HI                      [expr       $CONTROL_BASE_ADDR  +  0x063c]
set  USB_VID_PID                     [expr       $CONTROL_BASE_ADDR  +  0x07f4]
set  CONTROL_CONF_ECAP0_IN_PWM0_OUT  [expr       $CONTROL_BASE_ADDR  +  0x0964]
set  CONTROL_CONF_SPI4_CS0           [expr       $CONTROL_BASE_ADDR  +  0x0a5c]
set  CONTROL_CONF_SPI2_SCLK          [expr       $CONTROL_BASE_ADDR  +  0x0a60]
set  CONTROL_CONF_SPI2_D0            [expr       $CONTROL_BASE_ADDR  +  0x0a64]
set  CONTROL_CONF_XDMA_EVENT_INTR0   [expr       $CONTROL_BASE_ADDR  +  0x0a70]
set  CONTROL_CONF_XDMA_EVENT_INTR1   [expr       $CONTROL_BASE_ADDR  +  0x0a74]
set  CONTROL_CONF_GPMC_A0            [expr       $CONTROL_BASE_ADDR  +  0x0840]
set  DDR_IO_CTRL                     [expr       $CONTROL_BASE_ADDR  +  0x0e04]
set  VTP_CTRL_REG                    [expr       $CONTROL_BASE_ADDR  +  0x0e0c]
set  VREF_CTRL                       [expr       $CONTROL_BASE_ADDR  +  0x0e14]
set  DDR_CKE_CTRL                    [expr       $CONTROL_BASE_ADDR  +  0x131c]
set  DDR_ADDRCTRL_IOCTRL             [expr       $CONTROL_BASE_ADDR  +  0x1404]
set  DDR_ADDRCTRL_WD0_IOCTRL         [expr       $CONTROL_BASE_ADDR  +  0x1408]
set  DDR_ADDRCTRL_WD1_IOCTRL         [expr       $CONTROL_BASE_ADDR  +  0x140c]
set  DDR_DATA0_IOCTRL                [expr       $CONTROL_BASE_ADDR  +  0x1440]
set  DDR_DATA1_IOCTRL                [expr       $CONTROL_BASE_ADDR  +  0x1444]
set  DDR_DATA2_IOCTRL                [expr       $CONTROL_BASE_ADDR  +  0x1448]
set  DDR_DATA3_IOCTRL                [expr       $CONTROL_BASE_ADDR  +  0x144c]
set  EMIF_SDRAM_CONFIG_EXT           [expr       $CONTROL_BASE_ADDR  +  0x1460]
set  EMIF_SDRAM_STATUS_EXT           [expr       $CONTROL_BASE_ADDR  +  0x1464]

set  GPIO0_BASE_ADDR                 0x44e07000
set  GPIO0_SYSCONFIG                 [expr       $GPIO0_BASE_ADDR    +  0x0010]
set  GPIO0_SYSSTATUS                 [expr       $GPIO0_BASE_ADDR    +  0x0114]
set  GPIO0_CTRL                      [expr       $GPIO0_BASE_ADDR    +  0x0130]
set  GPIO0_OE                        [expr       $GPIO0_BASE_ADDR    +  0x0134]
set  GPIO0_CLEARDATAOUT              [expr       $GPIO0_BASE_ADDR    +  0x0190]
set  GPIO0_SETDATAOUT                [expr       $GPIO0_BASE_ADDR    +  0x0194]

set  GPIO5_BASE_ADDR                 0x48322000
set  GPIO5_SYSCONFIG                 [expr       $GPIO5_BASE_ADDR    +  0x0010]
set  GPIO5_SYSSTATUS                 [expr       $GPIO5_BASE_ADDR    +  0x0114]
set  GPIO5_CTRL                      [expr       $GPIO5_BASE_ADDR    +  0x0130]
set  GPIO5_OE                        [expr       $GPIO5_BASE_ADDR    +  0x0134]
set  GPIO5_CLEARDATAOUT              [expr       $GPIO5_BASE_ADDR    +  0x0190]
set  GPIO5_SETDATAOUT                [expr       $GPIO5_BASE_ADDR    +  0x0194]

set  GPIO1_BASE_ADDR                 0x4804c000
set  GPIO1_SYSCONFIG                 [expr       $GPIO1_BASE_ADDR    +  0x0010]
set  GPIO1_SYSSTATUS                 [expr       $GPIO1_BASE_ADDR    +  0x0114]
set  GPIO1_CTRL                      [expr       $GPIO1_BASE_ADDR    +  0x0130]
set  GPIO1_OE                        [expr       $GPIO1_BASE_ADDR    +  0x0134]
set  GPIO1_CLEARDATAOUT              [expr       $GPIO1_BASE_ADDR    +  0x0190]
set  GPIO1_SETDATAOUT                [expr       $GPIO1_BASE_ADDR    +  0x0194]

set  EMIF_BASE_ADDR                  0x4c000000
set  EMIF_STATUS                     [expr       $EMIF_BASE_ADDR     +  0x0004]
set  EMIF_SDRAM_CONFIG               [expr       $EMIF_BASE_ADDR     +  0x0008]
set  EMIF_SDRAM_CONFIG_2             [expr       $EMIF_BASE_ADDR     +  0x000c]
set  EMIF_SDRAM_REF_CTRL             [expr       $EMIF_BASE_ADDR     +  0x0010]
set  EMIF_SDRAM_REF_CTRL_SHDW        [expr       $EMIF_BASE_ADDR     +  0x0014]
set  EMIF_SDRAM_TIM_1                [expr       $EMIF_BASE_ADDR     +  0x0018]
set  EMIF_SDRAM_TIM_1_SHDW           [expr       $EMIF_BASE_ADDR     +  0x001c]
set  EMIF_SDRAM_TIM_2                [expr       $EMIF_BASE_ADDR     +  0x0020]
set  EMIF_SDRAM_TIM_2_SHDW           [expr       $EMIF_BASE_ADDR     +  0x0024]
set  EMIF_SDRAM_TIM_3                [expr       $EMIF_BASE_ADDR     +  0x0028]
set  EMIF_SDRAM_TIM_3_SHDW           [expr       $EMIF_BASE_ADDR     +  0x002c]
set  EMIF_LPDDR2_NVM_TIM             [expr       $EMIF_BASE_ADDR     +  0x0030]
set  EMIF_LPDDR2_NVM_TIM_SHDW        [expr       $EMIF_BASE_ADDR     +  0x0034]
set  EMIF_PWR_MGMT_CTRL              [expr       $EMIF_BASE_ADDR     +  0x0038]
set  EMIF_PWR_MGMT_CTRL_SHDW         [expr       $EMIF_BASE_ADDR     +  0x003c]
set  EMIF_LPDDR2_MODE_REG_DATA       [expr       $EMIF_BASE_ADDR     +  0x0040]
set  EMIF_LPDDR2_MODE_REG_CFG        [expr       $EMIF_BASE_ADDR     +  0x0050]
set  EMIF_OCP_CONFIG                 [expr       $EMIF_BASE_ADDR     +  0x0054]
set  EMIF_OCP_CFG_VAL_1              [expr       $EMIF_BASE_ADDR     +  0x0058]
set  EMIF_OCP_CFG_VAL_2              [expr       $EMIF_BASE_ADDR     +  0x005c]
set  EMIF_IODFT_TLGC                 [expr       $EMIF_BASE_ADDR     +  0x0060]
set  EMIF_IODFT_CTRL_MISR_RSLT       [expr       $EMIF_BASE_ADDR     +  0x0064]
set  EMIF_IODFT_ADDR_MISR_RSLT       [expr       $EMIF_BASE_ADDR     +  0x0068]
set  EMIF_IODFT_DATA_MISR_RSLT_1     [expr       $EMIF_BASE_ADDR     +  0x006c]
set  EMIF_IODFT_DATA_MISR_RSLT_2     [expr       $EMIF_BASE_ADDR     +  0x0070]
set  EMIF_IODFT_DATA_MISR_RSLT_3     [expr       $EMIF_BASE_ADDR     +  0x0074]
set  EMIF_PERF_CNT_1                 [expr       $EMIF_BASE_ADDR     +  0x0080]
set  EMIF_PERF_CNT_2                 [expr       $EMIF_BASE_ADDR     +  0x0084]
set  EMIF_PERF_CNT_CFG               [expr       $EMIF_BASE_ADDR     +  0x0088]
set  EMIF_PERF_CNT_SEL               [expr       $EMIF_BASE_ADDR     +  0x008c]
set  EMIF_PERF_CNT_TIM               [expr       $EMIF_BASE_ADDR     +  0x0090]
set  EMIF_MISC_REG                   [expr       $EMIF_BASE_ADDR     +  0x0094]
set  EMIF_DLL_CALIB_CTRL             [expr       $EMIF_BASE_ADDR     +  0x0098]
set  EMIF_DLL_CALIB_CTRL_SHDW        [expr       $EMIF_BASE_ADDR     +  0x009c]
set  EMIF_IRQ_EOI                    [expr       $EMIF_BASE_ADDR     +  0x00a0]
set  EMIF_IRQSTATUS_RAW_SYS          [expr       $EMIF_BASE_ADDR     +  0x00a4]
set  EMIF_IRQSTATUS_SYS              [expr       $EMIF_BASE_ADDR     +  0x00ac]
set  EMIF_IRQENABLE_SET_SYS          [expr       $EMIF_BASE_ADDR     +  0x00b4]
set  EMIF_IRQENABLE_CLR_SYS          [expr       $EMIF_BASE_ADDR     +  0x00bc]
set  EMIF_ZQ_CONFIG                  [expr       $EMIF_BASE_ADDR     +  0x00c8]
set  EMIF_TEMP_ALERT_CONFIG          [expr       $EMIF_BASE_ADDR     +  0x00cc]
set  EMIF_OCP_ERR_LOG                [expr       $EMIF_BASE_ADDR     +  0x00d0]
set  EMIF_RDWR_LVL_RMP_WIN           [expr       $EMIF_BASE_ADDR     +  0x00d4]
set  EMIF_RDWR_LVL_RMP_CTRL          [expr       $EMIF_BASE_ADDR     +  0x00d8]
set  EMIF_RDWR_LVL_CTRL              [expr       $EMIF_BASE_ADDR     +  0x00dc]
set  EMIF_DDR_PHY_CTRL_1             [expr       $EMIF_BASE_ADDR     +  0x00e4]
set  EMIF_DDR_PHY_CTRL_1_SHDW        [expr       $EMIF_BASE_ADDR     +  0x00e8]
set  EMIF_DDR_PHY_CTRL_2             [expr       $EMIF_BASE_ADDR     +  0x00ec]
set  EMIF_PRI_COS_MAP                [expr       $EMIF_BASE_ADDR     +  0x0100]
set  EMIF_CONNID_COS_1_MAP           [expr       $EMIF_BASE_ADDR     +  0x0104]
set  EMIF_CONNID_COS_2_MAP           [expr       $EMIF_BASE_ADDR     +  0x0108]
set  ECC_CTRL                        [expr       $EMIF_BASE_ADDR     +  0x0110]
set  ECC_ADDR_RNG_1                  [expr       $EMIF_BASE_ADDR     +  0x0114]
set  ECC_ADDR_RNG_2                  [expr       $EMIF_BASE_ADDR     +  0x0118]
set  EMIF_RD_WR_EXEC_THRSH           [expr       $EMIF_BASE_ADDR     +  0x0120]
set  COS_CONFIG                      [expr       $EMIF_BASE_ADDR     +  0x0124]

set  PHY_STATUS_1                    [expr       $EMIF_BASE_ADDR     +  0x0144]
set  PHY_STATUS_2                    [expr       $EMIF_BASE_ADDR     +  0x0148]
set  PHY_STATUS_3                    [expr       $EMIF_BASE_ADDR     +  0x014c]
set  PHY_STATUS_4                    [expr       $EMIF_BASE_ADDR     +  0x0150]
set  PHY_STATUS_5                    [expr       $EMIF_BASE_ADDR     +  0x0154]
set  PHY_STATUS_6                    [expr       $EMIF_BASE_ADDR     +  0x0158]
set  PHY_STATUS_7                    [expr       $EMIF_BASE_ADDR     +  0x015c]
set  PHY_STATUS_8                    [expr       $EMIF_BASE_ADDR     +  0x0160]
set  PHY_STATUS_9                    [expr       $EMIF_BASE_ADDR     +  0x0164]
set  PHY_STATUS_10                   [expr       $EMIF_BASE_ADDR     +  0x0168]
set  PHY_STATUS_11                   [expr       $EMIF_BASE_ADDR     +  0x016c]
set  PHY_STATUS_12                   [expr       $EMIF_BASE_ADDR     +  0x0170]
set  PHY_STATUS_13                   [expr       $EMIF_BASE_ADDR     +  0x0174]
set  PHY_STATUS_14                   [expr       $EMIF_BASE_ADDR     +  0x0178]
set  PHY_STATUS_15                   [expr       $EMIF_BASE_ADDR     +  0x017c]
set  PHY_STATUS_16                   [expr       $EMIF_BASE_ADDR     +  0x0180]
set  PHY_STATUS_17                   [expr       $EMIF_BASE_ADDR     +  0x0184]
set  PHY_STATUS_18                   [expr       $EMIF_BASE_ADDR     +  0x0188]
set  PHY_STATUS_19                   [expr       $EMIF_BASE_ADDR     +  0x018c]
set  PHY_STATUS_20                   [expr       $EMIF_BASE_ADDR     +  0x0190]
set  PHY_STATUS_21                   [expr       $EMIF_BASE_ADDR     +  0x0194]
set  PHY_STATUS_22                   [expr       $EMIF_BASE_ADDR     +  0x0198]
set  PHY_STATUS_23                   [expr       $EMIF_BASE_ADDR     +  0x019c]
set  PHY_STATUS_24                   [expr       $EMIF_BASE_ADDR     +  0x01a0]
set  PHY_STATUS_25                   [expr       $EMIF_BASE_ADDR     +  0x01a4]
set  PHY_STATUS_26                   [expr       $EMIF_BASE_ADDR     +  0x01a8]
set  PHY_STATUS_27                   [expr       $EMIF_BASE_ADDR     +  0x01ac]
set  PHY_STATUS_28                   [expr       $EMIF_BASE_ADDR     +  0x01b0]

set  EXT_PHY_CTRL_1                  [expr       $EMIF_BASE_ADDR     +  0x0200]
set  EXT_PHY_CTRL_1_SHDW             [expr       $EMIF_BASE_ADDR     +  0x0204]
set  EXT_PHY_CTRL_2                  [expr       $EMIF_BASE_ADDR     +  0x0208]
set  EXT_PHY_CTRL_2_SHDW             [expr       $EMIF_BASE_ADDR     +  0x020c]
set  EXT_PHY_CTRL_3                  [expr       $EMIF_BASE_ADDR     +  0x0210]
set  EXT_PHY_CTRL_3_SHDW             [expr       $EMIF_BASE_ADDR     +  0x0214]
set  EXT_PHY_CTRL_4                  [expr       $EMIF_BASE_ADDR     +  0x0218]
set  EXT_PHY_CTRL_4_SHDW             [expr       $EMIF_BASE_ADDR     +  0x021c]
set  EXT_PHY_CTRL_5                  [expr       $EMIF_BASE_ADDR     +  0x0220]
set  EXT_PHY_CTRL_5_SHDW             [expr       $EMIF_BASE_ADDR     +  0x0224]
set  EXT_PHY_CTRL_6                  [expr       $EMIF_BASE_ADDR     +  0x0228]
set  EXT_PHY_CTRL_6_SHDW             [expr       $EMIF_BASE_ADDR     +  0x022c]
set  EXT_PHY_CTRL_7                  [expr       $EMIF_BASE_ADDR     +  0x0230]
set  EXT_PHY_CTRL_7_SHDW             [expr       $EMIF_BASE_ADDR     +  0x0234]
set  EXT_PHY_CTRL_8                  [expr       $EMIF_BASE_ADDR     +  0x0238]
set  EXT_PHY_CTRL_8_SHDW             [expr       $EMIF_BASE_ADDR     +  0x023c]
set  EXT_PHY_CTRL_9                  [expr       $EMIF_BASE_ADDR     +  0x0240]
set  EXT_PHY_CTRL_9_SHDW             [expr       $EMIF_BASE_ADDR     +  0x0244]
set  EXT_PHY_CTRL_10                 [expr       $EMIF_BASE_ADDR     +  0x0248]
set  EXT_PHY_CTRL_10_SHDW            [expr       $EMIF_BASE_ADDR     +  0x024c]
set  EXT_PHY_CTRL_11                 [expr       $EMIF_BASE_ADDR     +  0x0250]
set  EXT_PHY_CTRL_11_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0254]
set  EXT_PHY_CTRL_12                 [expr       $EMIF_BASE_ADDR     +  0x0258]
set  EXT_PHY_CTRL_12_SHDW            [expr       $EMIF_BASE_ADDR     +  0x025c]
set  EXT_PHY_CTRL_13                 [expr       $EMIF_BASE_ADDR     +  0x0260]
set  EXT_PHY_CTRL_13_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0264]
set  EXT_PHY_CTRL_14                 [expr       $EMIF_BASE_ADDR     +  0x0268]
set  EXT_PHY_CTRL_14_SHDW            [expr       $EMIF_BASE_ADDR     +  0x026c]
set  EXT_PHY_CTRL_15                 [expr       $EMIF_BASE_ADDR     +  0x0270]
set  EXT_PHY_CTRL_15_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0274]
set  EXT_PHY_CTRL_16                 [expr       $EMIF_BASE_ADDR     +  0x0278]
set  EXT_PHY_CTRL_16_SHDW            [expr       $EMIF_BASE_ADDR     +  0x027c]
set  EXT_PHY_CTRL_17                 [expr       $EMIF_BASE_ADDR     +  0x0280]
set  EXT_PHY_CTRL_17_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0284]
set  EXT_PHY_CTRL_18                 [expr       $EMIF_BASE_ADDR     +  0x0288]
set  EXT_PHY_CTRL_18_SHDW            [expr       $EMIF_BASE_ADDR     +  0x028c]
set  EXT_PHY_CTRL_19                 [expr       $EMIF_BASE_ADDR     +  0x0290]
set  EXT_PHY_CTRL_19_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0294]
set  EXT_PHY_CTRL_20                 [expr       $EMIF_BASE_ADDR     +  0x0298]
set  EXT_PHY_CTRL_20_SHDW            [expr       $EMIF_BASE_ADDR     +  0x029c]
set  EXT_PHY_CTRL_21                 [expr       $EMIF_BASE_ADDR     +  0x02a0]
set  EXT_PHY_CTRL_21_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02a4]
set  EXT_PHY_CTRL_22                 [expr       $EMIF_BASE_ADDR     +  0x02a8]
set  EXT_PHY_CTRL_22_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02ac]
set  EXT_PHY_CTRL_23                 [expr       $EMIF_BASE_ADDR     +  0x02b0]
set  EXT_PHY_CTRL_23_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02b4]
set  EXT_PHY_CTRL_24                 [expr       $EMIF_BASE_ADDR     +  0x02b8]
set  EXT_PHY_CTRL_24_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02bc]
set  EXT_PHY_CTRL_25                 [expr       $EMIF_BASE_ADDR     +  0x02c0]
set  EXT_PHY_CTRL_25_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02c4]
set  EXT_PHY_CTRL_26                 [expr       $EMIF_BASE_ADDR     +  0x02c8]
set  EXT_PHY_CTRL_26_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02cc]
set  EXT_PHY_CTRL_27                 [expr       $EMIF_BASE_ADDR     +  0x02d0]
set  EXT_PHY_CTRL_27_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02d4]
set  EXT_PHY_CTRL_28                 [expr       $EMIF_BASE_ADDR     +  0x02d8]
set  EXT_PHY_CTRL_28_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02dc]
set  EXT_PHY_CTRL_29                 [expr       $EMIF_BASE_ADDR     +  0x02e0]
set  EXT_PHY_CTRL_29_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02e4]
set  EXT_PHY_CTRL_30                 [expr       $EMIF_BASE_ADDR     +  0x02e8]
set  EXT_PHY_CTRL_30_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02ec]
set  EXT_PHY_CTRL_31                 [expr       $EMIF_BASE_ADDR     +  0x02f0]
set  EXT_PHY_CTRL_31_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02f4]
set  EXT_PHY_CTRL_32                 [expr       $EMIF_BASE_ADDR     +  0x02f8]
set  EXT_PHY_CTRL_32_SHDW            [expr       $EMIF_BASE_ADDR     +  0x02fc]
set  EXT_PHY_CTRL_33                 [expr       $EMIF_BASE_ADDR     +  0x0300]
set  EXT_PHY_CTRL_33_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0304]
set  EXT_PHY_CTRL_34                 [expr       $EMIF_BASE_ADDR     +  0x0308]
set  EXT_PHY_CTRL_34_SHDW            [expr       $EMIF_BASE_ADDR     +  0x030c]
set  EXT_PHY_CTRL_35                 [expr       $EMIF_BASE_ADDR     +  0x0310]
set  EXT_PHY_CTRL_35_SHDW            [expr       $EMIF_BASE_ADDR     +  0x0314]
set  EXT_PHY_CTRL_36                 [expr       $EMIF_BASE_ADDR     +  0x0318]
set  EXT_PHY_CTRL_36_SHDW            [expr       $EMIF_BASE_ADDR     +  0x031c]

set  WDT1_BASE_ADDR                  0x44e35000
set  WDT1_W_PEND_WSPR                [expr       $WDT1_BASE_ADDR     +  0x0034]
set  WDT1_WSPR                       [expr       $WDT1_BASE_ADDR     +  0x0048]

set  RTC_BASE_ADDR                   0x44e3e000
set  RTC_KICK0R                      [expr       $RTC_BASE_ADDR      +  0x6c]
set  RTC_KICK1R                      [expr       $RTC_BASE_ADDR      +  0x70]


if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME am437x
}

set JRC_MODULE		icepick_d
set DEBUGSS_MODULE	debugss
set M3_MODULE		m3_wakeupss

set JRC_NAME		$_CHIPNAME.$JRC_MODULE
set DEBUGSS_NAME	$_CHIPNAME.$DEBUGSS_MODULE
set M3_NAME		$_CHIPNAME.$M3_MODULE
set _TARGETNAME		$_CHIPNAME.mpuss

#
# M3 WakeupSS DAP
#
if { [info exists M3_DAP_TAPID] } {
	set _M3_DAP_TAPID $M3_DAP_TAPID
} else {
	set _M3_DAP_TAPID 0x4b6b902f
}
jtag newtap $_CHIPNAME $M3_MODULE -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M3_DAP_TAPID -disable
jtag configure $M3_NAME -event tap-enable "icepick_d_tapenable $JRC_NAME 11 0"
dap create $M3_NAME.dap -chain-position $M3_NAME

#
# DebugSS DAP
#
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x46b6902f
}
jtag newtap $_CHIPNAME $DEBUGSS_MODULE -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
jtag configure $DEBUGSS_NAME -event tap-enable "icepick_d_tapenable $JRC_NAME 12 0"
dap create $DEBUGSS_NAME.dap -chain-position $DEBUGSS_NAME

#
# ICEpick-D (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b98c02f
}
jtag newtap $_CHIPNAME $JRC_MODULE -irlen 6 -ircapture 0x1 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version
jtag configure $JRC_NAME -event setup "jtag tapenable $DEBUGSS_NAME"
 # some TCK tycles are required to activate the DEBUG power domain
jtag configure $JRC_NAME -event post-reset "runtest 100"

#
# Cortex-A9 target
#
target create $_TARGETNAME cortex_a -dap $DEBUGSS_NAME.dap -coreid 0 -dbgbase 0x80000000


# SRAM: 256K at 0x4030.0000
$_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x40000

# Disables watchdog timer after reset otherwise board won't stay in
# halted state.
proc disable_watchdog { } {
	global WDT1_WSPR
	global WDT1_W_PEND_WSPR
	global _TARGETNAME

	set curstate [$_TARGETNAME curstate]

	if { [string compare $curstate halted] == 0 } {
		set WDT_DISABLE_SEQ1	0xaaaa
		set WDT_DISABLE_SEQ2	0x5555

		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ1

		# Empty body to make sure this executes as fast as possible.
		# We don't want any delays here otherwise romcode might start
		# executing and end up changing state of certain IPs.
		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }

		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ2
		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }
	}
}

proc ceil { x y } {
	return [ expr ($x + $y - 1) / $y ]
}

proc device_type { } {
	global CONTROL_STATUS

	set tmp [ mrw $CONTROL_STATUS ]
	set tmp [ expr $tmp & 0x700 ]
	set tmp [ expr $tmp >> 8 ]

	return $tmp
}

proc get_input_clock_frequency { } {
	global CONTROL_STATUS

	if { [ device_type ] != 3 } {
		error "Unknown device type\n"
		return -1
	}

	set freq [ mrw $CONTROL_STATUS ]
	set freq [ expr $freq & 0x00c00000 ]
	set freq [ expr $freq >> 22 ]

	switch $freq {
		0 {
			set CLKIN 19200000
		}

		1 {
			set CLKIN 24000000
		}

		2 {
			set CLKIN 25000000
		}

		3 {
			set CLKIN 26000000
		}
	}

	return $CLKIN
}

proc mpu_pll_config { CLKIN N M M2 } {
	global CM_CLKMODE_DPLL_MPU
	global CM_CLKSEL_DPLL_MPU
	global CM_DIV_M2_DPLL_MPU
	global CM_IDLEST_DPLL_MPU

	set clksel [ mrw $CM_CLKSEL_DPLL_MPU ]
	set div_m2 [ mrw $CM_DIV_M2_DPLL_MPU ]

	mww $CM_CLKMODE_DPLL_MPU 0x4
	while { !([ mrw $CM_IDLEST_DPLL_MPU ] & 0x0100) } { }

	set clksel [ expr $clksel & (~0x7ffff) ]
	set clksel [ expr $clksel | ($M << 0x8) | $N ]
	mww $CM_CLKSEL_DPLL_MPU $clksel

	set div_m2 [ expr $div_m2 & (~0x1f) ]
	set div_m2 [ expr $div_m2 | $M2 ]
	mww $CM_DIV_M2_DPLL_MPU $div_m2

	mww $CM_CLKMODE_DPLL_MPU 0x7
	while { [ mrw $CM_IDLEST_DPLL_MPU ] != 1 } { }

	echo "MPU DPLL locked"
}

proc core_pll_config { CLKIN N M M4 M5 M6 } {
	global CM_CLKMODE_DPLL_CORE
	global CM_CLKSEL_DPLL_CORE
	global CM_DIV_M4_DPLL_CORE
	global CM_DIV_M5_DPLL_CORE
	global CM_DIV_M6_DPLL_CORE
	global CM_IDLEST_DPLL_CORE

	set clksel [ mrw $CM_CLKSEL_DPLL_CORE ]

	mww $CM_CLKMODE_DPLL_CORE 0x4
	while { !([ mrw $CM_IDLEST_DPLL_CORE ] & 0x0100) } { }

	set clksel [ expr $clksel & (~0x7ffff) ]
	set clksel [ expr $clksel | ($M << 0x8) | $N ]
	mww $CM_CLKSEL_DPLL_CORE $clksel
	mww $CM_DIV_M4_DPLL_CORE $M4
	mww $CM_DIV_M5_DPLL_CORE $M5
	mww $CM_DIV_M6_DPLL_CORE $M6

	mww $CM_CLKMODE_DPLL_CORE 0x7
	while { !([ mrw $CM_IDLEST_DPLL_CORE ] & 0x01) } { }

	echo "CORE DPLL locked"
}

proc per_pll_config { CLKIN N M M2 } {
	global CM_CLKMODE_DPLL_PER
	global CM_CLKSEL_DPLL_PER
	global CM_DIV_M2_DPLL_PER
	global CM_IDLEST_DPLL_PER

	set x [ expr $M * $CLKIN / 1000000 ]
	set y [ expr ($N + 1) * 250 ]
	set sd [ ceil $x $y ]

	set clksel [ mrw $CM_CLKSEL_DPLL_PER ]
	set div_m2 [ mrw $CM_DIV_M2_DPLL_PER ]

	mww $CM_CLKMODE_DPLL_PER 0x4
	while { !([ mrw $CM_IDLEST_DPLL_PER ] & 0x0100) } { }

	set clksel [ expr $clksel & (~0xff0fffff) ]
	set clksel [ expr $clksel | ($M << 0x8) | $N ]
	set clksel [ expr $clksel | ($sd << 24) ]
	mww $CM_CLKSEL_DPLL_PER $clksel

	set div_m2 [ expr 0xffffff80 | $M2 ]

	mww $CM_CLKMODE_DPLL_PER 0x7
	while { !([ mrw $CM_IDLEST_DPLL_PER ] & 0x01) } { }

	echo "PER DPLL locked"
}

proc ddr_pll_config { CLKIN N M M2 M4 } {
	global CM_CLKMODE_DPLL_DDR
	global CM_CLKSEL_DPLL_DDR
	global CM_DIV_M2_DPLL_DDR
	global CM_DIV_M4_DPLL_DDR
	global CM_IDLEST_DPLL_DDR

	set clksel [ mrw $CM_CLKSEL_DPLL_DDR ]
	set div_m2 [ mrw $CM_DIV_M2_DPLL_DDR ]

	mww $CM_CLKMODE_DPLL_DDR 0x4
	while { !([ mrw $CM_IDLEST_DPLL_DDR ] & 0x0100) } { }

	set clksel [ expr $clksel & (~0x7ffff) ]
	set clksel [ expr $clksel | ($M << 8) | $N ]
	mww $CM_CLKSEL_DPLL_DDR $clksel

	set div_m2 [ expr ($div_m2 & 0xffffffe0) | $M2 ]
	mww $CM_DIV_M2_DPLL_DDR $div_m2
	mww $CM_DIV_M4_DPLL_DDR $M4

	mww $CM_CLKMODE_DPLL_DDR 0x7
	while { !([ mrw $CM_IDLEST_DPLL_DDR ] & 0x01) } { }

	echo "DDR DPLL Locked"
}

proc config_opp100 { } {
	set CLKIN [ get_input_clock_frequency ]

	if { $CLKIN == -1 } {
		return -1
	}

	switch $CLKIN {
		24000000 {
			mpu_pll_config   $CLKIN  0  25   1
			core_pll_config  $CLKIN  2  125  10  8  4
			per_pll_config   $CLKIN  9  400  5
			ddr_pll_config   $CLKIN  2  50   1   2
		}

		25000000 {
			mpu_pll_config   $CLKIN  0  24   1
			core_pll_config  $CLKIN  0  40   10  8  4
			per_pll_config   $CLKIN  9  384  5
			ddr_pll_config   $CLKIN  0  16   1   2
		}

		26000000 {
			mpu_pll_config   $CLKIN  12  300  1
			core_pll_config  $CLKIN  12  500  10  8  4
			per_pll_config   $CLKIN  12  480  5
			ddr_pll_config   $CLKIN  12  200  1   2
		}

		19200000 {
			mpu_pll_config   $CLKIN  3   125  1
			core_pll_config  $CLKIN  11  625  10  8  4
			per_pll_config   $CLKIN  7   400  5
			ddr_pll_config   $CLKIN  2   125  1   2
		}
	}
}

proc emif_prcm_clk_enable { } {
	global CM_PER_EMIF_FW_CLKCTRL
	global CM_PER_EMIF_CLKCTRL

	mww $CM_PER_EMIF_FW_CLKCTRL 0x02
	mww $CM_PER_EMIF_CLKCTRL 0x02

	while { [ mrw $CM_PER_EMIF_CLKCTRL ] != 0x02 } { }
}

proc vtp_enable { } {
	global VTP_CTRL_REG

	set vtp [ expr [ mrw $VTP_CTRL_REG ] | 0x40 ]
	mww $VTP_CTRL_REG $vtp

	set vtp [ expr [ mrw $VTP_CTRL_REG ] & ~0x01 ]
	mww $VTP_CTRL_REG $vtp

	set vtp [ expr [ mrw $VTP_CTRL_REG ] | 0x01 ]
	mww $VTP_CTRL_REG $vtp

}

proc config_ddr_ioctrl { } {
	global DDR_ADDRCTRL_IOCTRL
	global DDR_ADDRCTRL_WD0_IOCTRL
	global DDR_ADDRCTRL_WD1_IOCTRL
	global DDR_CKE_CTRL
	global DDR_DATA0_IOCTRL
	global DDR_DATA1_IOCTRL
	global DDR_DATA2_IOCTRL
	global DDR_DATA3_IOCTRL
	global DDR_IO_CTRL

	mww $DDR_ADDRCTRL_IOCTRL	0x84
	mww $DDR_ADDRCTRL_WD0_IOCTRL	0x00
	mww $DDR_ADDRCTRL_WD1_IOCTRL	0x00
	mww $DDR_DATA0_IOCTRL		0x84
	mww $DDR_DATA1_IOCTRL		0x84
	mww $DDR_DATA2_IOCTRL		0x84
	mww $DDR_DATA3_IOCTRL		0x84

	mww $DDR_IO_CTRL		0x00
	mww $DDR_CKE_CTRL		0x03
}

proc config_ddr_phy { } {
	global EMIF_DDR_PHY_CTRL_1
	global EMIF_DDR_PHY_CTRL_1_SHDW

	global EXT_PHY_CTRL_1
	global EXT_PHY_CTRL_1_SHDW
	global EXT_PHY_CTRL_2
	global EXT_PHY_CTRL_2_SHDW
	global EXT_PHY_CTRL_3
	global EXT_PHY_CTRL_3_SHDW
	global EXT_PHY_CTRL_4
	global EXT_PHY_CTRL_4_SHDW
	global EXT_PHY_CTRL_5
	global EXT_PHY_CTRL_5_SHDW
	global EXT_PHY_CTRL_6
	global EXT_PHY_CTRL_6_SHDW
	global EXT_PHY_CTRL_7
	global EXT_PHY_CTRL_7_SHDW
	global EXT_PHY_CTRL_8
	global EXT_PHY_CTRL_8_SHDW
	global EXT_PHY_CTRL_9
	global EXT_PHY_CTRL_9_SHDW
	global EXT_PHY_CTRL_10
	global EXT_PHY_CTRL_10_SHDW
	global EXT_PHY_CTRL_11
	global EXT_PHY_CTRL_11_SHDW
	global EXT_PHY_CTRL_12
	global EXT_PHY_CTRL_12_SHDW
	global EXT_PHY_CTRL_13
	global EXT_PHY_CTRL_13_SHDW
	global EXT_PHY_CTRL_14
	global EXT_PHY_CTRL_14_SHDW
	global EXT_PHY_CTRL_15
	global EXT_PHY_CTRL_15_SHDW
	global EXT_PHY_CTRL_16
	global EXT_PHY_CTRL_16_SHDW
	global EXT_PHY_CTRL_17
	global EXT_PHY_CTRL_17_SHDW
	global EXT_PHY_CTRL_18
	global EXT_PHY_CTRL_18_SHDW
	global EXT_PHY_CTRL_19
	global EXT_PHY_CTRL_19_SHDW
	global EXT_PHY_CTRL_20
	global EXT_PHY_CTRL_20_SHDW
	global EXT_PHY_CTRL_21
	global EXT_PHY_CTRL_21_SHDW
	global EXT_PHY_CTRL_22
	global EXT_PHY_CTRL_22_SHDW
	global EXT_PHY_CTRL_23
	global EXT_PHY_CTRL_23_SHDW
	global EXT_PHY_CTRL_24
	global EXT_PHY_CTRL_24_SHDW
	global EXT_PHY_CTRL_25
	global EXT_PHY_CTRL_25_SHDW
	global EXT_PHY_CTRL_26
	global EXT_PHY_CTRL_26_SHDW
	global EXT_PHY_CTRL_27
	global EXT_PHY_CTRL_27_SHDW
	global EXT_PHY_CTRL_28
	global EXT_PHY_CTRL_28_SHDW
	global EXT_PHY_CTRL_29
	global EXT_PHY_CTRL_29_SHDW
	global EXT_PHY_CTRL_30
	global EXT_PHY_CTRL_30_SHDW
	global EXT_PHY_CTRL_31
	global EXT_PHY_CTRL_31_SHDW
	global EXT_PHY_CTRL_32
	global EXT_PHY_CTRL_32_SHDW
	global EXT_PHY_CTRL_33
	global EXT_PHY_CTRL_33_SHDW
	global EXT_PHY_CTRL_34
	global EXT_PHY_CTRL_34_SHDW
	global EXT_PHY_CTRL_35
	global EXT_PHY_CTRL_35_SHDW
	global EXT_PHY_CTRL_36
	global EXT_PHY_CTRL_36_SHDW

	mww $EMIF_DDR_PHY_CTRL_1	0x8009
	mww $EMIF_DDR_PHY_CTRL_1_SHDW	0x8009

	set slave_ratio		0x80
	set gatelvl_init_ratio	0x20
	set wr_dqs_slave_delay	0x60
	set rd_dqs_slave_delay	0x60
	set dq_offset		0x40
	set gatelvl_init_mode	0x01
	set wr_data_slave_delay	0x80
	set gatelvl_num_dq0 0x0f
	set wrlvl_num_dq0 0x0f

	mww $EXT_PHY_CTRL_1        [ expr ($slave_ratio << 20) | ($slave_ratio << 10) | $slave_ratio ]
	mww $EXT_PHY_CTRL_1_SHDW   [ expr ($slave_ratio << 20) | ($slave_ratio << 10) | $slave_ratio ]
	mww $EXT_PHY_CTRL_26       [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_26_SHDW  [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_27       [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_27_SHDW  [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_28       [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_28_SHDW  [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_29       [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_29_SHDW  [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_30       [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_30_SHDW  [ expr ($gatelvl_init_ratio << 16) | $gatelvl_init_ratio ]
	mww $EXT_PHY_CTRL_31       0x00
	mww $EXT_PHY_CTRL_31_SHDW  0x00
	mww $EXT_PHY_CTRL_32       0x00
	mww $EXT_PHY_CTRL_32_SHDW  0x00
	mww $EXT_PHY_CTRL_33       0x00
	mww $EXT_PHY_CTRL_33_SHDW  0x00
	mww $EXT_PHY_CTRL_34       0x00
	mww $EXT_PHY_CTRL_34_SHDW  0x00
	mww $EXT_PHY_CTRL_35       0x00
	mww $EXT_PHY_CTRL_35_SHDW  0x00
	mww $EXT_PHY_CTRL_22       0x00
	mww $EXT_PHY_CTRL_22_SHDW  0x00
	mww $EXT_PHY_CTRL_23       [ expr ($wr_dqs_slave_delay  <<  16) | $rd_dqs_slave_delay ]
	mww $EXT_PHY_CTRL_23_SHDW  [ expr ($wr_dqs_slave_delay  <<  16) | $rd_dqs_slave_delay ]
	mww $EXT_PHY_CTRL_24       [ expr ($dq_offset << 24) | ($gatelvl_init_mode << 16) | $wr_data_slave_delay ]
	mww $EXT_PHY_CTRL_24_SHDW  [ expr ($dq_offset << 24) | ($gatelvl_init_mode << 16) | $wr_data_slave_delay << 0 ]
	mww $EXT_PHY_CTRL_25       [ expr ($dq_offset << 21) | ($dq_offset << 14) | ($dq_offset << 7) | $dq_offset ]
	mww $EXT_PHY_CTRL_25_SHDW  [ expr ($dq_offset << 21) | ($dq_offset << 14) | ($dq_offset << 7) | $dq_offset ]
	mww $EXT_PHY_CTRL_36       [ expr ($wrlvl_num_dq0 << 4) | $gatelvl_num_dq0 ]
	mww $EXT_PHY_CTRL_36_SHDW  [ expr ($wrlvl_num_dq0 << 4) | $gatelvl_num_dq0 ]
}

proc config_ddr_timing { } {
	global EMIF_SDRAM_TIM_1
	global EMIF_SDRAM_TIM_2
	global EMIF_SDRAM_TIM_3
	global EMIF_SDRAM_TIM_1_SHDW
	global EMIF_SDRAM_TIM_2_SHDW
	global EMIF_SDRAM_TIM_3_SHDW
	global EMIF_ZQ_CONFIG

	mww $EMIF_SDRAM_TIM_1		0xeaaad4db
	mww $EMIF_SDRAM_TIM_1_SHDW	0xeaaad4db

	mww $EMIF_SDRAM_TIM_2		0x266b7fda
	mww $EMIF_SDRAM_TIM_2_SHDW	0x266b7fda

	mww $EMIF_SDRAM_TIM_3		0x107f8678
	mww $EMIF_SDRAM_TIM_3_SHDW	0x107f8678

	mww $EMIF_ZQ_CONFIG		0x50074be4
}

proc config_ddr_pm { } {
	global EMIF_PWR_MGMT_CTRL
	global EMIF_PWR_MGMT_CTRL_SHDW
	global EMIF_DLL_CALIB_CTRL
	global EMIF_DLL_CALIB_CTRL_SHDW
	global EMIF_TEMP_ALERT_CONFIG

	mww $EMIF_PWR_MGMT_CTRL		0x00
	mww $EMIF_PWR_MGMT_CTRL_SHDW	0x00
	mww $EMIF_DLL_CALIB_CTRL	0x00050000
	mww $EMIF_DLL_CALIB_CTRL_SHDW	0x00050000
	mww $EMIF_TEMP_ALERT_CONFIG	0x00
}

proc config_ddr_priority { } {
	global EMIF_PRI_COS_MAP
	global EMIF_CONNID_COS_1_MAP
	global EMIF_CONNID_COS_2_MAP
	global EMIF_RD_WR_EXEC_THRSH
	global COS_CONFIG

	mww $EMIF_PRI_COS_MAP       0x00
	mww $EMIF_CONNID_COS_1_MAP  0x00
	mww $EMIF_CONNID_COS_2_MAP  0x0
	mww $EMIF_RD_WR_EXEC_THRSH  0x0405
	mww $COS_CONFIG             0x00ffffff
}

proc config_ddr3 { SDRAM_CONFIG } {
	global CM_DLL_CTRL
	global EMIF_IODFT_TLGC
	global EMIF_RDWR_LVL_CTRL
	global EMIF_RDWR_LVL_RMP_CTRL
	global EMIF_SDRAM_CONFIG
	global EMIF_SDRAM_CONFIG_EXT
	global EMIF_SDRAM_REF_CTRL
	global EMIF_SDRAM_REF_CTRL_SHDW
	global EMIF_STATUS
	global EXT_PHY_CTRL_36
	global EXT_PHY_CTRL_36_SHDW

	emif_prcm_clk_enable
	vtp_enable

	set dll [ expr [ mrw $CM_DLL_CTRL ] & ~0x01 ]
	mww $CM_DLL_CTRL $dll
	while { !([ mrw $CM_DLL_CTRL ] & 0x04) } { }

	config_ddr_ioctrl

	mww $EMIF_SDRAM_CONFIG_EXT	0xc163
	mww $EMIF_IODFT_TLGC		0x2011
	mww $EMIF_IODFT_TLGC		0x2411
	mww $EMIF_IODFT_TLGC		0x2011
	mww $EMIF_SDRAM_REF_CTRL	0x80003000

	config_ddr_phy

	mww $EMIF_IODFT_TLGC		0x2011
	mww $EMIF_IODFT_TLGC		0x2411
	mww $EMIF_IODFT_TLGC		0x2011

	config_ddr_timing
	config_ddr_pm
	config_ddr_priority

	mww $EMIF_SDRAM_REF_CTRL	0x3000
	mww $EMIF_SDRAM_CONFIG		$SDRAM_CONFIG

	mww $EMIF_SDRAM_REF_CTRL	0x0c30
	mww $EMIF_SDRAM_REF_CTRL_SHDW	0x0c30

	sleep 10

	set tmp [ expr [ mrw $EXT_PHY_CTRL_36 ] | 0x0100 ]
	mww $EXT_PHY_CTRL_36		$tmp
	mww $EXT_PHY_CTRL_36_SHDW	$tmp

	mww $EMIF_RDWR_LVL_RMP_CTRL	0x80000000
	mww $EMIF_RDWR_LVL_CTRL		0x80000000

	while { [ mrw $EMIF_RDWR_LVL_CTRL ] & 0x80000000 } { }

	if { [ mrw $EMIF_STATUS ]  & 0x70 } {
		error "DDR3 Hardware Leveling incomplete!!!"
	}
}

proc init_platform { SDRAM_CONFIG } {
	config_opp100
	config_ddr3 $SDRAM_CONFIG
}

$_TARGETNAME configure -event reset-init { init_platform 0x61a013b2 }
$_TARGETNAME configure -event reset-end { disable_watchdog }
#
# Copyright (C)   2010-2011   by Karl Kurbjun
# Copyright (C)   2009-2011   by yvind Harboe
# Copyright (C)   2009        by David Brownell
# Copyright (C)   2009        by Magnus Lundin
#
# TI AM/DM37x Technical Reference Manual (Version R)
#  http://www.ti.com/lit/ug/sprugn4r/sprugn4r.pdf
#
# This script is based on the AM3517 initialization.  It should be considered
# preliminary since it needs more complete testing and only the basic
# operations work.
#

###############################################################################
# User modifiable parameters
###############################################################################

# This script uses the variable CHIPTYPE to determine whether this is an AM35x
# or DM37x target. If CHIPTYPE is not set it will error out.
if { [info exists CHIPTYPE] } {

   if { [info exists CHIPNAME] } {
      set _CHIPNAME $CHIPNAME
   } else {
      set _CHIPNAME $CHIPTYPE
   }

   switch $CHIPTYPE {
      dm37x {
         # Primary TAP: ICEPick-C (JTAG route controller) and boundary scan
         set _JRC_TAPID "-expected-id 0x2b89102f -expected-id 0x1b89102f -expected-id 0x0b89102f"
      }
      am35x {
         # Primary TAP: ICEPick-C (JTAG route controller) and boundary scan
         set _JRC_TAPID "-expected-id 0x0b7ae02f -expected-id 0x0b86802f"
      }
      default {
         error "ERROR: CHIPTYPE was set, but it was not set to a valid value.  Acceptable values are \"dm37x\" or \"am35x\"."
      }
   }
} else {
  error "ERROR: CHIPTYPE was not defined. Please set CHIPTYPE to \"am35x\" for the AM35x or \"dm37x\" for the DM37x series in the board configuration."
}

# Run the adapter at the fastest acceptable speed with the slowest possible
# core clock.
adapter speed 10

###############################################################################
# JTAG setup
# The OpenOCD commands are described in the TAP Declaration section
#  http://openocd.org/doc/html/TAP-Declaration.html
###############################################################################

# The AM/DM37x has an ICEPick module in it like many of TI's other devices. More
#  can be read about this module in sprugn4r in chapter 27:  "Debug and
#  Emulation".  The module is used to route the JTAG chain to the various
#  subsystems in the chip.
source [find target/icepick.cfg]

# The TAP order should be described from the TDO connection in OpenOCD to the
#  TDI pin.  The OpenOCD FAQ describes this in more detail:
#  http://openocd.org/doc/html/FAQ.html

# From SPRUGN4R CH27 the available secondary TAPs are in this order from TDO:
#
#  Device   |  TAP number
#  ---------|------------
#  DAP      |  3
#  Sequencer|  2   Note: The sequencer is an ARM968
#  DSP      |  1
#  D2D      |  0
#
# Right now the only secondary tap enabled is the DAP so the rest are left
# undescribed.

######
# Start of Chain Description
# The Secondary TAPs all have enable functions defined for use with the ICEPick
# Only the DAP is enabled.  The AM37xx does not have the Sequencer or DSP but
# the TAP numbers for ICEPick do not change.
#
# TODO: A disable function should also be added.
######

# Secondary TAP: DAP is closest to the TDO output
# The TAP enable event also needs to be described
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -disable
jtag configure $_CHIPNAME.cpu -event tap-enable \
   "icepick_c_tapenable $_CHIPNAME.jrc 3"

# These taps are only present in the DM37x series.
if { $CHIPTYPE == "dm37x" } {
   # Secondary TAP: Sequencer (ARM968) it is not in the chain by default
   # The ICEPick can be used to enable it in the chain.
   jtag newtap $_CHIPNAME arm2 -irlen 4 -ircapture 0x1 -irmask 0x0f -disable
   jtag configure $_CHIPNAME.arm2 -event tap-enable \
      "icepick_c_tapenable $_CHIPNAME.jrc 2"

   # Secondary TAP: C64x+ DSP - it is not in the chain by default (-disable)
   # The ICEPick can be used to enable it in the chain.
   jtag newtap $_CHIPNAME dsp -irlen 38 -ircapture 0x25 -irmask 0x3f -disable
   jtag configure $_CHIPNAME.dsp -event tap-enable \
      "icepick_c_tapenable $_CHIPNAME.jrc 1"
}

# Secondary TAP: D2D it is not in the chain by default (-disable)
# The ICEPick can be used to enable it in the chain.
# This IRLEN is probably incorrect - not sure where the documentation is.
jtag newtap $_CHIPNAME d2d -irlen 4 -ircapture 0x1 -irmask 0x0f -disable
jtag configure $_CHIPNAME.d2d -event tap-enable \
   "icepick_c_tapenable $_CHIPNAME.jrc 0"

# Primary TAP: ICEPick - it is closest to TDI so last in the chain
eval "jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f $_JRC_TAPID"

######
# End of Chain Description
######

######
# Start JTAG TAP events
######

# some TCK tycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"

# Enable the DAP TAP
jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"

######
# End JTAG TAP events
######

###############################################################################
# Target Setup:
# This section is described in the OpenOCD documentation under CPU Configuration
#  http://openocd.org/doc/html/CPU-Configuration.html
###############################################################################

# Create the CPU target to be used with GDB:  Cortex-A8, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap

# The DM37x has 64K of SRAM starting at address 0x4020_0000.  Allow the first
# 16K to be used as a scratchpad for OpenOCD.

$_TARGETNAME configure -work-area-phys 0x40200000 -work-area-size 0x4000

######
# Start Target Reset Event Setup:
######

# Set the JTAG clock down to 10 kHz to be sure that it will work with the
#  slowest possible core clock (16.8MHz/2 = 8.4MHz). It is OK to speed up
#  *after* PLL and clock tree setup.

$_TARGETNAME configure -event "reset-start" { adapter speed 10 }

# Describe the reset assert process for openocd - this is asserted with the
# ICEPick
$_TARGETNAME configure -event "reset-assert" {

   global _CHIPNAME

   # assert warm system reset through ICEPick
   icepick_c_wreset $_CHIPNAME.jrc
}

# After the reset is asserted we need to re-initialize debugging and speed up
# the JTAG clock.

$_TARGETNAME configure -event reset-assert-post {

   global _TARGETNAME
   amdm37x_dbginit $_TARGETNAME
   adapter speed 1000
}

$_TARGETNAME configure -event gdb-attach {

   global _TARGETNAME
   amdm37x_dbginit $_TARGETNAME

   echo "Halting target"
   halt
}

######
# End Target Reset Event Setup:
######

###############################################################################
# Target Functions
# Add any functions needed for the target here
###############################################################################

# Run this to enable invasive debugging.  This is run automatically in the
# reset sequence.
proc amdm37x_dbginit {target} {
   # General Cortex-A8 debug initialisation
   cortex_a dbginit

   # Enable DBGEN signal.  This signal is described in the ARM v7 TRM, but
   # access to the signal appears to be implementation specific.  TI does not
   # describe this register much except a quick line that states DBGEM (sic) is
   # at this address and this bit.
   $target mww phys 0x5401d030 0x00002000
}
# Atheros AR71xx MIPS 24Kc SoC.
# tested on PB44 refererence board

adapter srst delay 100
jtag_ntrst_delay 100

reset_config trst_and_srst

set CHIPNAME ar71xx

jtag newtap $CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 1

set _TARGETNAME $CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-halt-post {
	#setup PLL to lowest common denominator 300/300/150 setting
	mww 0xb8050000 0x000f40a3	;# reset val + CPU:3 DDR:3 AHB:0
	mww 0xb8050000 0x800f40a3	;# send to PLL

	#next command will reset for PLL changes to take effect
	mww 0xb8050008 3		;# set reset_switch and clock_switch (resets SoC)
}

$_TARGETNAME configure -event reset-init {
	#complete pll initialization
	mww 0xb8050000 0x800f0080	;# set sw_update bit
	mww 0xb8050008 0		;# clear reset_switch bit
	mww 0xb8050000 0x800f00e8       ;# clr pwrdwn & bypass
	mww 0xb8050008 1		;# set clock_switch bit
	sleep 1                         ;# wait for lock

	# Setup DDR config and flash mapping
	mww 0xb8000000 0xefbc8cd0       ;# DDR cfg cdl val (rst: 0x5bfc8d0)
	mww 0xb8000004 0x8e7156a2       ;# DDR cfg2 cdl val (rst: 0x80d106a8)

	mww 0xb8000010 8		;# force precharge all banks
	mww 0xb8000010 1 		;# force EMRS update cycle
	mww 0xb800000c 0                ;# clr ext. mode register
	mww 0xb8000010 2 		;# force auto refresh all banks
	mww 0xb8000010 8		;# force precharge all banks
	mww 0xb8000008 0x31             ;# set DDR mode value CAS=3
	mww 0xb8000010 1 		;# force EMRS update cycle
	mww 0xb8000014 0x461b           ;# DDR refresh value
	mww 0xb8000018 0xffff           ;# DDR Read Data This Cycle value (16bit: 0xffff)
	mww 0xb800001c 0x7              ;# delay added to the DQS line (normal = 7)
	mww 0xb8000020 0
	mww 0xb8000024 0
	mww 0xb8000028 0
}

# setup working area somewhere in RAM
$_TARGETNAME configure -work-area-phys 0xa0600000 -work-area-size 0x20000

# serial SPI capable flash
# flash bank <driver> <base> <size> <chip_width> <bus_width>
#
# Configuration script for Arm CoreLink SSE-200 Subsystem based IoT SoCs.
#

global TARGET
set TARGET $_CHIPNAME

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

#
# SRAM on ARM CoreLink SSE-200 can be 4 banks of 8/16/32/64 KB
# We will configure work area assuming 8-KB bank size in SRAM bank 1.
# Also SRAM start addresses defaults to secure mode alias.
# These values can be overridden as per board configuration
#

global _WORKAREASIZE_CPU0
if { [info exists WORKAREASIZE_CPU0] } {
	set _WORKAREASIZE_CPU0 $WORKAREASIZE_CPU0
} else {
	set _WORKAREASIZE_CPU0 0x1000
}

global _WORKAREAADDR_CPU0
if { [info exists WORKAREAADDR_CPU0] } {
	set _WORKAREAADDR_CPU0 $WORKAREAADDR_CPU0
} else {
	set _WORKAREAADDR_CPU0 0x30008000
}

#
# Target configuration for Cortex M33 Core 0 on ARM CoreLink SSE-200
# Core 0 is the boot core and will always be configured.
#

target create ${TARGET}.CPU0 cortex_m -dap $_CHIPNAME.dap -ap-num 1 -coreid 0

${TARGET}.CPU0 configure -work-area-phys $_WORKAREAADDR_CPU0 -work-area-size $_WORKAREASIZE_CPU0 -work-area-backup 0

${TARGET}.CPU0 cortex_m reset_config sysresetreq

#
# Target configuration for Cortex M33 Core 1 on ARM CoreLink SSE-200
# Core 1 is optional and locked at boot until core 0 unlocks it.
#

if { $_ENABLE_CPU1 } {
	global _WORKAREASIZE_CPU1
	if { [info exists WORKAREASIZE_CPU1] } {
		set _WORKAREASIZE_CPU1 $WORKAREASIZE_CPU1
	} else {
		set _WORKAREASIZE_CPU1 0x1000
	}

	global _WORKAREAADDR_CPU1
	if { [info exists WORKAREAADDR_CPU1] } {
		set _WORKAREAADDR_CPU1 $WORKAREAADDR_CPU1
	} else {
		set _WORKAREAADDR_CPU1 0x30009000
	}

	target create ${TARGET}.CPU1 cortex_m -dap $_CHIPNAME.dap -ap-num 2 -coreid 1

	${TARGET}.CPU1 configure -work-area-phys $_WORKAREAADDR_CPU1 -work-area-size $_WORKAREASIZE_CPU1 -work-area-backup 0

	${TARGET}.CPU1 cortex_m reset_config vectreset
}

# Make sure the default target is the boot core
targets ${TARGET}.CPU0
#
# armada370 -- support for the Marvell Armada/370 CPU family
#
# gerg@uclinux.org, OCT-2013
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME armada370
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap

proc armada370_dbginit {target} {
     cortex_a dbginit
}

$_TARGETNAME configure -event reset-assert-post "armada370_dbginit $_TARGETNAME"

dap apsel 1
# Atmel AT32AP7000
#
# This is the only core in the now-inactive high end AVR32 product line,
# with MMU, Java Acceleration, and "pixel coprocessor".  The AP7 line
# is for "Application Processors" (AP) with 7-stage pipelines.
#
# Most current AVR32 parts are in the UC3 flash based microcontroller (UC)
# product line with 3-stage pipelines and without those extras.
#
# All AVR32 parts provide the Nexus Class 3 on-chip debug interfaces
# through their JTAG interfaces.

jtag newtap ap7 nexus -irlen 5 -expected-id 0x21e8203f

# REVISIT declare an avr32 target ... needs OpenOCD infrastructure
# for both Nexus (generic) and AVR32 (Atmel-specific).
# AT91R40008 target configuration file

# TRST is tied to SRST on the AT91X40 family.
reset_config srst_only srst_pulls_trst


if {[info exists CHIPNAME]} {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91r40008
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Setup the JTAG scan chain.
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1f0f0f0f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x20000 -work-area-size 0x20000 -work-area-backup 0
# Atmel AT91rm9200
# http://atmel.com/products/at91/

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91rm9200
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x05b0203f
}

# Never allow the following!
if { $_CPUTAPID == 0x15b0203f } {
   echo "-------------------------------------------------------"
   echo "- ERROR:                                              -"
   echo "- ERROR: TapID 0x15b0203f is wrong for at91rm9200     -"
   echo "- ERROR: The chip/board has a JTAG select pin/jumper  -"
   echo "- ERROR:                                              -"
   echo "- ERROR: In one position (0x05b0203f) it selects the  -"
   echo "- ERROR: ARM CPU, in the other position (0x1b0203f)   -"
   echo "- ERROR: it selects boundary-scan not the ARM         -"
   echo "- ERROR:                                              -"
   echo "-------------------------------------------------------"
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# Create the GDB Target.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME

# AT91RM9200 has a 16K block of sram @ 0x0020.0000
$_TARGETNAME configure -work-area-phys 0x00200000 \
		-work-area-size 0x4000 -work-area-backup 1

# This chip has a DCC ... use it
arm7_9 dcc_downloads enable
# script for ATMEL sam3, a Cortex-M3 chip
#
# at91sam3u4e
# at91sam3u2e
# at91sam3u1e
# at91sam3u4c
# at91sam3u2c
# at91sam3u1c
#
# at91sam3s4c
# at91sam3s4b
# at91sam3s4a
# at91sam3s2c
# at91sam3s2b
# at91sam3s2a
# at91sam3s1c
# at91sam3s1b
# at91sam3s1a
#
# at91sam3A4C
# at91sam3A8C
# at91sam3X4C
# at91sam3X4E
# at91sam3X8C
# at91sam3X8E
# at91sam3X8H

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME sam3
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# 16K is plenty, the smallest chip has this much
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

$_TARGETNAME configure -event gdb-flash-erase-start {
    halt
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 4 MHz, so use F_JTAG = 0.5MHz
#
# Since we may be running of an RC oscilator, we crank down the speed a
# bit more to be on the safe side. Perhaps superstition, but if are
# running off a crystal, we can run closer to the limit. Note
# that there can be a pretty wide band where things are more or less stable.

adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# common stuff
source [find target/at91sam3ax_xx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# This is a 256K chip - it has the 2nd bank
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam3 0x0000A0000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3ax_xx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# This is a 512K chip - it has the 2nd bank
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam3 0x0000C0000 0 1 1 $_TARGETNAME
# script for ATMEL sam3, a Cortex-M3 chip
#
# at91sam3A4C
# at91sam3A8C
# at91sam3X4C
# at91sam3X4E
# at91sam3X8C
# at91sam3X8E
# at91sam3X8H
source [find target/at91sam3XXX.cfg]

#
# Configuration for Atmel's SAM3N series
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME at91sam3n
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x4ba00477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap

set _FLASHNAME $_CHIPNAME.flash
flash bank flash0 at91sam3 0x00400000 0 0 0 $_TARGETNAME

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# script for ATMEL sam3, a Cortex-M3 chip
#
# at91sam3s4c
# at91sam3s4b
# at91sam3s4a
# at91sam3s2c
# at91sam3s2b
# at91sam3s2a
# at91sam3s1c
# at91sam3s1b
# at91sam3s1a

source [find target/at91sam3XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam3 0x00400000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# This is a 256K chip, it has the 2nd bank
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam3 0x000100000 0 1 1 $_TARGETNAME
# common stuff
source [find target/at91sam3uxx.cfg]

# size is automatically "calculated" by probing
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
# This is a 256K chip - it has the 2nd bank
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam3 0x000100000 0 1 1 $_TARGETNAME
# script for ATMEL sam3, a Cortex-M3 chip
#
# at91sam3u4e
# at91sam3u2e
# at91sam3u1e
# at91sam3u4c
# at91sam3u2c
# at91sam3u1c

source [find target/at91sam3XXX.cfg]
#
# script for ATMEL sam4, a Cortex-M4 chip
#

#
# sam4 devices can support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME sam4
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# 16K is plenty, the smallest chip has this much
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 4 MHz, so use F_JTAG = 0.5MHz
#
# Since we may be running of an RC oscilator, we crank down the speed a
# bit more to be on the safe side. Perhaps superstition, but if are
# running off a crystal, we can run closer to the limit. Note
# that there can be a pretty wide band where things are more or less stable.

adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# script for ATMEL sam4c32, a Cortex-M4 chip
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam4 0x01000000 0 1 1 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam4 0x01100000 0 1 1 $_TARGETNAME
# script for ATMEL sam4c, a Cortex-M4 chip
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4 0x01000000 0 1 1 $_TARGETNAME
# script for ATMEL sam4l, a Cortex-M4 chip
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4l 0x00000000 0 1 1 $_TARGETNAME

# SAM4L SMAP will hold the CPU in reset if TCK is low when RESET_N
# deasserts (see datasheet 42023E-SAM-07/2013 sec 8.11.3).
#
# smap_reset_deassert configures whether we want to run or halt out of reset,
# then instruct the SMAP to let us out of reset.
$_TARGETNAME configure -event reset-deassert-post "at91sam4l smap_reset_deassert"

# SRST (wired to RESET_N) resets debug circuitry
# srst_pulls_trst is not configured here to avoid an error raised in reset halt
reset_config srst_gates_jtag

# SAM4L starts from POR with SYSCLK set to 115kHz RCSYS, needs slow JTAG speed.
# Datasheet does not specify SYSCLK to JTAG/SWD clock ratio.
# Usually used SYSCLK/6 is hell slow, testing shows that debugging can work @ SYSCLK/2
# but your mileage may vary.
adapter speed 50

# System RC oscillator RCSYS starts in 3 cycles
adapter srst delay 0
# script for ATMEL sam4, a Cortex-M4 chip
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4 0x00400000 0 1 1 $_TARGETNAME
# script for ATMEL sam4sd32, a Cortex-M4 chip
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME at91sam4 0x00400000 0 1 1 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME at91sam4 0x00500000 0 1 1 $_TARGETNAME

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91sam7a2
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1f0f0f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
# ATMEL sam7se512
# Example: the "Elektor Internet Radio" - EIR
# http://www.ethernut.de/en/hardware/eir/index.html

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME sam7se512
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   # Force an error until we get a good number.
   set _CPUTAPID 0xffffffff
}

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config srst_only srst_pulls_trst

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# The target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config srst_only srst_pulls_trst

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91sam7s
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
$_TARGETNAME configure -event reset-init {
        soft_reset_halt
        # RSTC_CR : Reset peripherals
        mww 0xfffffd00 0xa5000004
        # disable watchdog
	mww 0xfffffd44 0x00008000
	# enable user reset
	mww 0xfffffd08 0xa5000001
	# CKGR_MOR : enable the main oscillator
	mww 0xfffffc20 0x00000601
	sleep 10
	# CKGR_PLLR: 96.1097 MHz
	mww 0xfffffc2c 0x00481c0e
	sleep 10
	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
	mww 0xfffffc30 0x00000007
	sleep 10
	# MC_FMR: flash mode (FWS=1,FMCN=73)
	mww 0xffffff60 0x00490100
	sleep 100
}

$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config srst_only srst_pulls_trst

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME sam7x256
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-init {
	# disable watchdog
	mww 0xfffffd44 0x00008000
	# enable user reset
	mww 0xfffffd08 0xa5000001
	# CKGR_MOR : enable the main oscillator
	mww 0xfffffc20 0x00000601
	sleep 10
	# CKGR_PLLR: 96.1097 MHz
	mww 0xfffffc2c 0x00481c0e
	sleep 10
	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
	mww 0xfffffc30 0x00000007
	sleep 10
	# MC_FMR: flash mode (FWS=1,FMCN=60)
	mww 0xffffff60 0x003c0100
	sleep 100
}

$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config srst_only srst_pulls_trst

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME sam7x512
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-init {
	# disable watchdog
	mww 0xfffffd44 0x00008000
	# enable user reset
	mww 0xfffffd08 0xa5000001
	# CKGR_MOR : enable the main oscillator
	mww 0xfffffc20 0x00000601
	sleep 10
	# CKGR_PLLR: 96.1097 MHz
	mww 0xfffffc2c 0x00481c0e
	sleep 10
	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
	mww 0xfffffc30 0x00000007
	sleep 10
	# MC_FMR: flash mode (FWS=1,FMCN=60)
	mww 0xffffff60 0x003c0100
	sleep 100
}

$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME.0 at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
flash bank $_FLASHNAME.1 at91sam7 0 0 0 0 $_TARGETNAME 1 0 0 0 0 0 0 18432
######################################
# Target:    Atmel AT91SAM9
######################################

if { [info exists AT91_CHIPNAME] } {
	set _CHIPNAME $AT91_CHIPNAME
} else {
	error "you must specify a chip name"
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x0792603f
}

reset_config trst_and_srst separate trst_push_pull srst_open_drain

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

adapter srst delay 300
jtag_ntrst_delay 200

adapter speed 3

######################
# Target configuration
######################

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
######################################
# Target:    Atmel AT91SAM9260
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9260
}

source [find target/at91sam9.cfg]


# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
# AT91SAM9260 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
# Both areas are 4 kB long.

#$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x1000 -work-area-backup 1
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9260
######################################

source [find target/at91sam9261.cfg]

reset_config trst_and_srst

adapter speed 4

adapter srst delay 200
jtag_ntrst_delay 200

scan_chain
$_TARGETNAME configure -event reset-start {
	# at reset chip runs at 32khz
	adapter speed 8
}

$_TARGETNAME configure -event reset-init {at91sam_init}

# Flash configuration
#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME

# Faster memory downloads. This is disabled automatically during
# reset init since all reset init sequences are too short for
# fast memory access
arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable

proc at91sam_init { } {
	mww 0xfffffd08 0xa5000501         ;# RSTC_MR : enable user reset
	mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog

	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
	sleep 20                          ;# wait 20 ms
	mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
	sleep 10                          ;# wait 10 ms
	mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198,656MHz
	sleep 20                          ;# wait 20 ms
	mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler
	sleep 10                          ;# wait 10 ms
	mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected
	sleep 10                          ;# wait 10 ms

	# Now run at anything fast... ie: 10mhz!
	adapter speed 10000               ;# Increase JTAG Speed to 6 MHz

	mww 0xffffec00 0x0a0a0a0a         ;# SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
	mww 0xffffec04 0x0b0b0b0b         ;# SMC_PULSE0
	mww 0xffffec08 0x00160016         ;# SMC_CYCLE0
	mww 0xffffec0c 0x00161003         ;# SMC_MODE0

	mww 0xfffff870 0xffff0000         ;# PIO_ASR : Select peripheral function for D15..D31
	mww 0xfffff804 0xffff0000         ;# PIO_PDR : Disable PIO function for D15..D31

	mww 0xffffef1c 0x2                ;# EBI_CSA : Assign EBI Chip Select 1 to SDRAM

	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
	#mww 0xffffea08 0x85227254         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S641632H-UC75 : 1M x 16Bit x 4 Banks)

	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
	mww 0x20000000 0
	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
	mww 0x20000000 0
	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x4
	mww 0x20000000 0
	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
	mww 0x20000000 0
	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
	mww 0x20000000 0
	mww 0xffffea04 0x5d2              ;# SDRAMC_TR : Set refresh timer count to 15us
}
######################################
# Target:    Atmel AT91SAM9261
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9261
}

source [find target/at91sam9.cfg]

# Internal sram1 memory
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x28000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9263
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9263
}

source [find target/at91sam9.cfg]

# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
# AT91SAM9263 has two SRAM areas,
# one starting at 0x00300000 of 80KiB
# and the other  starting at 0x00500000 of 16KiB.

# Internal sram1 memory
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x14000 -work-area-backup 1
#$_TARGETNAME configure -work-area-phys 0x00500000 -work-area-size 0x4000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9G10
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9g10
}

source [find target/at91sam9.cfg]

# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
# AT91SAM9G10 has one SRAM area at 0x00300000 of 16KiB

$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9G20
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9g20
}

source [find target/at91sam9.cfg]

# Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).

adapter speed 5

# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
# AT91SAM9G20 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
# Both areas are 16 kB long.

#$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 1
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9G45
######################################

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9g45
}

source [find target/at91sam9.cfg]

# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
# AT91SAM9G45 has one SRAM area starting at 0x00300000 of 64 KiB.

$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x200000 -work-area-backup 1
######################################
# Target:    Atmel AT91SAM9RL
######################################

if { [info exists CHIPNAME] } {
   set AT91_CHIPNAME $CHIPNAME
} else {
   set AT91_CHIPNAME at91sam9rl
}

source [find target/at91sam9.cfg]

# Internal sram1 memory
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x10000 -work-area-backup 1
#
# script for Atmel SAMD, SAMR, SAML or SAMC, a Cortex-M0 chip
#

#
# samdXX devices only support SWD transports.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91samd
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 2kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# SAMD DSU will hold the CPU in reset if TCK is low when RESET_N
# deasserts (see datasheet Atmel-42181ESAM-D21_Datasheet02/2015, section 12.6.2)
#
# dsu_reset_deassert configures whether we want to run or halt out of reset,
# then instruct the DSU to let us out of reset.
$_TARGETNAME configure -event reset-deassert-post {
        at91samd dsu_reset_deassert
}

# SRST (wired to RESET_N) resets debug circuitry
# srst_pulls_trst is not configured here to avoid an error raised in reset halt
reset_config srst_gates_jtag

# Do not use a reset button with other SWD adapter than Atmel's EDBG.
# DSU usually locks MCU in reset state until you issue a reset command
# in OpenOCD.

# SAMD runs at SYSCLK = 1 MHz divided from RC oscillator after reset.
# Other members of family usually use SYSCLK = 4 MHz after reset.
# Datasheet does not specify SYSCLK to SWD clock ratio.
# Usually used SYSCLK/6 is slow, testing shows that debugging can
# work @ SYSCLK/2 but your mileage may vary.
# This limit is most probably imposed by incorrectly handled SWD WAIT
# on some SWD adapters.

adapter speed 400

# Atmel's EDBG (on-board cmsis-dap adapter of Xplained kits) works
# without problem at maximal clock speed. Atmel recommends
# adapter speed less than 10 * CPU clock.
# adapter speed 5000

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91samd 0x00000000 0 1 1 $_TARGETNAME
# script for the ATMEL samg5x Cortex-M4F chip family
#

source [find target/at91sam4XXX.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4 0x00400000 0 1 1 $_TARGETNAME
if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME ar2313
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x00000001
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME
if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME ar2315
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x00000001
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME
# The Atheros AR9331 is a highly integrated and cost effective
# IEEE 802.11n 1x1 2.4 GHz System- on-a-Chip (SoC) for wireless
# local area network (WLAN) AP and router platforms.
#
# Notes:
# - MIPS Processor ID (PRId): 0x00019374
# - 24Kc MIPS processor with 64 KB I-Cache and 32 KB D-Cache,
#   operating at up to 400 MHz
# - External 16-bit DDR1, DDR2, or SDRAM memory interface
# - TRST is not available.
# - EJTAG PrRst signal is not supported
# - RESET_L pin A72 on the SoC will reset internal JTAG logic.
#

# Pins related for debug and bootstrap:
# Name		Pin		Description
#   JTAG
# JTAG_TCK	GPIO0, (A27)	Software configurable, default JTAG
# JTAG_TDI	GPIO6, (B46)	Software configurable, default JTAG
# JTAG_TDO	GPIO7, (A54)	Software configurable, default JTAG
# JTAG_TMS	GPIO8, (A52)	Software configurable, default JTAG
#   Reset
# RESET_L	-, (A72)	Input only
# SYS_RST_L	????????	Output reset request or GPIO
#   Bootstrap
# MEM_TYPE[1]	GPIO28, (A74)	0 - SDRAM, 1 - DDR1 RAM, 2 - DDR2 RAM
# MEM_TYPE[0]	GPIO12, (A56)
# FW_DOWNLOAD	GPIO16, (A75)	Used if BOOT_FROM_SPI = 0. 0 - boot from USB
#                               1 - boot from MDIO.
# JTAG_MODE(JS)	GPIO11, (B48)	0 - JTAG (Default); 1 - EJTAG
# BOOT_FROM_SPI	GPIO1, (A77)	0 - ROM boot; 1 - SPI boot
# SEL_25M_40M	GPIO0, (A78)	0 - 25MHz; 1 - 40MHz
#   UART
# UART0_SOUT	GPIO10, (A79)
# UART0_SIN	GPIO9, (B68)

# Per default we need to use "none" variant to be able properly "reset init"
# or "reset halt" the CPU.
reset_config none srst_pulls_trst

# For SRST based variant we still need proper timings.
# For ETH part the reset should be asserted at least for 10ms
# Since there is no other information let's take 100ms to be sure.
adapter srst pulse_width 100

# according to the SoC documentation it should take at least 5ms from
# reset end till bootstrap end. In the practice we need 8ms to get JTAG back
# to live.
adapter srst delay 8

if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME ar9331
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x00000001

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

# provide watchdog helper.
proc disable_watchdog { } {
	mww 0xb8060008 0x0
}

$_TARGETNAME configure -event halted { disable_watchdog }

# Since PrRst is not supported and SRST will reset complete chip
# with JTAG engine, we need to reset CPU from CPU itself.
$_TARGETNAME configure -event reset-assert-pre {
	halt
}

$_TARGETNAME configure -event reset-assert {
	catch "mww 0xb806001C 0x01000000"
}

# To be able to trigger complete chip reset, in case JTAG is blocked
# or CPU not responding, we still can use this helper.
proc full_reset { } {
	reset_config srst_only
	reset
	halt
	reset_config none
}

proc disable_watchdog { } {
	;# disable watchdog
	mww 0xb8060008 0x0
}

$_TARGETNAME configure -event reset-end { disable_watchdog }

# Section with helpers which can be used by boards
proc ar9331_25mhz_pll_init {} {
	mww 0xb8050008 0x00018004	;# bypass PLL; AHB_POST_DIV - ratio 4
	mww 0xb8050004 0x00000352	;# 34000(ns)/40ns(25MHz) = 0x352 (850)
	mww 0xb8050000 0x40818000	;# Power down control for CPU PLL
					;# OUTDIV | REFDIV | DIV_INT
	mww 0xb8050010 0x001003e8	;# CPU PLL Dither FRAC Register
					;# (disabled?)
	mww 0xb8050000 0x00818000	;# Power on | OUTDIV | REFDIV | DIV_INT
	mww 0xb8050008 0x00008000	;# remove bypass;
					;# AHB_POST_DIV - ratio 2
}

proc ar9331_ddr1_init {} {
	mww 0xb8000000 0x7fbc8cd0       ;# DDR_CONFIG - lots of DRAM confs
	mww 0xb8000004 0x9dd0e6a8	;# DDR_CONFIG2 - more DRAM confs

	mww 0xb8000010 0x8	;# Forces a PRECHARGE ALL cycle
	mww 0xb8000008 0x133	;# mode reg: 0x133 - default
	mww 0xb8000010 0x1	;# Forces an MRS update cycl
	mww 0xb800000c 0x2	;# Extended mode register value.
				;# default 0x2 - Reset to weak driver, DLL on
	mww 0xb8000010 0x2	;# Forces an EMRS update cycle
	mww 0xb8000010 0x8	;# Forces a PRECHARGE ALL cycle
	mww 0xb8000008 0x33	;# mode reg: remove some bit?
	mww 0xb8000010 0x1	;# Forces an MRS update cycl
	mww 0xb8000014 0x4186	;# enable refres: bit(14) - set refresh rate
	mww 0xb800001c 0x8	;# This register is used along with DQ Lane 0,
				;# DQ[7:0], DQS_0
	mww 0xb8000020 0x9	;# This register is used along with DQ Lane 1,
				;# DQ[15:8], DQS_1.
	mww 0xb8000018 0xff	;# DDR read and capture bit mask.
				;# Each bit represents a cycle of valid data.
}

proc ar9331_ddr2_init {} {
	mww 0xb8000000 0x7fbc8cd0	;# DDR_CONFIG - lots of DRAM confs
	mww 0xb8000004 0x9dd0e6a8	;# DDR_CONFIG2 - more DRAM confs

	mww 0xb800008c 0x00000a59
	mww 0xb8000010 0x00000008	;# PRECHARGE ALL cycle

	mww 0xb8000090 0x00000000
	mww 0xb8000010 0x00000010	;# EMR2S update cycle

	mww 0xb8000094 0x00000000
	mww 0xb8000010 0x00000020	;# EMR3S update cycle

	mww 0xb800000c 0x00000000
	mww 0xb8000010 0x00000002	;# EMRS update cycle

	mww 0xb8000008 0x00000100
	mww 0xb8000010 0x00000001	;# MRS update cycle

	mww 0xb8000010 0x00000008	;# PRECHARGE ALL cycle

	mww 0xb8000010 0x00000004
	mww 0xb8000010 0x00000004	;# AUTO REFRESH cycle

	mww 0xb8000008 0x00000a33
	mww 0xb8000010 0x00000001	;# MRS update cycle

	mww 0xb800000c 0x00000382
	mww 0xb8000010 0x00000002	;# EMRS update cycle

	mww 0xb800000c 0x00000402
	mww 0xb8000010 0x00000002	;# EMRS update cycle

	mww 0xb8000014 0x00004186	;# DDR_REFRESH
	mww 0xb800001c 0x00000008	;# DDR_TAP_CTRL0
	mww 0xb8000020 0x00000009	;# DDR_TAP_CTRL1

	;# DDR read and capture bit mask.
	;# Each bit represents a cycle of valid data.
	;# 0xff: use 16-bit DDR
	mww 0xb8000018 0x000000ff
}
if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME ar9344
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x00000001
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

proc test_ar9344_uart0_tx {} {
	echo "configuring uart0.."
	mww 0xb802000c 0x87
	mww 0xb8020000 0x15
	mww 0xb8020004 0
	mww 0xb802000c 7
	mww 0xb8020004 0

	echo "send message: hallo world"
	mww 0xb8020000 0x68
	mww 0xb8020000 0x65
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x6f
	mww 0xb8020000 0x20
	mww 0xb8020000 0x77
	mww 0xb8020000 0x6f
	mww 0xb8020000 0x72
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x64
	mww 0xb8020000 0x0a
}
# for avr

   set _CHIPNAME avr
   set _ENDIAN little

# jtag speed
adapter speed 4500

reset_config srst_only
adapter srst delay 100

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x8970203F
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME avr -endian $_ENDIAN -chain-position $_TARGETNAME

#$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 16384 -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME

#to use it, script will be like:
#init
#adapter speed 4500
#reset init
#verify_ircapture disable
#
#halt
#wait halt
#poll
#avr mass_erase 0
#flash write_image E:/Versaloon/Software/CAMERAPROTOCOLAGENT.hex
#reset run
#shutdown
set _CHIPNAME avr
set _ENDIAN little

# jtag speed
adapter speed 4500

# avr jtag docs never connect RSTN
reset_config none

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0a70103f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME avr -endian $_ENDIAN -chain-position $_TARGETNAME

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME
#
# Microchip (former Atmel) SAM E54, E53, E51 and D51 devices
# with a Cortex-M4 core
#

#
# Devices only support SWD transports.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME atsame5
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 32kB (the smallest RAM size is 128kB)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x8000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# SAM DSU will hold the CPU in reset if TCK is low when RESET_N
# deasserts
#
# dsu_reset_deassert configures whether we want to run or halt out of reset,
# then instruct the DSU to let us out of reset.
$_TARGETNAME configure -event reset-deassert-post {
        atsame5 dsu_reset_deassert
}

# SRST (wired to RESET_N) resets debug circuitry
# srst_pulls_trst is not configured here to avoid an error raised in reset halt
reset_config srst_gates_jtag

# Do not use a reset button with other SWD adapter than Atmel's EDBG.
# DSU usually locks MCU in reset state until you issue a reset command
# in OpenOCD.

# SAM E5x/D51 runs at SYSCLK = 48 MHz from RC oscillator after reset.
# Atmel's EDBG (on-board cmsis-dap adapter of Xplained kits) works
# without problem at clock speed over 5000 khz. Atmel recommends
# adapter speed less than 10 * CPU clock.
adapter speed 2000

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME atsame5 0x00000000 0 1 1 $_TARGETNAME
#
# Microchip (formerly Atmel) SAM L1x target
#
# Note: These devices support SWD only.
#

transport select swd

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME saml1x
}

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}

swd newdap $_CHIPNAME cpu -expected-id 0x0bf11477
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

if {![using_hla]} {
    cortex_m reset_config sysresetreq
}
# ATMEL SAMV, SAMS, and SAME chips are Cortex-M7 parts
# The chips are very similar; the SAMV series just has
# more peripherals and seems like the "flagship" of the
# family. This script will work for all of them.

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME samv
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 16kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bd11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20400000 -work-area-size $_WORKAREASIZE -work-area-backup 0

adapter speed 1800

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq

   # Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
   # HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
   # makes the data access cacheable. This allows reading and writing data in the
   # CPU cache from the debugger, which is far more useful than going straight to
   # RAM when operating on typical variables, and is generally no worse when
   # operating on special memory locations.
   $_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME atsamv 0x00400000 0 0 0 $_TARGETNAME
set _CHIPNAME avr32
set _ENDIAN big

set _CPUTAPID 0x21e8203f

adapter srst delay 100
jtag_ntrst_delay 100

reset_config trst_and_srst separate

# jtag scan chain
# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_CPUTAPID

set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
target create $_TARGETNAME avr32_ap7k -endian $_ENDIAN -chain-position $_TARGETNAME
# BCM281xx

if { [info exists CHIPNAME] } {
	set  _CHIPNAME $CHIPNAME
} else {
	set  _CHIPNAME bcm281xx
}


# Main CPU DAP
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -expected-id $_DAP_TAPID -irlen 4


# Dual Cortex-A9
set _TARGETNAME0 $_CHIPNAME.cpu0
set _TARGETNAME1 $_CHIPNAME.cpu1

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME0 cortex_a -dap $_CHIPNAME.dap -coreid 0 -dbgbase 0x3fe10000
target create $_TARGETNAME1 cortex_a -dap $_CHIPNAME.dap -coreid 1 -dbgbase 0x3fe12000
target smp $_TARGETNAME0 $_TARGETNAME1
set _CHIPNAME bcm4706
set _CPUID 0x1008c17f

jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian little -chain-position $_TARGETNAME
set _CHIPNAME bcm4718
set _LVTAPID 0x1471617f
set _CPUID 0x0008c17f

source [find target/bcm47xx.cfg]
echo "Forcing reset_config to none to prevent OpenOCD from pulling SRST after the switch from LV is already performed"
reset_config none

jtag newtap $_CHIPNAME-lv tap -irlen 32 -ircapture 0x1 -irmask 0x1f -expected-id $_LVTAPID -expected-id $_CPUID
jtag configure $_CHIPNAME-lv.tap -event setup "jtag tapenable $_CHIPNAME.cpu"
jtag configure $_CHIPNAME-lv.tap -event tap-disable {}

jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "switch_lv_to_ejtag"

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian little -chain-position $_TARGETNAME

proc switch_lv_to_ejtag {} {
    global _CHIPNAME
    poll 0
    irscan $_CHIPNAME-lv.tap 0x143ff3a
    drscan $_CHIPNAME-lv.tap 32 1
    jtag tapdisable $_CHIPNAME-lv.tap
    poll 1
}
set _CHIPNAME bcm5352e
set _CPUID 0x0535217f

jtag newtap $_CHIPNAME cpu -irlen 8 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian little -chain-position $_TARGETNAME
set _CHIPNAME bcm6348
set _CPUID 0x0634817f

adapter speed 1000

jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME
# BlueField SoC Target

set _CHIPNAME bluefield

# Specify the target device
#rshim device /dev/rshim0/rshim

# Main DAP
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x4ba00477
}

adapter speed 1500

swd newdap $_CHIPNAME cpu -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Initialize the target name and command variable.
set _TARGETNAME $_CHIPNAME.cpu
set _smp_command ""

# CTI relative address
set $_TARGETNAME.cti(0) 0xC4020000
set $_TARGETNAME.cti(1) 0xC4120000
set $_TARGETNAME.cti(2) 0xC8020000
set $_TARGETNAME.cti(3) 0xC8120000
set $_TARGETNAME.cti(4) 0xCC020000
set $_TARGETNAME.cti(5) 0xCC120000
set $_TARGETNAME.cti(6) 0xD0020000
set $_TARGETNAME.cti(7) 0xD0120000
set $_TARGETNAME.cti(8) 0xD4020000
set $_TARGETNAME.cti(9) 0xD4120000
set $_TARGETNAME.cti(10) 0xD8020000
set $_TARGETNAME.cti(11) 0xD8120000
set $_TARGETNAME.cti(12) 0xDC020000
set $_TARGETNAME.cti(13) 0xDC120000
set $_TARGETNAME.cti(14) 0xE0020000
set $_TARGETNAME.cti(15) 0xE0120000

# Create debug targets for a number of cores starting from core '_core_start'.
# Adjust the numbers according to board configuration.
set _core_start 0
set _cores 16

# Create each core
for { set _core $_core_start } { $_core < $_core_start + $_cores } { incr _core 1 } {
    cti create cti$_core -dap $_CHIPNAME.dap -baseaddr [set $_TARGETNAME.cti($_core)] -ap-num 0

    set _command "target create ${_TARGETNAME}$_core aarch64 \
                         -dap $_CHIPNAME.dap -coreid $_core -cti cti$_core"

    if { $_core != $_core_start } {
        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
    } else {
        set _smp_command "target smp ${_TARGETNAME}$_core"
    }

    eval $_command
}

# Configure SMP
if { $_cores > 1 } {
    eval $_smp_command
}

# Make sure the default target is the boot core
targets ${_TARGETNAME}0

proc core_up { args } {
	global _TARGETNAME

	# Examine remaining cores
	foreach _core [set args] {
		${_TARGETNAME}$_core arp_examine
	}
}
#
# bluenrg-1/2 and bluenrg-lp devices support only SWD transports.
#

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME bluenrg-1
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 24kB-256bytes
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x5F00
}

adapter speed 4000

swj_newdap $_CHIPNAME cpu -expected-id 0x0bb11477 -expected-id 0x0bc11477
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
set WDOG_VALUE 0
set WDOG_VALUE_SET 0

target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000100 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME bluenrg-x 0 0 0 0 $_TARGETNAME

# In BlueNRG-X reset pin is actually a shutdown (power-off), so define reset as none
reset_config none

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event halted {
    global WDOG_VALUE
    global WDOG_VALUE_SET
    set _JTAG_IDCODE [mrw 0x40000004]
    if {$_JTAG_IDCODE != 0x0201E041} {
        # Stop watchdog during halt, if enabled. Only Bluenrg-1/2
        set WDOG_VALUE [mrw 0x40700008]
        if [expr ($WDOG_VALUE & (1 << 1))] {
            set WDOG_VALUE_SET 1
            mww 0x40700008 [expr ($WDOG_VALUE & 0xFFFFFFFD)]
        }
    }
}
$_TARGETNAME configure -event resumed {
    global WDOG_VALUE
    global WDOG_VALUE_SET
    set _JTAG_IDCODE [mrw 0x40000004]
    if {$_JTAG_IDCODE != 0x0201E041} {
        if [expr $WDOG_VALUE_SET] {
            # Restore watchdog enable value after resume. Only Bluenrg-1/2
            mww 0x40700008 $WDOG_VALUE
            set WDOG_VALUE_SET 0
           }
   }
}
# c100 config.
# This is ARM1136 dual core
# this script only configures one core (that is used to run Linux)

# assume no PLL lock, start slowly
adapter speed 100

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME c100
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x27b3645b
}

if { [info exists DSPTAPID] } {
   set _DSPTAPID $DSPTAPID
} else {
   set _DSPTAPID 0x27b3645b
}

jtag newtap $_CHIPNAME dsp -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_DSPTAPID


# Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME

# C100's ARAM 64k SRAM
$_TARGETNAME configure -work-area-phys 0x0a000000 -work-area-size 0x10000 -work-area-backup 0

# board(-config) specific parameters file.

# set CFG_REFCLKFREQ [configC100 CFG_REFCLKFREQ]
proc config {label} {
    return [dict get [configC100] $label ]
}

# show the value for the param. with label
proc showconfig {label} {
    echo [format "0x%x" [dict get [configC100] $label ]]
}

# Telo board config
# when there are more then one board config
# use soft links to c100board-config.tcl
# so that only the right board-config gets
# included (just like include/configs/board-configs.h
# in u-boot.
proc configC100 {} {
    # xtal freq. 24MHz
    dict set configC100 CFG_REFCLKFREQ	         24000000

    # Amba Clk 165MHz
    dict set configC100 CONFIG_SYS_HZ_CLOCK      165000000
    dict set configC100 w_amba 1
    dict set configC100 x_amba 1
    # y = amba_clk * (w+1)*(x+1)*2/xtal_clk
    dict set configC100 y_amba [expr ([dict get $configC100 CONFIG_SYS_HZ_CLOCK] * ( ([dict get $configC100 w_amba]+1 ) * ([dict get $configC100 x_amba]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]

    # Arm Clk 450MHz, must be a multiple of 25 MHz
    dict set configC100 CFG_ARM_CLOCK      450000000
    dict set configC100 w_arm 0
    dict set configC100 x_arm 1
    # y = arm_clk * (w+1)*(x+1)*2/xtal_clk
    dict set configC100 y_arm [expr ([dict get $configC100 CFG_ARM_CLOCK] * ( ([dict get $configC100 w_arm]+1 ) * ([dict get $configC100 x_arm]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]


}

# This should be called for reset init event handler
proc setupTelo {} {

    # setup GPIO used as control signals for C100
    setupGPIO
    # This will allow acces to lower 8MB or NOR
    lowGPIO5
    # setup NOR size,timing,etc.
    setupNOR
    # setup internals + PLL + DDR2
    initC100
}


proc setupNOR {} {
    echo "Setting up NOR: 16MB, 16-bit wide bus, CS0"
    # this is taken from u-boot/boards/mindspeed/ooma-darwin/board.c:nor_hw_init()
    set EX_CSEN_REG	    [regs EX_CSEN_REG ]
    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]
    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]
    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]
    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]
    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]
    set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
    set EX_MFSM_REG	    [regs EX_MFSM_REG ]
    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]
    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]
    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]

    # enable Expansion Bus Clock + CS0 (NOR)
    mww $EX_CSEN_REG 0x3
    # set the address space for CS0=16MB
    mww $EX_CS0_SEG_REG 0x7ff
    # set the CS0 bus width to 16-bit
    mww $EX_CS0_CFG_REG 0x202
    # set timings to NOR
    mww $EX_CS0_TMG1_REG 0x03034006
    mww $EX_CS0_TMG2_REG 0x04040002
    #mww $EX_CS0_TMG3_REG
    # set EBUS clock 165/5=33MHz
    mww $EX_CLOCK_DIV_REG 0x5
    # everthing else is OK with default
}

proc bootNOR {} {
    set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
    set BLOCK_RESET_REG	       [regs BLOCK_RESET_REG]
    set DDR_RST		       [regs DDR_RST]

    # put DDR controller in reset (so that it comes reset in u-boot)
    mmw $BLOCK_RESET_REG 0x0 $DDR_RST
    # setup CS0 controller for NOR
    setupNOR
    # make sure we are accessing the lower part of NOR
    lowGPIO5
    # set PC to start of NOR (at boot 0x20000000 = 0x0)
    reg pc $EXP_CS0_BASEADDR
    # run
    resume
}
proc setupGPIO {} {
    echo "Setting up GPIO block for Telo"
    # This is current setup for Telo (see sch. for details):
    #GPIO0 reset for FXS-FXO IC, leave as input, the IC has internal pullup
    #GPIO1 irq line for FXS-FXO
    #GPIO5 addr22 for NOR flash (access to upper 8MB)
    #GPIO17 reset for DECT module.
    #GPIO29 CS_n for NAND

    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
    set GPIO_OE_REG		    [regs GPIO_OE_REG]

    # set GPIO29=GPIO17=1, GPIO5=0
    mww $GPIO_OUTPUT_REG [expr 1<<29 | 1<<17]
    # enable [as output] GPIO29,GPIO17,GPIO5
    mww $GPIO_OE_REG [expr  1<<29 | 1<<17 | 1<<5]
}

proc highGPIO5 {} {
    echo "GPIO5 high"
    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
    # set GPIO5=1
    mmw $GPIO_OUTPUT_REG [expr 1 << 5] 0x0
}

proc lowGPIO5 {} {
    echo "GPIO5 low"
    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
    # set GPIO5=0
    mmw $GPIO_OUTPUT_REG 0x0 [expr 1 << 5]
}

proc boardID {id} {
    # so far built:
    # 4'b1111
    dict set boardID 15 name "EVT1"
    dict set boardID 15 ddr2size 128M
    # dict set boardID 15 nandsize 1G
    # dict set boardID 15 norsize 16M
    # 4'b0000
    dict set boardID 0 name "EVT2"
    dict set boardID 0 ddr2size 128M
    # 4'b0001
    dict set boardID 1 name "EVT3"
    dict set boardID 1 ddr2size 256M
    # 4'b1110
    dict set boardID 14 name "EVT3_old"
    dict set boardID 14 ddr2size 128M
    # 4'b0010
    dict set boardID 2 name "EVT4"
    dict set boardID 2 ddr2size 256M

    return $boardID
}


# converted from u-boot/boards/mindspeed/ooma-darwin/board.c:ooma_board_detect()
# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors
proc ooma_board_detect {} {
    set GPIO_BOOTSTRAP_REG	[regs GPIO_BOOTSTRAP_REG]

    # read the current value of the BOOTSRAP pins
    set tmp [mrw $GPIO_BOOTSTRAP_REG]
    echo [format "GPIO_BOOTSTRAP_REG  (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG $tmp]
    # extract the GPBP bits
    set gpbt [expr ($tmp &0x1C00) >> 10 | ($tmp & 0x40) >>3]

    # display board ID
    echo [format "This is %s (0x%x)" [dict get [boardID $gpbt] $gpbt name] $gpbt]
    # show it on serial console
    putsUART0 [format "This is %s (0x%x)\n" [dict get [boardID $gpbt] $gpbt name] $gpbt]
    # return the ddr2 size, used to configure DDR2 on a given board.
    return [dict get [boardID $gpbt] $gpbt ddr2size]
}

proc configureDDR2regs_256M {} {

    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]

    set DENALI_CTL_02_VAL 0x0100000000010100
    set DENALI_CTL_11_VAL 0x433a32164a560a00

    mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
    # 01_DATA mod [40]=1, enable BA2
    mw64bit $DENALI_CTL_01_DATA  0x0100010100000001
    mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
    mw64bit $DENALI_CTL_03_DATA  0x0102020202020201
    mw64bit $DENALI_CTL_04_DATA  0x0000010100000001
    mw64bit $DENALI_CTL_05_DATA  0x0203010300010101
    mw64bit $DENALI_CTL_06_DATA  0x060a020200020202
    mw64bit $DENALI_CTL_07_DATA  0x0000000300000206
    mw64bit $DENALI_CTL_08_DATA  0x6400003f3f0a0209
    mw64bit $DENALI_CTL_09_DATA  0x1a000000001a1a1a
    mw64bit $DENALI_CTL_10_DATA  0x0120202020191a18
    # 11_DATA mod [39-32]=16,more refresh
    mw64bit $DENALI_CTL_11_DATA  $DENALI_CTL_11_VAL
    mw64bit $DENALI_CTL_12_DATA  0x0000000000000800
    mw64bit $DENALI_CTL_13_DATA  0x0010002000100040
    mw64bit $DENALI_CTL_14_DATA  0x0010004000100040
    mw64bit $DENALI_CTL_15_DATA  0x04f8000000000000
    mw64bit $DENALI_CTL_16_DATA  0x000000002cca0000
    mw64bit $DENALI_CTL_17_DATA  0x0000000000000000
    mw64bit $DENALI_CTL_18_DATA  0x0302000000000000
    mw64bit $DENALI_CTL_19_DATA  0x00001300c8030600
    mw64bit $DENALI_CTL_20_DATA  0x0000000081fe00c8

    set wr_dqs_shift 0x40
    # start DDRC
    mw64bit $DENALI_CTL_02_DATA [expr $DENALI_CTL_02_VAL | (1 << 32)]
    # wait int_status[2] (DRAM init complete)
    echo -n "Waiting for DDR2 controller to init..."
    set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
    while { [expr $tmp & 0x040000] == 0 } {
	sleep 1
	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
    }
    echo "done."

    # do ddr2 training sequence
    # TBD (for now, if you need it, run trainDDR command)
}

# converted from u-boot/cpu/arm1136/comcerto/bsp100.c:config_board99()
# The values are computed based on Mindspeed and Nanya datasheets
proc configureDDR2regs_128M {} {

    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]


    set DENALI_CTL_02_VAL 0x0100010000010100
    set DENALI_CTL_11_VAL 0x433A42124A650A37
    # set some default values
    mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
    mw64bit $DENALI_CTL_01_DATA  0x0100000100000101
    mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
    mw64bit $DENALI_CTL_03_DATA  0x0102020202020201
    mw64bit $DENALI_CTL_04_DATA  0x0201010100000201
    mw64bit $DENALI_CTL_05_DATA  0x0203010300010101
    mw64bit $DENALI_CTL_06_DATA  0x050A020200020202
    mw64bit $DENALI_CTL_07_DATA  0x000000030E0B0205
    mw64bit $DENALI_CTL_08_DATA  0x6427003F3F0A0209
    mw64bit $DENALI_CTL_09_DATA  0x1A00002F00001A00
    mw64bit $DENALI_CTL_10_DATA  0x01202020201A1A1A
    mw64bit $DENALI_CTL_11_DATA  $DENALI_CTL_11_VAL
    mw64bit $DENALI_CTL_12_DATA  0x0000080000000800
    mw64bit $DENALI_CTL_13_DATA  0x0010002000100040
    mw64bit $DENALI_CTL_14_DATA  0x0010004000100040
    mw64bit $DENALI_CTL_15_DATA  0x0508000000000000
    mw64bit $DENALI_CTL_16_DATA  0x000020472D200000
    mw64bit $DENALI_CTL_17_DATA  0x0000000008000000
    mw64bit $DENALI_CTL_18_DATA  0x0302000000000000
    mw64bit $DENALI_CTL_19_DATA  0x00001400C8030604
    mw64bit $DENALI_CTL_20_DATA  0x00000000823600C8

    set wr_dqs_shift 0x40
    # start DDRC
    mw64bit $DENALI_CTL_02_DATA [expr $DENALI_CTL_02_VAL | (1 << 32)]
    # wait int_status[2] (DRAM init complete)
    echo -n "Waiting for DDR2 controller to init..."
    set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
    while { [expr $tmp & 0x040000] == 0 } {
	sleep 1
	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
    }
    # This is not necessary
    #mw64bit $DENALI_CTL_11_DATA [expr ($DENALI_CTL_11_VAL  & ~0x00007F0000000000) | ($wr_dqs_shift << 40) ]
    echo "done."

    # do ddr2 training sequence
    # TBD (for now, if you need it, run trainDDR command)
}



proc setupUART0 {} {
    # configure UART0 to 115200, 8N1
    set GPIO_LOCK_REG      [regs GPIO_LOCK_REG]
    set GPIO_IOCTRL_REG    [regs GPIO_IOCTRL_REG]
    set GPIO_IOCTRL_VAL    [regs GPIO_IOCTRL_VAL]
    set GPIO_IOCTRL_UART0  [regs GPIO_IOCTRL_UART0]
    set UART0_LCR	            [regs UART0_LCR]
    set LCR_DLAB		    [regs LCR_DLAB]
    set UART0_DLL		    [regs UART0_DLL]
    set UART0_DLH		    [regs UART0_DLH]
    set UART0_IIR		    [regs UART0_IIR]
    set UART0_IER		    [regs UART0_IER]
    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]
    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]
    set FCR_XMITRES		    [regs FCR_XMITRES]
    set FCR_RCVRRES		    [regs FCR_RCVRRES]
    set FCR_FIFOEN		    [regs FCR_FIFOEN]
    set IER_UUE			    [regs IER_UUE]

    # unlock writing to IOCTRL register
    mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
    # enable UART0
    mmw $GPIO_IOCTRL_REG $GPIO_IOCTRL_UART0 0x0
    # baudrate  115200
    # This should really be amba_clk/(16*115200) but amba_clk=165MHz
    set tmp 89
    # Enable Divisor Latch access
    mmw  $UART0_LCR $LCR_DLAB 0x0
    # set the divisor to $tmp
    mww $UART0_DLL [expr $tmp & 0xff]
    mww $UART0_DLH [expr $tmp >> 8]
    # Disable Divisor Latch access
    mmw  $UART0_LCR 0x0 $LCR_DLAB
    # set the UART to 8N1
    mmw  $UART0_LCR [expr $LCR_ONE_STOP | $LCR_CHAR_LEN_8 ] 0x0
    # reset FIFO
    mmw  $UART0_IIR [expr $FCR_XMITRES  | $FCR_RCVRRES | $FCR_FIFOEN ] 0x0
    #  enable FFUART
    mww $UART0_IER $IER_UUE
}

proc putcUART0 {char} {

    set UART0_LSR	    [regs UART0_LSR]
    set UART0_THR	    [regs UART0_THR]
    set LSR_TEMT	    [regs LSR_TEMT]

    # convert the 'char' to digit
    set tmp [ scan $char %c ]
    # /* wait for room in the tx FIFO on FFUART */
    while {[expr [mrw $UART0_LSR] & $LSR_TEMT] == 0} { sleep 1 }
    mww $UART0_THR $tmp
    if { $char == "\n" } { putcUART0 \r }
}

proc putsUART0 {str} {
    set index 0
    set len [string length $str]
    while { $index < $len } {
	putcUART0 [string index $str $index]
	set index [expr $index + 1]
    }
}


proc trainDDR2 {} {
    set ARAM_BASEADDR	[regs ARAM_BASEADDR]

    # you must have run 'reset init' or u-boot
    # load the training code to ARAM
    load_image ./images/ddr2train.bin $ARAM_BASEADDR bin
    # set PC to start of NOR (at boot 0x20000000 = 0x0)
    reg pc $ARAM_BASEADDR
    # run
    resume
}

proc flashUBOOT {file} {
    # this will update uboot on NOR partition
    set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]

    # setup CS0 controller for NOR
    setupNOR
    # make sure we are accessing the lower part of NOR
    lowGPIO5
    flash probe 0
    echo "Erasing sectors 0-3 for uboot"
    putsUART0 "Erasing sectors 0-3 for uboot\n"
    flash erase_sector 0 0 3
    echo "Programming u-boot"
    putsUART0 "Programming u-boot..."
    arm11 memwrite burst enable
    flash write_image $file $EXP_CS0_BASEADDR
    arm11 memwrite burst disable
    putsUART0 "done.\n"
    putsUART0 "Rebooting, please wait!\n"
    reboot
}

proc helpC100 {} {
    echo "List of useful functions for C100 processor:"
    echo "1)  reset init:        will set up your Telo board"
    echo "2)  setupNOR:          will setup NOR access"
    echo "3)  showNOR:           will show current NOR config registers for 16-bit, 16MB NOR"
    echo "4)  setupGPIO:         will setup GPIOs for Telo board"
    echo "5)  showGPIO:          will show current GPIO config registers"
    echo "6)  highGPIO5:         will set GPIO5=NOR_addr22=1 to access upper 8MB"
    echo "7)  lowGPIO5:          will set GPIO5=NOR_addr22=0 to access lower 8MB"
    echo "8)  showAmbaClk:       will show current config registers for Amba Bus Clock"
    echo "9)  setupAmbaClk:      will setup Amba Bus Clock=165MHz"
    echo "10) showArmClk:        will show current config registers for Arm Bus Clock"
    echo "11) setupArmClk:       will setup Amba Bus Clock=450MHz"
    echo "12) ooma_board_detect: will show which version of Telo you have"
    echo "13) setupDDR2:         will configure DDR2 controller, you must have PLLs configureg"
    echo "14) showDDR2:          will show DDR2 config registers"
    echo "15) showWatchdog:      will show current register config for watchdog"
    echo "16) reboot:            will trigger watchdog and reboot Telo (hw reset)"
    echo "17) bootNOR:           will boot Telo from NOR"
    echo "18) setupUART0:        will configure UART0 for 115200 8N1, PLLs have to be confiured"
    echo "19) putcUART0:         will print a character on UART0"
    echo "20) putsUART0:         will print a string on UART0"
    echo "21) trainDDR2:          will run DDR2 training program"
    echo "22) flashUBOOT:        will prgram NOR sectors 0-3 with u-boot.bin"
}

source [find mem_helper.tcl]

# read a 64-bit register (memory mapped)
proc mr64bit {reg} {
    set value ""
    mem2array value 32 $reg 2
    return $value
}


# write a 64-bit register (memory mapped)
proc mw64bit {reg value} {
    set high [expr $value >> 32]
    set low  [expr $value & 0xffffffff]
    #echo [format "mw64bit(0x%x): 0x%08x%08x" $reg $high $low]
    mww $reg $low
    mww [expr $reg+4] $high
}


proc showNOR {} {
    echo "This is the current NOR setup"
    set EX_CSEN_REG	    [regs EX_CSEN_REG ]
    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]
    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]
    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]
    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]
    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]
    set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
    set EX_MFSM_REG	    [regs EX_MFSM_REG ]
    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]
    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]
    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]

    echo [format "EX_CSEN_REG      (0x%x): 0x%x" $EX_CSEN_REG [mrw $EX_CSEN_REG]]
    echo [format "EX_CS0_SEG_REG   (0x%x): 0x%x" $EX_CS0_SEG_REG [mrw $EX_CS0_SEG_REG]]
    echo [format "EX_CS0_CFG_REG   (0x%x): 0x%x" $EX_CS0_CFG_REG [mrw $EX_CS0_CFG_REG]]
    echo [format "EX_CS0_TMG1_REG  (0x%x): 0x%x" $EX_CS0_TMG1_REG [mrw $EX_CS0_TMG1_REG]]
    echo [format "EX_CS0_TMG2_REG  (0x%x): 0x%x" $EX_CS0_TMG2_REG [mrw $EX_CS0_TMG2_REG]]
    echo [format "EX_CS0_TMG3_REG  (0x%x): 0x%x" $EX_CS0_TMG3_REG [mrw $EX_CS0_TMG3_REG]]
    echo [format "EX_CLOCK_DIV_REG (0x%x): 0x%x" $EX_CLOCK_DIV_REG [mrw $EX_CLOCK_DIV_REG]]
    echo [format "EX_MFSM_REG      (0x%x): 0x%x" $EX_MFSM_REG [mrw $EX_MFSM_REG]]
    echo [format "EX_CSFSM_REG     (0x%x): 0x%x" $EX_CSFSM_REG [mrw $EX_CSFSM_REG]]
    echo [format "EX_WRFSM_REG     (0x%x): 0x%x" $EX_WRFSM_REG [mrw $EX_WRFSM_REG]]
    echo [format "EX_RDFSM_REG     (0x%x): 0x%x" $EX_RDFSM_REG [mrw $EX_RDFSM_REG]]
}



proc showGPIO {} {
    echo "This is the current GPIO register setup"
    # GPIO outputs register
    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
    # GPIO Output Enable register
    set GPIO_OE_REG		    [regs GPIO_OE_REG]
    set GPIO_HI_INT_ENABLE_REG	    [regs GPIO_HI_INT_ENABLE_REG]
    set GPIO_LO_INT_ENABLE_REG	    [regs GPIO_LO_INT_ENABLE_REG]
    # GPIO input register
    set GPIO_INPUT_REG		    [regs GPIO_INPUT_REG]
    set APB_ACCESS_WS_REG	    [regs APB_ACCESS_WS_REG]
    set MUX_CONF_REG		    [regs MUX_CONF_REG]
    set SYSCONF_REG		    [regs SYSCONF_REG]
    set GPIO_ARM_ID_REG		    [regs GPIO_ARM_ID_REG]
    set GPIO_BOOTSTRAP_REG	    [regs GPIO_BOOTSTRAP_REG]
    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]
    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]
    set GPIO_DEVID_REG		    [regs GPIO_DEVID_REG]

    echo [format "GPIO_OUTPUT_REG       (0x%x): 0x%x" $GPIO_OUTPUT_REG [mrw $GPIO_OUTPUT_REG]]
    echo [format "GPIO_OE_REG           (0x%x): 0x%x" $GPIO_OE_REG [mrw $GPIO_OE_REG]]
    echo [format "GPIO_HI_INT_ENABLE_REG(0x%x): 0x%x" $GPIO_HI_INT_ENABLE_REG [mrw $GPIO_HI_INT_ENABLE_REG]]
    echo [format "GPIO_LO_INT_ENABLE_REG(0x%x): 0x%x" $GPIO_LO_INT_ENABLE_REG [mrw $GPIO_LO_INT_ENABLE_REG]]
    echo [format "GPIO_INPUT_REG        (0x%x): 0x%x" $GPIO_INPUT_REG [mrw $GPIO_INPUT_REG]]
    echo [format "APB_ACCESS_WS_REG     (0x%x): 0x%x" $APB_ACCESS_WS_REG [mrw $APB_ACCESS_WS_REG]]
    echo [format "MUX_CONF_REG          (0x%x): 0x%x" $MUX_CONF_REG [mrw $MUX_CONF_REG]]
    echo [format "SYSCONF_REG           (0x%x): 0x%x" $SYSCONF_REG [mrw $SYSCONF_REG]]
    echo [format "GPIO_ARM_ID_REG       (0x%x): 0x%x" $GPIO_ARM_ID_REG [mrw $GPIO_ARM_ID_REG]]
    echo [format "GPIO_BOOTSTRAP_REG    (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG [mrw $GPIO_BOOTSTRAP_REG]]
    echo [format "GPIO_LOCK_REG         (0x%x): 0x%x" $GPIO_LOCK_REG [mrw $GPIO_LOCK_REG]]
    echo [format "GPIO_IOCTRL_REG       (0x%x): 0x%x" $GPIO_IOCTRL_REG [mrw $GPIO_IOCTRL_REG]]
    echo [format "GPIO_DEVID_REG        (0x%x): 0x%x" $GPIO_DEVID_REG [mrw $GPIO_DEVID_REG]]
}



# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_get_amba_clk())
proc showAmbaClk {} {
    set CFG_REFCLKFREQ		     [config CFG_REFCLKFREQ]
    set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
    set PLL_CLK_BYPASS	             [regs PLL_CLK_BYPASS]

    echo [format "CLKCORE_AHB_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_AHB_CLK_CNTRL [mrw $CLKCORE_AHB_CLK_CNTRL]]
    mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
    # see if the PLL is in bypass mode
    set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
    echo [format "PLL bypass bit: %d" $bypass]
    if {$bypass == 1} {
	echo [format "Amba Clk is set to REFCLK: %d (MHz)" [expr $CFG_REFCLKFREQ/1000000]]
    } else {
	# nope, extract x,y,w and compute the PLL output freq.
	set x [expr ($value(0) & 0x0001F0000) >> 16]
	echo [format "x: %d" $x]
	set y [expr ($value(0) & 0x00000007F)]
	echo [format "y: %d" $y]
	set w [expr ($value(0) & 0x000000300) >> 8]
	echo [format "w: %d" $w]
	echo [format "Amba PLL Clk: %d (MHz)" [expr ($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000]]
    }
}


# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_set_amba_clk())
# this clock is useb by all peripherals (DDR2, ethernet, ebus, etc)
proc setupAmbaClk {} {
    set CLKCORE_PLL_STATUS           [regs CLKCORE_PLL_STATUS]
    set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
    set ARM_PLL_BY_CTRL	    [regs ARM_PLL_BY_CTRL]
    set ARM_AHB_BYP	    [regs ARM_AHB_BYP]
    set PLL_DISABLE	    [regs PLL_DISABLE]
    set PLL_CLK_BYPASS	    [regs PLL_CLK_BYPASS]
    set AHB_PLL_BY_CTRL	    [regs AHB_PLL_BY_CTRL]
    set DIV_BYPASS	    [regs DIV_BYPASS]
    set AHBCLK_PLL_LOCK	    [regs AHBCLK_PLL_LOCK]
    set CFG_REFCLKFREQ		 [config CFG_REFCLKFREQ]
    set CONFIG_SYS_HZ_CLOCK      [config CONFIG_SYS_HZ_CLOCK]
    set w    [config w_amba]
    set x    [config x_amba]
    set y    [config y_amba]

    echo [format "Setting Amba PLL to lock to %d MHz" [expr $CONFIG_SYS_HZ_CLOCK/1000000]]
    #echo [format "setupAmbaClk: w= %d" $w]
    #echo [format "setupAmbaClk: x= %d" $x]
    #echo [format "setupAmbaClk: y= %d" $y]
    # set PLL into BYPASS mode using MUX
    mmw $CLKCORE_AHB_CLK_CNTRL $PLL_CLK_BYPASS 0x0
    # do an internal PLL bypass
    mmw $CLKCORE_AHB_CLK_CNTRL $AHB_PLL_BY_CTRL 0x0
    # wait 500us (ARM running @24Mhz -> 12000 cycles => 500us)
    # openocd smallest resolution is 1ms so, wait 1ms
    sleep 1
    # disable the PLL
    mmw $CLKCORE_AHB_CLK_CNTRL $PLL_DISABLE 0x0
    # wait 1ms
    sleep 1
    # enable the PLL
    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $PLL_DISABLE
    sleep 1
    # set X, W and X
    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 0xFFFFFF
    mmw $CLKCORE_AHB_CLK_CNTRL [expr (($x << 16) + ($w << 8) + $y)] 0x0
    # wait for PLL to lock
    echo "Waiting for Amba PLL to lock"
    while {[expr [mrw $CLKCORE_PLL_STATUS] & $AHBCLK_PLL_LOCK] == 0} { sleep 1 }
    # remove the internal PLL bypass
    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $AHB_PLL_BY_CTRL
    # remove PLL from BYPASS mode using MUX
    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $PLL_CLK_BYPASS
}


# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_get_arm_clk())
proc showArmClk {} {
    set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
    set CLKCORE_ARM_CLK_CNTRL	[regs CLKCORE_ARM_CLK_CNTRL]
    set PLL_CLK_BYPASS	        [regs PLL_CLK_BYPASS]

    echo [format "CLKCORE_ARM_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_ARM_CLK_CNTRL [mrw $CLKCORE_ARM_CLK_CNTRL]]
    mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
    # see if the PLL is in bypass mode
    set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
    echo [format "PLL bypass bit: %d" $bypass]
    if {$bypass == 1} {
	echo [format "Amba Clk is set to REFCLK: %d (MHz)" [expr $CFG_REFCLKFREQ/1000000]]
    } else {
	# nope, extract x,y,w and compute the PLL output freq.
	set x [expr ($value(0) & 0x0001F0000) >> 16]
	echo [format "x: %d" $x]
	set y [expr ($value(0) & 0x00000007F)]
	echo [format "y: %d" $y]
	set w [expr ($value(0) & 0x000000300) >> 8]
	echo [format "w: %d" $w]
	echo [format "Arm PLL Clk: %d (MHz)" [expr ($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000]]
    }
}

# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_set_arm_clk())
# Arm Clock is used by two ARM1136 cores
proc setupArmClk {} {
    set CLKCORE_PLL_STATUS        [regs CLKCORE_PLL_STATUS]
    set CLKCORE_ARM_CLK_CNTRL	  [regs CLKCORE_ARM_CLK_CNTRL]
    set ARM_PLL_BY_CTRL	          [regs ARM_PLL_BY_CTRL]
    set ARM_AHB_BYP	          [regs ARM_AHB_BYP]
    set PLL_DISABLE	          [regs PLL_DISABLE]
    set PLL_CLK_BYPASS	          [regs PLL_CLK_BYPASS]
    set AHB_PLL_BY_CTRL	          [regs AHB_PLL_BY_CTRL]
    set DIV_BYPASS	          [regs DIV_BYPASS]
    set FCLK_PLL_LOCK	          [regs FCLK_PLL_LOCK]
    set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
    set CFG_ARM_CLOCK		[config CFG_ARM_CLOCK]
    set w    [config w_arm]
    set x    [config x_arm]
    set y    [config y_arm]

    echo [format "Setting Arm PLL to lock to %d MHz" [expr $CFG_ARM_CLOCK/1000000]]
    #echo [format "setupArmClk: w= %d" $w]
    #echo [format "setupArmaClk: x= %d" $x]
    #echo [format "setupArmaClk: y= %d" $y]
    # set PLL into BYPASS mode using MUX
    mmw $CLKCORE_ARM_CLK_CNTRL $PLL_CLK_BYPASS 0x0
    # do an internal PLL bypass
    mmw $CLKCORE_ARM_CLK_CNTRL $ARM_PLL_BY_CTRL 0x0
    # wait 500us (ARM running @24Mhz -> 12000 cycles => 500us)
    # openocd smallest resolution is 1ms so, wait 1ms
    sleep 1
    # disable the PLL
    mmw $CLKCORE_ARM_CLK_CNTRL $PLL_DISABLE 0x0
    # wait 1ms
    sleep 1
    # enable the PLL
    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $PLL_DISABLE
    sleep 1
    # set X, W and X
    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 0xFFFFFF
    mmw $CLKCORE_ARM_CLK_CNTRL [expr (($x << 16) + ($w << 8) + $y)] 0x0
    # wait for PLL to lock
    echo "Waiting for Amba PLL to lock"
    while {[expr [mrw $CLKCORE_PLL_STATUS] & $FCLK_PLL_LOCK] == 0} { sleep 1 }
    # remove the internal PLL bypass
    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $ARM_PLL_BY_CTRL
    # remove PLL from BYPASS mode using MUX
    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $PLL_CLK_BYPASS
}



proc setupPLL {} {
    echo "PLLs setup"
    setupAmbaClk
    setupArmClk
}

# converted from u-boot/cpu/arm1136/bsp100.c:SoC_mem_init()
proc setupDDR2 {} {
    echo "Configuring DDR2"

    set MEMORY_BASE_ADDR	    [regs  MEMORY_BASE_ADDR]
    set MEMORY_MAX_ADDR	            [regs  MEMORY_MAX_ADDR]
    set MEMORY_CR 		    [regs  MEMORY_CR]
    set BLOCK_RESET_REG		    [regs  BLOCK_RESET_REG]
    set DDR_RST		            [regs  DDR_RST]

    # put DDR controller in reset (so that it is reset and correctly configured)
    # this is only necessary if DDR was previously confiured
    # and not reset.
    mmw $BLOCK_RESET_REG 0x0 $DDR_RST

    set M [expr 1024 * 1024]
    set DDR_SZ_1024M	[expr 1024 * $M]
    set DDR_SZ_256M	[expr 256 * $M]
    set DDR_SZ_128M	[expr 128 * $M]
    set DDR_SZ_64M	[expr 64 * $M]
    # ooma_board_detect returns DDR2 memory size
    set tmp [ooma_board_detect]
    if {$tmp == "128M"} {
	echo "DDR2 size 128MB"
	set ddr_size $DDR_SZ_128M
    } elseif {$tmp == "256M"} {
	echo "DDR2 size 256MB"
	set ddr_size $DDR_SZ_256M
    } else {
	echo "Don't know how to handle this DDR2 size?"
    }

    # Memory setup register
    mww $MEMORY_MAX_ADDR  [expr ($ddr_size - 1) + $MEMORY_BASE_ADDR]
    # disable ROM remap
    mww $MEMORY_CR 0x0
    # Take DDR controller out of reset
    mmw $BLOCK_RESET_REG $DDR_RST 0x0
    # min. 20 ops delay
    sleep 1

    # This will setup Denali DDR2 controller
    if {$tmp == "128M"} {
	configureDDR2regs_128M
    } elseif {$tmp == "256M"} {
	configureDDR2regs_256M
    } else {
	echo "Don't know how to configure DDR2 setup?"
    }
}



proc showDDR2 {} {

    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]

    set tmp [mr64bit $DENALI_CTL_00_DATA]
    echo [format "DENALI_CTL_00_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_00_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_01_DATA]
    echo [format "DENALI_CTL_01_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_01_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_02_DATA]
    echo [format "DENALI_CTL_02_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_02_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_03_DATA]
    echo [format "DENALI_CTL_03_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_03_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_04_DATA]
    echo [format "DENALI_CTL_04_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_04_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_05_DATA]
    echo [format "DENALI_CTL_05_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_05_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_06_DATA]
    echo [format "DENALI_CTL_06_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_06_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_07_DATA]
    echo [format "DENALI_CTL_07_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_07_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_08_DATA]
    echo [format "DENALI_CTL_08_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_08_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_09_DATA]
    echo [format "DENALI_CTL_09_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_09_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_10_DATA]
    echo [format "DENALI_CTL_10_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_10_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_11_DATA]
    echo [format "DENALI_CTL_11_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_11_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_12_DATA]
    echo [format "DENALI_CTL_12_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_12_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_13_DATA]
    echo [format "DENALI_CTL_13_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_13_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_14_DATA]
    echo [format "DENALI_CTL_14_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_14_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_15_DATA]
    echo [format "DENALI_CTL_15_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_15_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_16_DATA]
    echo [format "DENALI_CTL_16_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_16_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_17_DATA]
    echo [format "DENALI_CTL_17_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_17_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_18_DATA]
    echo [format "DENALI_CTL_18_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_18_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_19_DATA]
    echo [format "DENALI_CTL_19_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_19_DATA $tmp(1) $tmp(0)]
    set tmp [mr64bit $DENALI_CTL_20_DATA]
    echo [format "DENALI_CTL_20_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_20_DATA $tmp(1) $tmp(0)]

}

proc initC100 {} {
    # this follows u-boot/cpu/arm1136/start.S
    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]
    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]
    set GPIO_IOCTRL_VAL	            [regs GPIO_IOCTRL_VAL]
    set APB_ACCESS_WS_REG           [regs APB_ACCESS_WS_REG]
    set ASA_ARAM_BASEADDR	    [regs ASA_ARAM_BASEADDR]
    set ASA_ARAM_TC_CR_REG	    [regs ASA_ARAM_TC_CR_REG]
    set ASA_EBUS_BASEADDR	    [regs ASA_EBUS_BASEADDR]
    set ASA_EBUS_TC_CR_REG	    [regs ASA_EBUS_TC_CR_REG]
    set ASA_TC_REQIDMAEN	    [regs ASA_TC_REQIDMAEN]
    set ASA_TC_REQTDMEN	            [regs ASA_TC_REQTDMEN]
    set ASA_TC_REQIPSECUSBEN        [regs ASA_TC_REQIPSECUSBEN]
    set ASA_TC_REQARM0EN	    [regs ASA_TC_REQARM0EN]
    set ASA_TC_REQARM1EN	    [regs ASA_TC_REQARM1EN]
    set ASA_TC_REQMDMAEN	    [regs ASA_TC_REQMDMAEN]
    set INTC_ARM1_CONTROL_REG       [regs INTC_ARM1_CONTROL_REG]


    # unlock writing to IOCTRL register
    mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
    # enable address lines A15-A21
    mmw $GPIO_IOCTRL_REG 0xf 0x0
    # set ARM into supervisor mode (SVC32)
    # disable IRQ, FIQ
    # Do I need this in JTAG mode?
    # it really should be done as 'and ~0x1f | 0xd3 but
    # openocd does not support this yet
    reg cpsr 0xd3
    #	/*
    #	 * flush v4 I/D caches
    #	 */
    #	mov	r0, #0
    #	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
    arm mcr 15 0 7 7 0 0x0
    #	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
    arm mcr 15 0 8 7 0 0x0

    #	/*
    #	 * disable MMU stuff and caches
    #	 */
    #	mrc	p15, 0, r0, c1, c0, 0
    arm mrc 15 0 1 0 0
    #	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
    #	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
    #	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
    #	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
    #	orr	r0, r0, #0x00400000	@ set bit 22 (U)
    #	mcr	p15, 0, r0, c1, c0, 0
    arm mcr 15 0 1 0 0 0x401002
    # This is from bsp_init() in u-boot/boards/mindspeed/ooma-darwin/board.c
    # APB init
    #    	// Setting APB Bus Wait states to 1, set post write
    #	(*(volatile u32*)(APB_ACCESS_WS_REG)) = 0x40;
    mww [expr $APB_ACCESS_WS_REG] 0x40
    # AHB init
    #	// enable all 6 masters for ARAM
    mmw $ASA_ARAM_TC_CR_REG [expr $ASA_TC_REQIDMAEN | $ASA_TC_REQTDMEN | $ASA_TC_REQIPSECUSBEN | $ASA_TC_REQARM0EN | $ASA_TC_REQARM1EN | $ASA_TC_REQMDMAEN] 0x0
    #	// enable all 6 masters for EBUS
    mmw $ASA_EBUS_TC_CR_REG [expr $ASA_TC_REQIDMAEN | $ASA_TC_REQTDMEN | $ASA_TC_REQIPSECUSBEN | $ASA_TC_REQARM0EN | $ASA_TC_REQARM1EN | $ASA_TC_REQMDMAEN] 0x0

    # ARAM init
    #	// disable pipeline mode in ARAM
    # I don't think this is documented anywhere?
    mww $INTC_ARM1_CONTROL_REG 0x1
    # configure clocks
    setupPLL
    # setupUART0 must be run before setupDDR2 as setupDDR2 uses UART.
    setupUART0
    # enable cache
    # ? (u-boot does nothing here)
    # DDR2 memory init
    setupDDR2
    putsUART0 "C100 initialization complete.\n"
    echo "C100 initialization complete."
}

# show current state of watchdog timer
proc showWatchdog {} {
    set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]
    set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]

    echo [format "TIMER_WDT_HIGH_BOUND    (0x%x): 0x%x" $TIMER_WDT_HIGH_BOUND [mrw $TIMER_WDT_HIGH_BOUND]]
    echo [format "TIMER_WDT_CONTROL       (0x%x): 0x%x" $TIMER_WDT_CONTROL [mrw $TIMER_WDT_CONTROL]]
    echo [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]
}

# converted from u-boot/cpu/arm1136/comcerto/intrrupts.c:void reset_cpu (ulong ignored)
# this will trigger watchdog reset
# the sw. reset does not work on C100
# watchdog reset effectively works as hw. reset
proc reboot {} {
    set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]
    set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]

    # allow the counter to count to high value  before triggering
    # this is because register writes are slow over JTAG and
    # I don't want to miss the high_bound==curr_count condition
    mww $TIMER_WDT_HIGH_BOUND  0xffffff
    mww $TIMER_WDT_CURRENT_COUNT 0x0
    echo "JTAG speed lowered to 100kHz"
    adapter speed 100
    mww $TIMER_WDT_CONTROL 0x1
    # wait until the reset
    echo -n "Waiting for watchdog to trigger..."
    #while {[mrw $TIMER_WDT_CONTROL] == 1} {
    #    echo [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]
    #    sleep 1
    #
    #}
    while {[c100.cpu curstate] != "running"} { sleep 1}
    echo "done."
    echo [format "Note that C100 is in %s state, type halt to stop" [c100.cpu curstate]]
}
# Note that I basically converted
# u-boot/include/asm-arm/arch/comcerto_100.h
# defines

# this is a work-around for 'global' not working under Linux
# access registers by calling this routine.
# For example:
# set EX_CS_TMG1_REG [regs EX_CS0_TMG1_REG]
proc regs {reg} {
    return [dict get [regsC100] $reg ]
}

proc showreg {reg} {
    echo [format "0x%x" [dict get [regsC100] $reg ]]
}

proc regsC100 {} {
#/* memcore */
#/* device memory base addresses */
#// device memory sizes
#/* ARAM SIZE=64K */
dict set regsC100 ARAM_SIZE		0x00010000
dict set regsC100 ARAM_BASEADDR	0x0A000000

#/* Hardware Interface Units */
dict set regsC100 APB_BASEADDR	0x10000000
#/* APB_SIZE=16M address range */
dict set regsC100 APB_SIZE		0x01000000

dict set regsC100 EXP_CS0_BASEADDR       0x20000000
dict set regsC100 EXP_CS1_BASEADDR       0x24000000
dict set regsC100 EXP_CS2_BASEADDR       0x28000000
dict set regsC100 EXP_CS3_BASEADDR       0x2C000000
dict set regsC100 EXP_CS4_BASEADDR       0x30000000

dict set regsC100 DDR_BASEADDR           0x80000000

dict set regsC100 TDM_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x000000]
dict set regsC100 PHI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x010000]
dict set regsC100 TDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x020000]
dict set regsC100 ASA_DDR_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x040000]
dict set regsC100 ASA_ARAM_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x048000]
dict set regsC100 TIMER_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x050000]
dict set regsC100 ASD_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x060000]
dict set regsC100 GPIO_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x070000]
dict set regsC100 UART0_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x090000]
dict set regsC100 UART1_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x094000]
dict set regsC100 SPI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x098000]
dict set regsC100 I2C_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x09C000]
dict set regsC100 INTC_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0A0000]
dict set regsC100 CLKCORE_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x0B0000]
dict set regsC100 PUI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0B0000]
dict set regsC100 GEMAC_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0D0000]
dict set regsC100 IDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0E0000]
dict set regsC100 MEMCORE_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x0F0000]
dict set regsC100 ASA_EBUS_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x100000]
dict set regsC100 ASA_AAB_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x108000]
dict set regsC100 GEMAC1_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x190000]
dict set regsC100 EBUS_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x1A0000]
dict set regsC100 MDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x1E0000]


#////////////////////////////////////////////////////////////
#//	AHB block											    //
#////////////////////////////////////////////////////////////
dict set regsC100 ASA_ARAM_PRI_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x00]
dict set regsC100 ASA_ARAM_TC_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x04]
dict set regsC100 ASA_ARAM_TC_CR_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x08]
dict set regsC100 ASA_ARAM_STAT_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x0C]

dict set regsC100 ASA_EBUS_PRI_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x00]
dict set regsC100 ASA_EBUS_TC_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x04]
dict set regsC100 ASA_EBUS_TC_CR_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x08]
dict set regsC100 ASA_EBUS_STAT_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x0C]

dict set regsC100 IDMA_MASTER		0
dict set regsC100 TDMA_MASTER		1
dict set regsC100 USBIPSEC_MASTER	2
dict set regsC100 ARM0_MASTER		3
dict set regsC100 ARM1_MASTER		4
dict set regsC100 MDMA_MASTER		5

#define IDMA_PRIORITY(level) (level)
#define TDM_PRIORITY(level) (level << 4)
#define USBIPSEC_PRIORITY(level) (level << 8)
#define ARM0_PRIORITY(level) (level << 12)
#define ARM1_PRIORITY(level) (level << 16)
#define MDMA_PRIORITY(level) (level << 20)

dict set regsC100 ASA_TC_REQIDMAEN	 [expr 1<<18]
dict set regsC100 ASA_TC_REQTDMEN	 [expr 1<<19]
dict set regsC100 ASA_TC_REQIPSECUSBEN [expr 1<<20]
dict set regsC100 ASA_TC_REQARM0EN	 [expr 1<<21]
dict set regsC100 ASA_TC_REQARM1EN	 [expr 1<<22]
dict set regsC100 ASA_TC_REQMDMAEN	 [expr 1<<23]

dict set regsC100 MEMORY_BASE_ADDR	0x80000000
dict set regsC100 MEMORY_MAX_ADDR	[expr [dict get $regsC100 ASD_BASEADDR ] + 0x10]
dict set regsC100 MEMORY_CR 		[expr [dict get $regsC100 ASD_BASEADDR ] + 0x14]
dict set regsC100 ROM_REMAP_EN	0x1

#define HAL_asb_priority(level) \
#*(volatile unsigned *)ASA_PRI_REG = level

#define HAL_aram_priority(level) \
#*(volatile unsigned *)ASA_ARAM_PRI_REG = level

#define HAL_aram_arbitration(arbitration_mask) \
#*(volatile unsigned *)ASA_ARAM_TC_CR_REG |= arbitration_mask

#define HAL_aram_defmaster(mask) \
#*(volatile unsigned *)ASA_ARAM_TC_CR_REG = (*(volatile unsigned *)ASA_TC_CR_REG & 0xFFFF) | (mask << 24)

#////////////////////////////////////////////////////////////
#// INTC block						  //
#////////////////////////////////////////////////////////////

dict set regsC100 INTC_ARM1_CONTROL_REG	[expr [dict get $regsC100 INTC_BASEADDR ] + 0x18]

#////////////////////////////////////////////////////////////
#// TIMER block						  //
#////////////////////////////////////////////////////////////

dict set regsC100 TIMER0_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x00]
dict set regsC100 TIMER0_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x04]
dict set regsC100 TIMER1_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x08]
dict set regsC100 TIMER1_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x0C]

dict set regsC100 TIMER2_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x18]
dict set regsC100 TIMER2_LBOUND_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x10]
dict set regsC100 TIMER2_HBOUND_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x14]
dict set regsC100 TIMER2_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x1C]

dict set regsC100 TIMER3_LOBND	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x20]
dict set regsC100 TIMER3_HIBND	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x24]
dict set regsC100 TIMER3_CTRL		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x28]
dict set regsC100 TIMER3_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x2C]

dict set regsC100 TIMER_MASK		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x40]
dict set regsC100 TIMER_STATUS	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x50]
dict set regsC100 TIMER_ACK		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x50]
dict set regsC100 TIMER_WDT_HIGH_BOUND [expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD0]
dict set regsC100 TIMER_WDT_CONTROL	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD4]
dict set regsC100 TIMER_WDT_CURRENT_COUNT [expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD8]



#////////////////////////////////////////////////////////////
#//  EBUS block
#////////////////////////////////////////////////////////////

dict set regsC100 EX_SWRST_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x00]
dict set regsC100 EX_CSEN_REG		        [expr [dict get $regsC100 EBUS_BASEADDR ] + 0x04]
dict set regsC100 EX_CS0_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x08]
dict set regsC100 EX_CS1_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x0C]
dict set regsC100 EX_CS2_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x10]
dict set regsC100 EX_CS3_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x14]
dict set regsC100 EX_CS4_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x18]
dict set regsC100 EX_CS0_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x1C]
dict set regsC100 EX_CS1_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x20]
dict set regsC100 EX_CS2_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x24]
dict set regsC100 EX_CS3_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x28]
dict set regsC100 EX_CS4_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x2C]
dict set regsC100 EX_CS0_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x30]
dict set regsC100 EX_CS1_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x34]
dict set regsC100 EX_CS2_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x38]
dict set regsC100 EX_CS3_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x3C]
dict set regsC100 EX_CS4_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x40]
dict set regsC100 EX_CS0_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x44]
dict set regsC100 EX_CS1_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x48]
dict set regsC100 EX_CS2_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x4C]
dict set regsC100 EX_CS3_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x50]
dict set regsC100 EX_CS4_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x54]
dict set regsC100 EX_CS0_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x58]
dict set regsC100 EX_CS1_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x5C]
dict set regsC100 EX_CS2_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x60]
dict set regsC100 EX_CS3_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x64]
dict set regsC100 EX_CS4_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x68]
dict set regsC100 EX_CLOCK_DIV_REG	        [expr [dict get $regsC100 EBUS_BASEADDR ] + 0x6C]

dict set regsC100 EX_MFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x100]
dict set regsC100 EX_MFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x100]
dict set regsC100 EX_CSFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x104]
dict set regsC100 EX_WRFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x108]
dict set regsC100 EX_RDFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x10C]


dict set regsC100 EX_CLK_EN		0x00000001
dict set regsC100 EX_CSBOOT_EN	0x00000002
dict set regsC100 EX_CS0_EN		0x00000002
dict set regsC100 EX_CS1_EN		0x00000004
dict set regsC100 EX_CS2_EN		0x00000008
dict set regsC100 EX_CS3_EN		0x00000010
dict set regsC100 EX_CS4_EN		0x00000020

dict set regsC100 EX_MEM_BUS_8	0x00000000
dict set regsC100 EX_MEM_BUS_16       0x00000002
dict set regsC100 EX_MEM_BUS_32	0x00000004
dict set regsC100 EX_CS_HIGH		0x00000008
dict set regsC100 EX_WE_HIGH		0x00000010
dict set regsC100 EX_RE_HIGH		0x00000020
dict set regsC100 EX_ALE_MODE		0x00000040
dict set regsC100 EX_STRB_MODE	0x00000080
dict set regsC100 EX_DM_MODE		0x00000100
dict set regsC100 EX_NAND_MODE	0x00000200
dict set regsC100 EX_RDY_EN		0x00000400
dict set regsC100 EX_RDY_EDGE		0x00000800

#////////////////////////////////////////////////////////////
#//  GPIO block
#////////////////////////////////////////////////////////////

# GPIO outputs register
dict set regsC100 GPIO_OUTPUT_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x00]
# GPIO Output Enable register
dict set regsC100 GPIO_OE_REG		        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x04]
dict set regsC100 GPIO_HI_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x08]
dict set regsC100 GPIO_LO_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x0C]
# GPIO input register
dict set regsC100 GPIO_INPUT_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x10]
dict set regsC100 APB_ACCESS_WS_REG	        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x14]
dict set regsC100 MUX_CONF_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x18]
dict set regsC100 SYSCONF_REG		        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x1C]
dict set regsC100 GPIO_ARM_ID_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x30]
dict set regsC100 GPIO_BOOTSTRAP_REG	        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x40]
dict set regsC100 GPIO_LOCK_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x38]
dict set regsC100 GPIO_IOCTRL_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x44]
dict set regsC100 GPIO_DEVID_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x50]

dict set regsC100 GPIO_IOCTRL_A15A16	0x00000001
dict set regsC100 GPIO_IOCTRL_A17A18	0x00000002
dict set regsC100 GPIO_IOCTRL_A19A21	0x00000004
dict set regsC100 GPIO_IOCTRL_TMREVT0	0x00000008
dict set regsC100 GPIO_IOCTRL_TMREVT1	0x00000010
dict set regsC100 GPIO_IOCTRL_GPBT3	0x00000020
dict set regsC100 GPIO_IOCTRL_I2C	0x00000040
dict set regsC100 GPIO_IOCTRL_UART0	0x00000080
dict set regsC100 GPIO_IOCTRL_UART1	0x00000100
dict set regsC100 GPIO_IOCTRL_SPI	0x00000200
dict set regsC100 GPIO_IOCTRL_HBMODE	0x00000400

dict set regsC100 GPIO_IOCTRL_VAL	0x55555555

dict set regsC100 GPIO_0			0x01
dict set regsC100 GPIO_1			0x02
dict set regsC100 GPIO_2			0x04
dict set regsC100 GPIO_3			0x08
dict set regsC100 GPIO_4			0x10
dict set regsC100 GPIO_5			0x20
dict set regsC100 GPIO_6			0x40
dict set regsC100 GPIO_7			0x80

dict set regsC100 GPIO_RISING_EDGE	1
dict set regsC100 GPIO_FALLING_EDGE	2
dict set regsC100 GPIO_BOTH_EDGES	3

#////////////////////////////////////////////////////////////
#// UART
#////////////////////////////////////////////////////////////

dict set regsC100 UART0_RBR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
dict set regsC100 UART0_THR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
dict set regsC100 UART0_DLL		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
dict set regsC100 UART0_IER		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x04]
dict set regsC100 UART0_DLH		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x04]
dict set regsC100 UART0_IIR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x08]
dict set regsC100 UART0_FCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x08]
dict set regsC100 UART0_LCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x0C]
dict set regsC100 UART0_MCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x10]
dict set regsC100 UART0_LSR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x14]
dict set regsC100 UART0_MSR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x18]
dict set regsC100 UART0_SCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x1C]

dict set regsC100 UART1_RBR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
dict set regsC100 UART1_THR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
dict set regsC100 UART1_DLL		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
dict set regsC100 UART1_IER		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x04]
dict set regsC100 UART1_DLH		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x04]
dict set regsC100 UART1_IIR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x08]
dict set regsC100 UART1_FCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x08]
dict set regsC100 UART1_LCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x0C]
dict set regsC100 UART1_MCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x10]
dict set regsC100 UART1_LSR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x14]
dict set regsC100 UART1_MSR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x18]
dict set regsC100 UART1_SCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x1C]

# /* default */
dict set regsC100 LCR_CHAR_LEN_5		0x00
dict set regsC100 LCR_CHAR_LEN_6		0x01
dict set regsC100 LCR_CHAR_LEN_7		0x02
dict set regsC100 LCR_CHAR_LEN_8		0x03
#/* One stop bit! - default */
dict set regsC100 LCR_ONE_STOP		0x00
#/* Two stop bit! */
dict set regsC100 LCR_TWO_STOP		0x04
#/* Parity Enable */
dict set regsC100 LCR_PEN			0x08
dict set regsC100 LCR_PARITY_NONE		0x00
#/* Even Parity Select */
dict set regsC100 LCR_EPS			0x10
#/* Enable Parity  Stuff */
dict set regsC100 LCR_PS			0x20
#/* Start Break */
dict set regsC100 LCR_SBRK		        0x40
#/* Parity Stuff Bit */
dict set regsC100 LCR_PSB			0x80
#/* UART 16550 Divisor Latch Assess */
dict set regsC100 LCR_DLAB		        0x80

#/* FIFO Error Status */
dict set regsC100 LSR_FIFOE		[expr 1 << 7]
#/* Transmitter Empty */
dict set regsC100 LSR_TEMT		[expr 1 << 6]
#/* Transmit Data Request */
dict set regsC100 LSR_TDRQ		[expr 1 << 5]
#/* Break Interrupt */
dict set regsC100 LSR_BI			[expr 1 << 4]
#/* Framing Error */
dict set regsC100 LSR_FE			[expr 1 << 3]
#/* Parity Error */
dict set regsC100 LSR_PE			[expr 1 << 2]
#/* Overrun Error */
dict set regsC100 LSR_OE			[expr 1 << 1]
#/* Data Ready */
dict set regsC100 LSR_DR			[expr 1 << 0]

#/* DMA Requests Enable */
dict set regsC100 IER_DMAE		        [expr 1 << 7]
#/* UART Unit Enable */
dict set regsC100 IER_UUE			[expr 1 << 6]
#/* NRZ coding Enable */
dict set regsC100 IER_NRZE		        [expr 1 << 5]
#/* Receiver Time Out Interrupt Enable */
dict set regsC100 IER_RTIOE		        [expr 1 << 4]
#/* Modem Interrupt Enable */
dict set regsC100 IER_MIE			[expr 1 << 3]
#/* Receiver Line Status Interrupt Enable */
dict set regsC100 IER_RLSE		        [expr 1 << 2]
#/* Transmit Data request Interrupt Enable */
dict set regsC100 IER_TIE			[expr 1 << 1]
#/* Receiver Data Available Interrupt Enable */
dict set regsC100 IER_RAVIE		        [expr 1 << 0]

#/* FIFO Mode Enable Status */
dict set regsC100 IIR_FIFOES1		        [expr 1 << 7]
#/* FIFO Mode Enable Status */
dict set regsC100 IIR_FIFOES0		        [expr 1 << 6]
#/* Time Out Detected */
dict set regsC100 IIR_TOD			[expr 1 << 3]
#/* Interrupt Source Encoded */
dict set regsC100 IIR_IID2		        [expr 1 << 2]
#/* Interrupt Source Encoded */
dict set regsC100 IIR_IID1		        [expr 1 << 1]
#/* Interrupt Pending (active low) */
dict set regsC100 IIR_IP			[expr 1 << 0]

#/* UART 16550 FIFO Control Register */
dict set regsC100 FCR_FIFOEN		0x01
dict set regsC100 FCR_RCVRRES		0x02
dict set regsC100 FCR_XMITRES		0x04

#/* Interrupt Enable Register */
#// UART 16550
#// Enable Received Data Available Interrupt
dict set regsC100 IER_RXTH		0x01
#// Enable Transmitter Empty Interrupt
dict set regsC100 IER_TXTH		0x02



#////////////////////////////////////////////////////////////
#// CLK  + RESET block
#////////////////////////////////////////////////////////////

dict set regsC100 CLKCORE_ARM_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x00]
dict set regsC100 CLKCORE_AHB_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x04]
dict set regsC100 CLKCORE_PLL_STATUS	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x08]
dict set regsC100 CLKCORE_CLKDIV_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x0C]
dict set regsC100 CLKCORE_TDM_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x10]
dict set regsC100 CLKCORE_FSYNC_CNTRL	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x14]
dict set regsC100 CLKCORE_CLK_PWR_DWN	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x18]
dict set regsC100 CLKCORE_RNG_CNTRL	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x1C]
dict set regsC100 CLKCORE_RNG_STATUS	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x20]
dict set regsC100 CLKCORE_ARM_CLK_CNTRL2	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x24]
dict set regsC100 CLKCORE_TDM_REF_DIV_RST	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x40]

dict set regsC100 ARM_PLL_BY_CTRL	0x80000000
dict set regsC100 ARM_AHB_BYP		0x04000000
dict set regsC100 PLL_DISABLE		0x02000000
dict set regsC100 PLL_CLK_BYPASS	0x01000000

dict set regsC100 AHB_PLL_BY_CTRL	0x80000000
dict set regsC100 DIV_BYPASS		0x40000000
dict set regsC100 SYNC_MODE		0x20000000

dict set regsC100 EPHY_CLKDIV_BYPASS	0x00200000
dict set regsC100 EPHY_CLKDIV_RATIO_SHIFT	16
dict set regsC100 PUI_CLKDIV_BYPASS	0x00004000
dict set regsC100 PUI_CLKDIV_SRCCLK	0x00002000
dict set regsC100 PUI_CLKDIV_RATIO_SHIFT	8
dict set regsC100 PCI_CLKDIV_BYPASS	0x00000020
dict set regsC100 PCI_CLKDIV_RATIO_SHIFT	0

dict set regsC100 ARM0_CLK_PD		0x00200000
dict set regsC100 ARM1_CLK_PD		0x00100000
dict set regsC100 EPHY_CLK_PD		0x00080000
dict set regsC100 TDM_CLK_PD		0x00040000
dict set regsC100 PUI_CLK_PD		0x00020000
dict set regsC100 PCI_CLK_PD		0x00010000
dict set regsC100 MDMA_AHBCLK_PD	0x00000400
dict set regsC100 I2CSPI_AHBCLK_PD	0x00000200
dict set regsC100 UART_AHBCLK_PD	0x00000100
dict set regsC100 IPSEC_AHBCLK_PD	0x00000080
dict set regsC100 TDM_AHBCLK_PD	0x00000040
dict set regsC100 USB1_AHBCLK_PD	0x00000020
dict set regsC100 USB0_AHBCLK_PD	0x00000010
dict set regsC100 GEMAC1_AHBCLK_PD	0x00000008
dict set regsC100 GEMAC0_AHBCLK_PD	0x00000004
dict set regsC100 PUI_AHBCLK_PD	0x00000002
dict set regsC100 HIF_AHBCLK_PD	0x00000001

dict set regsC100 ARM1_DIV_BP		0x00001000
dict set regsC100 ARM1_DIV_VAL_SHIFT	8
dict set regsC100 ARM0_DIV_BP		0x00000010
dict set regsC100 ARM0_DIV_VAL_SHIFT	0

dict set regsC100 AHBCLK_PLL_LOCK	0x00000002
dict set regsC100 FCLK_PLL_LOCK	0x00000001


#// reset block
dict set regsC100 BLOCK_RESET_REG		[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x100]
dict set regsC100 CSP_RESET_REG		[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x104]

dict set regsC100 RNG_RST		0x1000
dict set regsC100 IPSEC_RST		0x0800
dict set regsC100 DDR_RST		0x0400
dict set regsC100 USB1_PHY_RST	0x0200
dict set regsC100 USB0_PHY_RST	0x0100
dict set regsC100 USB1_RST		0x0080
dict set regsC100 USB0_RST		0x0040
dict set regsC100 GEMAC1_RST		0x0020
dict set regsC100 GEMAC0_RST		0x0010
dict set regsC100 TDM_RST		0x0008
dict set regsC100 PUI_RST		0x0004
dict set regsC100 HIF_RST		0x0002
dict set regsC100 PCI_RST		0x0001

#////////////////////////////////////////////////////////////////
#//	DDR  CONTROLLER block
#////////////////////////////////////////////////////////////////

dict set regsC100 DDR_CONFIG_BASEADDR	0x0D000000
dict set regsC100 DENALI_CTL_00_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x00]
dict set regsC100 DENALI_CTL_01_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x08]
dict set regsC100 DENALI_CTL_02_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x10]
dict set regsC100 DENALI_CTL_03_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x18]
dict set regsC100 DENALI_CTL_04_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x20]
dict set regsC100 DENALI_CTL_05_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x28]
dict set regsC100 DENALI_CTL_06_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x30]
dict set regsC100 DENALI_CTL_07_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x38]
dict set regsC100 DENALI_CTL_08_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x40]
dict set regsC100 DENALI_CTL_09_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x48]
dict set regsC100 DENALI_CTL_10_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x50]
dict set regsC100 DENALI_CTL_11_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x58]
dict set regsC100 DENALI_CTL_12_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x60]
dict set regsC100 DENALI_CTL_13_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x68]
dict set regsC100 DENALI_CTL_14_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x70]
dict set regsC100 DENALI_CTL_15_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x78]
dict set regsC100 DENALI_CTL_16_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x80]
dict set regsC100 DENALI_CTL_17_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x88]
dict set regsC100 DENALI_CTL_18_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x90]
dict set regsC100 DENALI_CTL_19_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x98]
dict set regsC100 DENALI_CTL_20_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0xA0]

# 32-bit value
dict set regsC100 DENALI_READY_CHECK         [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x44]
# 8-bit
dict set regsC100 DENALI_WR_DQS              [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x5D]
# 8-bit
dict set regsC100 DENALI_DQS_OUT             [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x5A]
# 8-bit
dict set regsC100 DENALI_DQS_DELAY0          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x4F]
# 8-bit
dict set regsC100 DENALI_DQS_DELAY1          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x50]
# 8-bit
dict set regsC100 DENALI_DQS_DELAY2          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x51]
# 8-bit
dict set regsC100 DENALI_DQS_DELAY3          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x52]


# end of proc regsC100
}
# Config for Texas Instruments low power RF SoC CC2538
# http://www.ti.com/lit/pdf/swru319

adapter speed 100

source [find target/icepick.cfg]
source [find target/ti-cjtag.cfg]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME cc2538
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x8B96402F
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "icepick_c_tapenable $_CHIPNAME.jrc 0"

#
# ICEpick-C (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID 0x8B96402F
}
jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version
# A start sequence is needed to change from cJTAG (Compact JTAG) to
# 4-pin JTAG before talking via JTAG commands
jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.cpu"
jtag configure $_CHIPNAME.jrc -event post-reset "ti_cjtag_to_4pin_jtag $_CHIPNAME.jrc"

#
# Cortex-M3 target
#
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME cs351x
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x00526fa1
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# Create the GDB Target.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME fa526 -endian $_ENDIAN -chain-position $_TARGETNAME

# There is 16K of SRAM on this chip
# FIXME: flash programming is not working by using this work area. So comment this out for now.
#$_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x4000 -work-area-backup 1

# This chip has a DCC ... use it
arm7_9 dcc_downloads enable
#
# Utility code for DaVinci-family chips
#

# davinci_pinmux: assigns PINMUX$reg <== $value
proc davinci_pinmux {soc reg value} {
	mww [expr [dict get $soc sysbase] + 4 * $reg] $value
}

source [find mem_helper.tcl]

#
# pll_setup: initialize PLL
#  - pll_addr ... physical addr of controller
#  - mult ... pll multiplier
#  - config ... dict mapping { prediv, postdiv, div[1-9] } to dividers
#
# For PLLs that don't have a given register (e.g. plldiv8), or where a
# given divider is non-programmable, caller provides *NO* config mapping.
#

# PLL version 0x02: tested on dm355
# REVISIT: On dm6446/dm357 the PLLRST polarity is different.
proc pll_v02_setup {pll_addr mult config} {
	set pll_ctrl_addr [expr $pll_addr + 0x100]
	set pll_ctrl [mrw $pll_ctrl_addr]

	# 1 - clear CLKMODE (bit 8) iff using on-chip oscillator
	# NOTE: this assumes we should clear that bit
	set pll_ctrl [expr $pll_ctrl & ~0x0100]
	mww $pll_ctrl_addr $pll_ctrl

	# 2 - clear PLLENSRC (bit 5)
	set pll_ctrl [expr $pll_ctrl & ~0x0020]
	mww $pll_ctrl_addr $pll_ctrl

	# 3 - clear PLLEN (bit 0) ... enter bypass mode
	set pll_ctrl [expr $pll_ctrl & ~0x0001]
	mww $pll_ctrl_addr $pll_ctrl

	# 4 - wait at least 4 refclk cycles
	sleep 1

	# 5 - set PLLRST (bit 3)
	set pll_ctrl [expr $pll_ctrl | 0x0008]
	mww $pll_ctrl_addr $pll_ctrl

	# 6 - set PLLDIS (bit 4)
	set pll_ctrl [expr $pll_ctrl | 0x0010]
	mww $pll_ctrl_addr $pll_ctrl

	# 7 - clear PLLPWRDN (bit 1)
	set pll_ctrl [expr $pll_ctrl & ~0x0002]
	mww $pll_ctrl_addr $pll_ctrl

	# 8 - clear PLLDIS (bit 4)
	set pll_ctrl [expr $pll_ctrl & ~0x0010]
	mww $pll_ctrl_addr $pll_ctrl

	# 9 - optional: write prediv, postdiv, and pllm
	# NOTE: for dm355 PLL1, postdiv is controlled via MISC register
	mww [expr $pll_addr + 0x0110] [expr ($mult - 1) & 0xff]
	if { [dict exists $config prediv] } {
		set div [dict get $config prediv]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0114] $div
	}
	if { [dict exists $config postdiv] } {
		set div [dict get $config postdiv]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0128] $div
	}

	# 10 - optional: set plldiv1, plldiv2, ...
	# NOTE:  this assumes some registers have their just-reset values:
	#	- PLLSTAT.GOSTAT is clear when we enter
	#	- ALNCTL has everything set
	set go 0
	if { [dict exists $config div1] } {
		set div [dict get $config div1]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0118] $div
		set go 1
	}
	if { [dict exists $config div2] } {
		set div [dict get $config div2]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x011c] $div
		set go 1
	}
	if { [dict exists $config div3] } {
		set div [dict get $config div3]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0120] $div
		set go 1
	}
	if { [dict exists $config div4] } {
		set div [dict get $config div4]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0160] $div
		set go 1
	}
	if { [dict exists $config div5] } {
		set div [dict get $config div5]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0164] $div
		set go 1
	}
	if {$go != 0} {
		# write pllcmd.GO; poll pllstat.GO
		mww [expr $pll_addr + 0x0138] 0x01
		set pllstat [expr $pll_addr + 0x013c]
		while {[expr [mrw $pllstat] & 0x01] != 0} { sleep 1 }
	}
	mww [expr $pll_addr + 0x0138] 0x00

	# 11 - wait at least 5 usec for reset to finish
	# (assume covered by overheads including JTAG messaging)

	# 12 - clear PLLRST (bit 3)
	set pll_ctrl [expr $pll_ctrl & ~0x0008]
	mww $pll_ctrl_addr $pll_ctrl

	# 13 - wait at least 8000 refclk cycles for PLL to lock
	# if we assume 24 MHz (slowest osc), that's 1/3 msec
	sleep 3

	# 14 - set PLLEN (bit 0) ... leave bypass mode
	set pll_ctrl [expr $pll_ctrl | 0x0001]
	mww $pll_ctrl_addr $pll_ctrl
}

# PLL version 0x03: tested on dm365
proc pll_v03_setup {pll_addr mult config} {
	set pll_ctrl_addr [expr $pll_addr + 0x100]
	set pll_secctrl_addr [expr $pll_addr + 0x108]
	set pll_ctrl [mrw $pll_ctrl_addr]

	# 1 - power up the PLL
	set pll_ctrl [expr $pll_ctrl & ~0x0002]
	mww $pll_ctrl_addr $pll_ctrl

	# 2 - clear PLLENSRC (bit 5)
	set pll_ctrl [expr $pll_ctrl & ~0x0020]
	mww $pll_ctrl_addr $pll_ctrl

	# 2 - clear PLLEN (bit 0) ... enter bypass mode
	set pll_ctrl [expr $pll_ctrl & ~0x0001]
	mww $pll_ctrl_addr $pll_ctrl

	# 3 - wait at least 4 refclk cycles
	sleep 1

	# 4 - set PLLRST (bit 3)
	set pll_ctrl [expr $pll_ctrl | 0x0008]
	mww $pll_ctrl_addr $pll_ctrl

	# 5 - wait at least 5 usec
	sleep 1

	# 6 - clear PLLRST (bit 3)
	set pll_ctrl [expr $pll_ctrl & ~0x0008]
	mww $pll_ctrl_addr $pll_ctrl

	# 9 - optional: write prediv, postdiv, and pllm
	mww [expr $pll_addr + 0x0110] [expr ($mult / 2) & 0x1ff]
	if { [dict exists $config prediv] } {
		set div [dict get $config prediv]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0114] $div
	}
	if { [dict exists $config postdiv] } {
		set div [dict get $config postdiv]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0128] $div
	}

	# 10 - write start sequence to PLLSECCTL
	mww $pll_secctrl_addr 0x00470000
	mww $pll_secctrl_addr 0x00460000
	mww $pll_secctrl_addr 0x00400000
	mww $pll_secctrl_addr 0x00410000

	# 11 - optional: set plldiv1, plldiv2, ...
	# NOTE: this assumes some registers have their just-reset values:
	#	- PLLSTAT.GOSTAT is clear when we enter
	set aln 0
	if { [dict exists $config div1] } {
		set div [dict get $config div1]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0118] $div
		set aln [expr $aln | 0x1]
	} else {
		mww [expr $pll_addr + 0x0118] 0
	}
	if { [dict exists $config div2] } {
		set div [dict get $config div2]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x011c] $div
		set aln [expr $aln | 0x2]
	} else {
		mww [expr $pll_addr + 0x011c] 0
	}
	if { [dict exists $config div3] } {
		set div [dict get $config div3]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0120] $div
		set aln [expr $aln | 0x4]
	} else {
		mww [expr $pll_addr + 0x0120] 0
	}
	if { [dict exists $config oscdiv] } {
		set div [dict get $config oscdiv]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0124] $div
	} else {
		mww [expr $pll_addr + 0x0124] 0
	}
	if { [dict exists $config div4] } {
		set div [dict get $config div4]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0160] $div
		set aln [expr $aln | 0x8]
	} else {
		mww [expr $pll_addr + 0x0160] 0
	}
	if { [dict exists $config div5] } {
		set div [dict get $config div5]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0164] $div
		set aln [expr $aln | 0x10]
	} else {
		mww [expr $pll_addr + 0x0164] 0
	}
	if { [dict exists $config div6] } {
		set div [dict get $config div6]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0168] $div
		set aln [expr $aln | 0x20]
	} else {
		mww [expr $pll_addr + 0x0168] 0
	}
	if { [dict exists $config div7] } {
		set div [dict get $config div7]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x016c] $div
		set aln [expr $aln | 0x40]
	} else {
		mww [expr $pll_addr + 0x016c] 0
	}
	if { [dict exists $config div8] } {
		set div [dict get $config div8]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0170] $div
		set aln [expr $aln | 0x80]
	} else {
		mww [expr $pll_addr + 0x0170] 0
	}
	if { [dict exists $config div9] } {
		set div [dict get $config div9]
		set div [expr 0x8000 | ($div - 1)]
		mww [expr $pll_addr + 0x0174] $div
		set aln [expr $aln | 0x100]
	} else {
		mww [expr $pll_addr + 0x0174] 0
	}
	if {$aln != 0} {
		# clear pllcmd.GO
		mww [expr $pll_addr + 0x0138] 0x00
		# write alingment flags
		mww [expr $pll_addr + 0x0140] $aln
		# write pllcmd.GO; poll pllstat.GO
		mww [expr $pll_addr + 0x0138] 0x01
		set pllstat [expr $pll_addr + 0x013c]
		while {[expr [mrw $pllstat] & 0x01] != 0} { sleep 1 }
	}
	mww [expr $pll_addr + 0x0138] 0x00
	set addr [dict get $config ctladdr]
	while {[expr [mrw $addr] & 0x0e000000] != 0x0e000000} { sleep 1 }

	# 12 - set PLLEN (bit 0) ... leave bypass mode
	set pll_ctrl [expr $pll_ctrl | 0x0001]
	mww $pll_ctrl_addr $pll_ctrl
}

# NOTE: dm6446 requires EMURSTIE set in MDCTL before certain
# modules can be enabled.

# prepare a non-DSP module to be enabled; finish with psc_go
proc psc_enable {module} {
	set psc_addr 0x01c41000
	# write MDCTL
	mmw [expr $psc_addr + 0x0a00 + (4 * $module)] 0x03 0x1f
}

# prepare a non-DSP module to be reset; finish with psc_go
proc psc_reset {module} {
	set psc_addr 0x01c41000
	# write MDCTL
	mmw [expr $psc_addr + 0x0a00 + (4 * $module)] 0x01 0x1f
}

# execute non-DSP PSC transition(s) set up by psc_enable, psc_reset, etc
proc psc_go {} {
	set psc_addr 0x01c41000
	set ptstat_addr [expr $psc_addr + 0x0128]

	# just in case PTSTAT.go isn't clear
	while { [expr [mrw $ptstat_addr] & 0x01] != 0 } { sleep 1 }

	# write PTCMD.go ... ignoring any DSP power domain
	mww [expr $psc_addr + 0x0120] 1

	# wait for PTSTAT.go to clear (again ignoring DSP power domain)
	while { [expr [mrw $ptstat_addr] & 0x01] != 0 } { sleep 1 }
}

#
# A reset using only SRST is a "Warm Reset", resetting everything in the
# chip except ARM emulation (and everything _outside_ the chip that hooks
# up to SRST).  But many boards don't expose SRST via their JTAG connectors
# (it's not present on TI-14 headers).
#
# From the chip-only perspective, a "Max Reset" is a "Warm" reset ... except
# without any board-wide side effects, since it's triggered using JTAG using
# either (a) ARM watchdog timer, or (b) ICEpick.
#
proc davinci_wdog_reset {} {
	set timer2_phys 0x01c21c00

	# NOTE -- on entry
	#   - JTAG communication with the ARM *must* be working OK; this
	#     may imply using adaptive clocking or disabling WFI-in-idle
	#   - current target must be the DaVinci ARM
	#   - that ARM core must be halted
	#   - timer2 clock is still enabled (PSC 29 on most chips)

	#
	# Part I -- run regardless of being halted via JTAG
	#
	# NOTE:  for now, we assume there's no DSP that could control the
	# watchdog; or, equivalently, SUSPSRC.TMR2SRC says the watchdog
	# suspend signal is controlled via ARM emulation suspend.
	#

	# EMUMGT_CLKSPEED: write FREE bit to run despite emulation halt
	mww phys [expr $timer2_phys + 0x28] 0x00004000

	#
	# Part II -- in case watchdog hasn't been set up
	#

	# TCR: disable, force internal clock source
	mww phys [expr $timer2_phys + 0x20] 0

	# TGCR: reset, force to 64-bit wdog mode, un-reset ("initial" state)
	mww phys [expr $timer2_phys + 0x24] 0
	mww phys [expr $timer2_phys + 0x24] 0x110b

	# clear counter (TIM12, TIM34) and period (PRD12, PRD34) registers
	# so watchdog triggers ASAP
	mww phys [expr $timer2_phys + 0x10] 0
	mww phys [expr $timer2_phys + 0x14] 0
	mww phys [expr $timer2_phys + 0x18] 0
	mww phys [expr $timer2_phys + 0x1c] 0

	# WDTCR: put into pre-active state, then active
	mww phys [expr $timer2_phys + 0x28] 0xa5c64000
	mww phys [expr $timer2_phys + 0x28] 0xda7e4000

	#
	# Part III -- it's ready to rumble
	#

	# WDTCR: write invalid WDKEY to trigger reset
	mww phys [expr $timer2_phys + 0x28] 0x00004000
}
######################################
# Target:    Marvell Dragonite CPU core
######################################

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dragonite
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x121003d3
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME dragonite -endian $_ENDIAN -chain-position $_TARGETNAME

reset_config trst_and_srst
adapter srst delay 200
jtag_ntrst_delay 200
# Script for freescale DSP56321
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dsp56321
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a big endian
   set _ENDIAN big
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1181501d
}

#jtag speed
adapter speed 4500

#has only srst
reset_config srst_only

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x1 -expected-id $_CPUTAPID

#target configuration
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME dsp563xx -endian $_ENDIAN -chain-position $_TARGETNAME

#working area at base of ram
$_TARGETNAME configure -work-area-virt 0
# Script for freescale DSP568013

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dsp568013
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a big endian
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x01f2401d
}

#jtag speed
adapter speed 800

reset_config srst_only

#MASTER tap
jtag newtap $_CHIPNAME chp -irlen 8 -ircapture 1 -irmask 0x03 -expected-id $_CPUTAPID

#CORE tap
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x03 -disable -expected-id 0x02211004

#target configuration - There is only 1 tap at a time, hence only 1 target is defined.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME

# Setup the interesting tap
# Disable polling to be able to get idcode from core tap. If re enabled, can be re enabled, but it should be disabled to correctly unlock flash (operations require certain instruction to be in the IR register during reset, and polling would change this)
jtag configure $_CHIPNAME.chp -event setup "
     jtag tapenable $_TARGETNAME
     poll off
"

#select CORE tap by modifying the TLM register.
#to be used when MASTER tap is selected.
jtag configure $_TARGETNAME -event tap-enable "
     irscan $_CHIPNAME.chp 0x05;
     drscan $_CHIPNAME.chp 4 0x02;
     jtag tapdisable $_CHIPNAME.chp;
"

#select MASTER tap by modifying the TLM register.
#to be used when CORE tap is selected.
jtag configure $_CHIPNAME.chp -event tap-enable "
     irscan $_TARGETNAME 0x08;
     drscan $_TARGETNAME 4 0x1;
     jtag tapdisable $_TARGETNAME;
"

#disables the master tap
jtag configure $_TARGETNAME -event tap-disable "
"
#TODO FIND SMARTER WAY.

jtag configure $_CHIPNAME.chp -event tap-disable "
"
#TODO FIND SMARTER WAY.


#working area at base of ram
$_TARGETNAME configure -work-area-virt 0

#setup flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
# Script for freescale DSP568037

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dsp568037
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a big endian
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x01f2801d
}

#jtag speed
adapter speed 800

reset_config srst_only

#MASTER tap
jtag newtap $_CHIPNAME chp -irlen 8 -ircapture 1 -irmask 0x03 -expected-id $_CPUTAPID

#CORE tap
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x03 -disable -expected-id 0x02211004

#target configuration - There is only 1 tap at a time, hence only 1 target is defined.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME

# Setup the interesting tap
jtag configure $_CHIPNAME.chp -event setup "jtag tapenable $_TARGETNAME"

#select CORE tap by modifying the TLM register.
#to be used when MASTER tap is selected.
jtag configure $_TARGETNAME -event tap-enable "
     irscan $_CHIPNAME.chp 0x05;
     drscan $_CHIPNAME.chp 4 0x02;
     jtag tapdisable $_CHIPNAME.chp;
"

#select MASTER tap by modifying the TLM register.
#to be used when CORE tap is selected.
jtag configure $_CHIPNAME.chp -event tap-enable "
     irscan $_TARGETNAME 0x08;
     drscan $_TARGETNAME 4 0x1;
     jtag tapdisable $_TARGETNAME;
"

#disables the master tap
jtag configure $_TARGETNAME -event tap-disable "
"
#TODO FIND SMARTER WAY.

jtag configure $_CHIPNAME.chp -event tap-disable "
"
#TODO FIND SMARTER WAY.


#working area at base of ram
$_TARGETNAME configure -work-area-virt 0

#setup flash
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
#
# Silicon Labs (formerly Energy Micro) EFM32 target
#
# Note: All EFM32 chips have SWD support, but only newer series 1
# chips have JTAG support.
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME efm32
}

# Work-area is a space in RAM used for flash programming
# By default use 2kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

adapter speed 1000

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME efm32 0 0 0 0 $_TARGETNAME

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# Target configuration for the Silicon Labs EM357 chips
#

#
# em357 family supports JTAG and SWD transports
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME em357
}

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x3ba00477
   } else {
      set _CPUTAPID 0x1ba00477
   }
}

if { [info exists BSTAPID] } {
   set _BSTAPID $BSTAPID
} else {
  set _BSTAPID 0x069a962b
}

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME em358
}

if { [info exists FLASHSIZE] } {
    set _FLASHSIZE $FLASHSIZE
} else {
    set _FLASHSIZE 0x30000
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
if { [using_jtag] } {
    jtag newtap $_CHIPNAME bs -irlen 4 -expected-id $_BSTAPID -ircapture 0xe -irmask 0xf
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME em357 0x08000000 $_FLASHSIZE 0 0 $_TARGETNAME

if { ![using_hla]} {
# according to errata, we need to use vectreset rather than sysresetreq to avoid lockup
# There is a bug in the chip, which means that when using external debuggers the chip
# may lock up in certain CPU clock modes. Affected modes are operating the CPU at
# 24MHz derived from the 24MHz crystal, or 12MHz derived from the high frequency RC
# oscillator. If an external debugger tool asserts SYSRESETREQ, the chip will lock up and
# require a pin reset or power cycle.
#
# for details, refer to:
# http://www.silabs.com/Support%20Documents/TechnicalDocs/EM35x-Errata.pdf
    cortex_m reset_config vectreset
}
# Target configuration for the Silicon Labs EM358 chips

#
# em357 family supports JTAG and SWD transports
#

if { ![info exists CHIPNAME] } {
   set CHIPNAME em358
}

if { ![info exists BSTAPID] } {
  set BSTAPID 0x069aa62b
}

# 512K of flash in the em358 chips
set FLASHSIZE 0x80000
source [find target/em357.cfg]
# SPDX-License-Identifier: GPL-2.0-or-later
# QuickLogic EOS S3
# https://www.quicklogic.com/products/soc/eos-s3-microcontroller/

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME eos_s3
}

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x80000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

# For now we use SRAM only for software upload
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

adapter speed 4000

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# Cirrus Logic EP9301 processor on an Olimex CS-E9301 board.

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME ep9301
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   # Force an error until we get a good number.
   set _CPUTAPID 0xffffffff
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
adapter srst delay 100
jtag_ntrst_delay 100

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -work-area-phys 0x80014000 -work-area-size 0x1000 -work-area-backup 1

#flash configuration
#flash bank <driver> <base> <size> <chip_width> <bus_width> [driver_options ...]
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cfi 0x60000000 0x1000000 2 2 $_TARGETNAME
#
# EnSilica eSi-32xx SoC (eSi-RISC Family)
# http://www.ensilica.com/risc-ip/
#

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME esi32xx
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    set _CPUTAPID 0x11234001
}

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME esirisc -chain-position $_CHIPNAME.cpu

# Targets with the UNIFIED_ADDRESS_SPACE option disabled should set
# CACHEARCH to 'harvard'. By default, 'von_neumann' is assumed.
if { [info exists CACHEARCH] } {
    $_TARGETNAME esirisc cache_arch $CACHEARCH
}

adapter speed 2000

reset_config none

# The default linker scripts provided by the eSi-RISC toolchain do not
# specify attributes on memory regions, which results in incorrect
# application of software breakpoints by GDB.
gdb_breakpoint_override hard
#
# Samsung Exynos 5250 - dual-core ARM Cortex-A15
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME exynos5250
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create ${_TARGETNAME}0 cortex_a -dap $_CHIPNAME.dap
target create ${_TARGETNAME}1 cortex_a -dap $_CHIPNAME.dap

target smp ${_TARGETNAME}0 ${_TARGETNAME}1
#Script for faux target - used for testing

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME at91eb40a
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x00000000
}


jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

#target configuration
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

#dummy flash driver
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME faux 0x01000000 0x200000 2 2 $_TARGETNAME
######################################
# Target:    Marvell Feroceon CPU core
######################################

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME feroceon
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x20a023d3
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME feroceon -endian $_ENDIAN -chain-position $_TARGETNAME

reset_config trst_and_srst
adapter srst delay 200
jtag_ntrst_delay 200
# MB9BF506
# Fujitsu Cortex-M3 with 512kB Flash and 64kB RAM

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME mb9bfxx6
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x4ba00477
}

# delays on reset lines
adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

# Fujitsu Cortex-M3 reset configuration
reset_config trst_only

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# MB9BF506 has 64kB of SRAM on its main system bus
$_TARGETNAME configure -work-area-phys 0x1FFF8000 -work-area-size 0x10000 -work-area-backup 0

# MB9BF506 has 512kB internal FLASH

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME fm3 0 0 0 0 $_TARGETNAME

# 4MHz / 6 = 666kHz, so use 500
adapter speed 500

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# Spansion FM4 (ARM Cortex-M4)
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME fm4
}

source [find target/swj-dp.tcl]

if { [info exists CPUTAPID] } {
	set _CPU_TAPID $CPUTAPID
} elseif { [using_jtag] } {
	set _CPU_TAPID 0x4ba00477
} else {
	set _CPU_TAPID 0x2ba01477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap

adapter speed 500

if {![using_hla]} {
	cortex_m reset_config sysresetreq
}
#
# Spansion FM4 MB9BFxxx (ARM Cortex-M4)
#

source [find target/fm4.cfg]

# MB9BF566 M/N/R have 32 KB SRAM0
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x8000
}

$_TARGETNAME configure -work-area-phys [expr 0x20000000 - $_WORKAREASIZE] \
                       -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME fm4 0x00000000 0 0 0 $_TARGETNAME $CHIPSERIES
#
# Spansion FM4 S6E2CC (ARM Cortex-M4)
#

source [find target/fm4.cfg]

# S6E2CC8 H/J/L have 96 KB SRAM0
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x18000
}

$_TARGETNAME configure -work-area-phys [expr 0x20000000 - $_WORKAREASIZE] \
                       -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank ${_FLASHNAME}0 fm4 0x00000000 0 0 0 $_TARGETNAME $CHIPSERIES
flash bank ${_FLASHNAME}1 fm4 0x00100000 0 0 0 $_TARGETNAME $CHIPSERIES
#
# GigaDevice GD32VF103 target
#
# https://www.gigadevice.com/products/microcontrollers/gd32/risc-v/
#

transport select jtag

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME gd32vf103
}

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x1000563d

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME riscv -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
#
# Support for General Plus GP326XXXA chips
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME gp326xxxa
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4f1f0f0f
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

# Use internal SRAM as a work area
$_TARGETNAME configure -work-area-phys 0xf8000000 -work-area-size 0x8000 -work-area-backup 0

# The chip has both lines connected together
reset_config trst_and_srst srst_pulls_trst
# This delay is needed otherwise communication with the target would
# be unreliable
adapter srst delay 100

# Set the adapter speed ridiculously low just in case we are
# running off of a 32kHz clock
adapter speed 2

proc gp32xxxa_halt_and_reset_control_registers {} {
	# System control registers
	set P_SYSTEM_CTRL_NEW       0xD0000008
	set P_SYSTEM_CTRL           0xD000000C
	set P_SYSTEM_CLK_EN0        0xD0000010
	set P_SYSTEM_CLK_EN1        0xD0000014
	set P_SYSTEM_RESET_FLAG     0xD0000018
	set P_SYSTEM_CLK_CTRL       0xD000001C
	set P_SYSTEM_LVR_CTRL       0xD0000020
	set P_SYSTEM_WATCHDOG_CTRL  0xD0000024
	set P_SYSTEM_PLLEN          0xD000005C

	# Since we can't use SRST without pulling TRST
	# we can't assume the state of the clock configuration
	# or watchdog settings. So reset them before porceeding

	# Set the adapter speed ridiculously low just in case we are
	# running off of a 32kHz clock
	adapter speed 2

	# Disable any advanced features at this stage
	arm7_9 dcc_downloads disable
	arm7_9 fast_memory_access disable

	# Do a "soft reset"
	soft_reset_halt
	# Reset all system control registers to their default "after-reset" values
	mwh $P_SYSTEM_WATCHDOG_CTRL  0x0000
	mwh $P_SYSTEM_LVR_CTRL       0x0000

	mwh $P_SYSTEM_CTRL_NEW       0x0001
	mwh $P_SYSTEM_CTRL           0x0001
	# Clear all reset flags by writing 1's
	mwh $P_SYSTEM_RESET_FLAG     0x001C

	mwh $P_SYSTEM_CLK_CTRL       0x8000
	mwh $P_SYSTEM_CLK_EN0        0xFFFF
	mwh $P_SYSTEM_CLK_EN1        0xFFFF
	mwh $P_SYSTEM_PLLEN          0x0010

	# Unfortunately there's no register that would allow us to
	# know if PLL is locked. So just wait for 100ms in hopes that
	# it would be enough.
	sleep 100

	# Now that we know that we are running at 48Mhz
	# Increase JTAG speed and enable speed optimization features
	adapter speed 5000
	arm7_9 dcc_downloads enable
	arm7_9 fast_memory_access enable
}

$_TARGETNAME configure -event reset-end { gp32xxxa_halt_and_reset_control_registers }
# Hisilicon Hi3798 Target

if { [info exists CHIPNAME] } {
  set _CHIPNAME $CHIPNAME
} else {
  set _CHIPNAME hi3798
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x5ba00477
}

# declare the one JTAG tap to access the DAP
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -ignore-version -enable
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
# declare the 4 main application cores
set _TARGETNAME $_CHIPNAME.cpu
set _smp_command ""

set $_TARGETNAME.cti(0) 0x80020000
set $_TARGETNAME.cti(1) 0x80120000
set $_TARGETNAME.cti(2) 0x80220000
set $_TARGETNAME.cti(3) 0x80320000

set _cores 4
for { set _core 0 } { $_core < $_cores } { incr _core 1 } {

    cti create cti$_core -dap $_CHIPNAME.dap -baseaddr [set $_TARGETNAME.cti($_core)] -ap-num 0

    set _command "target create ${_TARGETNAME}$_core aarch64 \
                         -dap $_CHIPNAME.dap -coreid $_core -cti cti$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        #set _command "$_command -defer-examine"
        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
    } else {
        # uncomment when "hawt" rtos is merged
        # set _command "$_command -rtos hawt"
        set _smp_command "target smp ${_TARGETNAME}$_core"
    }

    eval $_command
}

eval $_smp_command
# Hisilicon Hi6220 Target

if { [info exists CHIPNAME] } {
  set _CHIPNAME $CHIPNAME
} else {
  set _CHIPNAME hi6220
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x4ba00477
}

# declare the one JTAG tap to access the DAP
jtag newtap $_CHIPNAME tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -ignore-version

# create the DAP
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap

# declare the 8 main application cores
set _TARGETNAME $_CHIPNAME.cpu
set _smp_command ""

set $_TARGETNAME.cti(0) 0x80198000
set $_TARGETNAME.cti(1) 0x80199000
set $_TARGETNAME.cti(2) 0x8019A000
set $_TARGETNAME.cti(3) 0x8019B000
set $_TARGETNAME.cti(4) 0x801D8000
set $_TARGETNAME.cti(5) 0x801D9000
set $_TARGETNAME.cti(6) 0x801DA000
set $_TARGETNAME.cti(7) 0x801DB000

set _cores 8
for { set _core 0 } { $_core < $_cores } { incr _core 1 } {

    cti create cti$_core -dap $_CHIPNAME.dap -baseaddr [set $_TARGETNAME.cti($_core)] -ap-num 0

    set _command "target create ${_TARGETNAME}$_core aarch64 \
                         -dap $_CHIPNAME.dap -coreid $_core -cti cti$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        set _command "$_command -defer-examine"
        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
    } else {
        # uncomment when "hawt" rtos is merged
        # set _command "$_command -rtos hawt"
        set _smp_command "target smp ${_TARGETNAME}$_core"
    }

    eval $_command
}

eval $_smp_command

cti create cti.sys -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0x80003000

# declare the auxiliary Cortex-M3 core on AP #2 (runs mcuimage.bin)
target create ${_TARGETNAME}.m3 cortex_m -dap $_CHIPNAME.dap -ap-num 2 -defer-examine

# declare the auxiliary Cortex-A7 core
target create ${_TARGETNAME}.a7 cortex_a -dap $_CHIPNAME.dap -dbgbase 0x80210000 -defer-examine
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

#Hilscher netX 10 CPU

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME netx10
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x25966021
}

# jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# that TAP is associated with a target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
################################################################################
# Author: Michael Trensch (MTrensch@googlemail.com)
################################################################################

#Hilscher netX 50 CPU

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME netx50
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x25966021
}

# jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# that TAP is associated with a target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME

# On netX50 SDRAM is not accessible at offset 0xDEAD0-0xDEADF as it is busy from
# DMA controller at init. This function will setup a dummy DMA to free this ares
# and must be called before using SDRAM
proc sdram_fix { } {

  mww 0x1c005830 0x00000001

  mww 0x1c005104 0xBFFFFFFC
  mww 0x1c00510c 0x00480001
  mww 0x1c005110 0x00000001

  sleep 100

  mww 0x1c00510c 0
  mww 0x1c005110 0
  mww 0x1c005830 0x00000000

	puts "SDRAM Fix executed!"
}
#Hilscher netX 500 CPU

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME netx500
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926021
}

# jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# that TAP is associated with a target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

proc mread32 {addr} {
  set value(0) 0
  mem2array value 32 $addr 1
  return $value(0)
}

# This function must be called on netX100/500 right after halt
# If it is called later the needed register cannot be written anymore
proc sdram_fix { } {

  set accesskey [mread32 0x00100070]
  mww 0x00100070 [expr $accesskey]
  mww 0x0010002c 0x00000001

  if {[expr [mread32 0x0010002c] & 0x07] == 0x07} {
	 puts "SDRAM Fix was not executed. Probably your CPU halted too late and the register is already locked!"
  } else {
	 puts "SDRAM Fix succeeded!"
  }
}
#
# Copyright (C)   2011        by Karl Kurbjun
# Copyright (C)   2009        by David Brownell
#

# Utilities for TI ICEpick-C/D used in most TI SoCs
# Details about the ICEPick are available in the the TRM for each SoC
# and http://processors.wiki.ti.com/index.php/ICEPICK

# create "constants"
proc CONST { key } {

	array set constant {
		# define ICEPick instructions
		IR_BYPASS   0x00
		IR_ROUTER   0x02
		IR_CONNECT  0x07
		IF_BYPASS   0x3F
	}
	return $constant($key)
}

# Instruction to connect to the icepick module
proc icepick_c_connect {jrc} {

	# Send CONNECT instruction in IR state
	irscan $jrc [CONST IR_CONNECT] -endstate IRPAUSE

	# Send write and connect key
	drscan $jrc 8 0x89 -endstate DRPAUSE
}

# Instruction to disconnect to the icepick module
proc icepick_c_disconnect {jrc} {

	# Send CONNECT instruction in IR state
	irscan $jrc [CONST IR_CONNECT] -endstate IRPAUSE

	# Send write and connect key
	drscan $jrc 8 0x86 -endstate DRPAUSE
}

#
# icepick_c_router:
#  this function is for sending router commands
# arguments are:
#  jrc:        TAP name for the ICEpick
#  rw:         read/write (0 for read, 1 for write)
#  block:      icepick or DAP
#  register:   which register to read/write
#  payload:    value to read/write
# this function is for sending router commands
#
proc icepick_c_router {jrc rw block register payload} {

	set new_dr_value \
		[expr ( ($rw & 0x1) << 31)        | ( ($block & 0x7) << 28) | \
			( ($register & 0xF) << 24)  | ( $payload & 0xFFFFFF ) ]

#	echo "\tNew router value:\t0x[format %x $new_dr_value]"

	# select router
	irscan $jrc [CONST IR_ROUTER] -endstate IRPAUSE

	# ROUTER instructions are 32 bits wide
	set old_dr_value 0x[drscan $jrc 32 $new_dr_value -endstate DRPAUSE]
#	echo "\tOld router value:\t0x[format %x $old_dr_value]"
}

# Configure the icepick control register
proc icepick_c_setup {jrc} {

	# send a router write, block is 0, register is 1, value is 0x2100
	icepick_c_router $jrc 1 0x0 0x1 0x001000
}

# jrc	== TAP name for the ICEpick
# port	== a port number, 0..15 for debug tap, 16..31 for test tap
proc icepick_c_tapenable {jrc port} {

	if { ($port >= 0) && ($port < 16) } {
		# Debug tap"
		set tap $port
		set block 0x2
	} elseif { $port < 32 } {
		# Test tap
		set tap [expr ($port - 16)]
		set block 0x1
	} else {
		echo "ERROR: Invalid ICEPick C port number: $port"
		return
	}

	# First CONNECT to the ICEPick
#	echo "Connecting to ICEPick"
	icepick_c_connect $jrc

#	echo "Configuring the ICEpick"
	icepick_c_setup $jrc

	# NOTE: it's important not to enter RUN/IDLE state until
	# done sending these instructions and data to the ICEpick.
	# And never to enter RESET, which will disable the TAPs.

	# first enable power and clock for TAP
	icepick_c_router $jrc 1 $block $tap 0x110048

	# TRM states that the register should be read back here, skipped for now

	# enable debug "default" mode
	icepick_c_router $jrc 1 $block $tap 0x112048

	# TRM states that debug enable and debug mode should be read back and
	# confirmed - skipped for now

	# Finally select the tap
	icepick_c_router $jrc 1 $block $tap 0x112148

	# Enter the bypass state
	irscan $jrc [CONST IR_BYPASS] -endstate RUN/IDLE
	runtest 10
}

# jrc	== TAP name for the ICEpick
# coreid== core id number 0..15 (not same as port number!)
proc icepick_d_set_core_control {jrc coreid value } {
	icepick_c_router $jrc 1 0x6 $coreid $value
}

# jrc	== TAP name for the ICEpick
# port	== a port number, 0..15
# Follow the sequence described in
# http://processors.wiki.ti.com/images/f/f6/Router_Scan_Sequence-ICEpick-D.pdf
proc icepick_d_tapenable {jrc port coreid { value 0x2008 } } {

	# First CONNECT to the ICEPick
	icepick_c_connect $jrc
	icepick_c_setup $jrc

	# Select the port
	icepick_c_router $jrc 1 0x2 $port 0x2108

	# Set icepick core control for $coreid
	icepick_d_set_core_control $jrc $coreid $value

	# Enter the bypass state
	irscan $jrc [CONST IF_BYPASS] -endstate RUN/IDLE
	runtest 10
}

# This function uses the ICEPick to send a warm system reset
proc icepick_c_wreset {jrc} {

	# send a router write, block is 0, register is 1, value is 0x2100
	icepick_c_router $jrc 1 0x0 0x1 0x002101
}
# utility fn's for Freescale i.MX series

global TARGETNAME
set TARGETNAME $_TARGETNAME

# rewrite commands of the form below to arm11 mcr...
#	Data.Set c15:0x042f %long 0x40000015
proc setc15 {regs value} {
	global TARGETNAME

	echo [format "set p15 0x%04x, 0x%08x" $regs $value]

	arm mcr 15 [expr ($regs>>12)&0x7] [expr ($regs>>0)&0xf] [expr ($regs>>4)&0xf] [expr ($regs>>8)&0x7] $value
}


proc imx3x_reset {} {
	# this reset script comes from the Freescale PDK
	#
	# http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=IMX35PDK

	echo "Target Setup: initialize DRAM controller and peripherals"

#	Data.Set c15:0x01 %long 0x00050078
	setc15 0x01 0x00050078

	echo "configuring CP15 for enabling the peripheral bus"
#	Data.Set c15:0x042f %long 0x40000015
	setc15 0x042f 0x40000015
}
#use combined on interfaces or targets that can't set TRST/SRST separately
#
# Hmmm.... should srst_pulls_trst be used here like i.MX27???
reset_config trst_and_srst

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx21
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}


# Note above there is 1 tap

# The CPU tap
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0792611f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID


# Create the GDB Target.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

arm7_9 dcc_downloads enable
#
# imx25 config
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx25
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists ETBTAPID] } {
   set _ETBTAPID $ETBTAPID
} else {
   set _ETBTAPID 0x1b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0x0f -expected-id $_ETBTAPID

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926041
}
jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0x0 -irmask 0x0 -expected-id 0x0

if { [info exists SDMATAPID] } {
   set _SDMATAPID $SDMATAPID
} else {
   set _SDMATAPID 0x0882301d
}
jtag newtap $_CHIPNAME sdma -irlen 5 -expected-id $_SDMATAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN \
		-chain-position $_TARGETNAME

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
# page 3-34 of "MCIMC27 Multimedia Applications Processor Reference Manual, Rev 0.3"
# SRST pulls TRST
#
# Without setting these options correctly you'll see all sorts
# of weird errors, e.g. MOE=0xe, invalid cpsr values, reset
# failing, etc.
reset_config trst_and_srst srst_pulls_trst

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx27
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}


# Note above there are 2 taps

# trace buffer
if { [info exists ETBTAPID] } {
   set _ETBTAPID $ETBTAPID
} else {
   set _ETBTAPID 0x1b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETBTAPID

# The CPU tap
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926121
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# Create the GDB Target.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
# REVISIT what operating environment sets up this virtual address mapping?
$_TARGETNAME configure -work-area-virt 0xffff4c00 -work-area-phys 0xffff4c00 \
	-work-area-size 0x8000 -work-area-backup 1
# Internal to the chip, there is 45K of SRAM
#

arm7_9 dcc_downloads enable

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
# i.MX28 config file.
# based off of the imx21.cfg file.

reset_config trst_and_srst

#jtag nTRST and nSRST delay
adapter srst delay 100
jtag_ntrst_delay 100

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME imx28
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}


# Note above there is 1 tap

# The CPU tap
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x079264f3
}
jtag newtap $_CHIPNAME cpu  -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID


# Create the GDB Target.
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

arm7_9 dcc_downloads enable
# imx31 config
#

reset_config trst_and_srst srst_gates_jtag

adapter srst delay 5

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx31
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07b3601d
}

if { [info exists SDMATAPID] } {
   set _SDMATAPID $SDMATAPID
} else {
   set _SDMATAPID 0x2190101d
}

if { [info exists ETBTAPID] } {
   set _ETBTAPID $ETBTAPID
} else {
   set _ETBTAPID 0x2b900f0f
}

#========================================

jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETBTAPID

# The "SDMA" - <S>mart <DMA> controller debug tap
# Based on some IO pins - this can be disabled & removed
# See diagram: 6-14
#   SIGNAL NAME:
#    SJC_MOD - controls multiplexer - disables ARM1136
#    SDMA_BYPASS - disables SDMA    -
#
# Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

# No IDCODE for this TAP
jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0xf -expected-id 0x0

# Per section 40.17.1, table 40-85 the IR register is 4 bits
# But this conflicts with Diagram 6-13, "3bits ir and drs"
jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME


proc power_restore {} { echo "Sensed power restore. No action." }
proc srst_deasserted {} { echo "Sensed nSRST deasserted. No action." }

# trace setup ... NOTE, "normal full" mode fudges the real ETMv3.1 mode
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
# imx35 config
#

reset_config trst_and_srst srst_gates_jtag
jtag_ntrst_delay 100

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx35
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07b3601d
}

if { [info exists SDMATAPID] } {
   set _SDMATAPID $SDMATAPID
} else {
   set _SDMATAPID 0x0882601d
}

if { [info exists ETBTAPID] } {
   set _ETBTAPID $ETBTAPID
} else {
   set _ETBTAPID 0x2b900f0f
}

#========================================

jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETBTAPID
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

# No IDCODE for this TAP
jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0x0 -expected-id 0x0

jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME

proc power_restore {} { echo "Sensed power restore. No action." }
proc srst_deasserted {} { echo "Sensed nSRST deasserted. No action." }

# trace setup ... NOTE, "normal full" mode fudges the real ETMv3.1 mode
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
# Freescale i.MX51

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx51
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x1ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf \
        -expected-id $_DAP_TAPID

# SDMA / no IDCODE
jtag newtap $_CHIPNAME sdma -irlen 4 -ircapture 0x0 -irmask 0xf

# SJC
if { [info exists SJC_TAPID] } {
   set _SJC_TAPID SJC_TAPID
} else {
   set _SJC_TAPID 0x0190c01d
}

jtag newtap $_CHIPNAME sjc -irlen 5 -ircapture 0x1 -irmask 0x1f \
        -expected-id $_SJC_TAPID -ignore-version

# GDB target: Cortex-A8, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap

# some TCK tycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.sjc -event post-reset "runtest 100"

proc imx51_dbginit {target} {
     # General Cortex-A8 debug initialisation
     cortex_a dbginit
}

$_TARGETNAME configure -event reset-assert-post "imx51_dbginit $_TARGETNAME"
# Freescale i.MX53

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME imx53
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x1ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf \
        -expected-id $_DAP_TAPID

# SDMA / no IDCODE
jtag newtap $_CHIPNAME sdma -irlen 4 -ircapture 0x0 -irmask 0xf

# SJC
if { [info exists SJC_TAPID] } {
   set _SJC_TAPID SJC_TAPID
} else {
   set _SJC_TAPID 0x0190d01d
}

jtag newtap $_CHIPNAME sjc -irlen 5 -ircapture 0x1 -irmask 0x1f \
        -expected-id $_SJC_TAPID -ignore-version

# GDB target: Cortex-A8, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap

# some TCK tycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.sjc -event post-reset "runtest 100"

proc imx53_dbginit {target} {
     # General Cortex-A8 debug initialisation
     cortex_a dbginit
}

$_TARGETNAME configure -event reset-assert-post "imx53_dbginit $_TARGETNAME"
#
# Freescale i.MX6 series
#
# Supports 6Q 6D 6QP 6DP 6DL 6S 6SL 6SLL
#
# Some imx6 chips have Cortex-A7 or an Cortex-M and need special handling
#

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME imx6
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

# SDMA / no IDCODE
jtag newtap $_CHIPNAME sdma -irlen 4 -ircapture 0x00 -irmask 0x0f

# System JTAG Controller

# List supported SJC TAPIDs from imx reference manuals:
set _SJC_TAPID_6Q   0x0191c01d
set _SJC_TAPID_6D   0x0191e01d
set _SJC_TAPID_6QP  0x3191c01d
set _SJC_TAPID_6DP  0x3191d01d
set _SJC_TAPID_6DL  0x0891a01d
set _SJC_TAPID_6S   0x0891b01d
set _SJC_TAPID_6SL  0x0891f01d
set _SJC_TAPID_6SLL 0x088c201d

# Allow external override of the first SJC TAPID
if { [info exists SJC_TAPID] } {
    set _SJC_TAPID $SJC_TAPID
} else {
    set _SJC_TAPID $_SJC_TAPID_6Q
}

jtag newtap $_CHIPNAME sjc -irlen 5 -ircapture 0x01 -irmask 0x1f \
        -ignore-version \
        -expected-id $_SJC_TAPID \
        -expected-id $_SJC_TAPID_6QP \
        -expected-id $_SJC_TAPID_6DP \
        -expected-id $_SJC_TAPID_6D \
        -expected-id $_SJC_TAPID_6DL \
        -expected-id $_SJC_TAPID_6S \
        -expected-id $_SJC_TAPID_6SL \
        -expected-id $_SJC_TAPID_6SLL

# GDB target: Cortex-A9, using DAP, configuring only one core
# Base addresses of cores:
# core 0  -  0x82150000
# core 1  -  0x82152000
# core 2  -  0x82154000
# core 3  -  0x82156000
set _TARGETNAME $_CHIPNAME.cpu.0
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap \
        -coreid 0 -dbgbase 0x82150000

# some TCK cycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.sjc -event post-reset "runtest 100"

proc imx6_dbginit {target} {
        # General Cortex-A8/A9 debug initialisation
        cortex_a dbginit
}

# Slow speed to be sure it will work
adapter speed 1000
$_TARGETNAME configure -event reset-start { adapter speed 1000 }

$_TARGETNAME configure -event reset-assert-post "imx6_dbginit $_TARGETNAME"
#
# Freescale i.MX6SoloX
#

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME imx6sx
}

# 2x CoreSight Debug Access Port for Cortex-M4 and Cortex-A9
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu_m4 -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap_m4 -chain-position $_CHIPNAME.cpu_m4

jtag newtap $_CHIPNAME cpu_a9 -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap_a9 -chain-position $_CHIPNAME.cpu_a9

# SDMA / no IDCODE
jtag newtap $_CHIPNAME sdma -irlen 4 -ircapture 0x00 -irmask 0x0f

# System JTAG Controller
if { [info exists SJC_TAPID] } {
    set _SJC_TAPID $SJC_TAPID
} else {
    set _SJC_TAPID 0x0891c01d
}
jtag newtap $_CHIPNAME sjc -irlen 5 -ircapture 0x01 -irmask 0x1f \
        -expected-id $_SJC_TAPID -ignore-version

# Cortex-A9 (boot core)
target create $_CHIPNAME.cpu_a9 cortex_a -dap $_CHIPNAME.dap_a9 \
        -coreid 0 -dbgbase 0x82150000

# Cortex-M4 (default off)
target create $_CHIPNAME.cpu_m4 cortex_m -dap $_CHIPNAME.dap_m4 \
        -ap-num 0 -defer-examine

# AHB mem-ap target
target create $_CHIPNAME.ahb mem_ap -dap $_CHIPNAME.dap_a9 -ap-num 0

# Default target is Cortex-A9
targets $_CHIPNAME.cpu_a9
#
# Freescale i.MX6UltraLite series: 6UL 6ULL 6ULZ
#

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME imx6ul
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

# SDMA / no IDCODE
jtag newtap $_CHIPNAME sdma -irlen 4 -ircapture 0x00 -irmask 0x0f

# System JTAG Controller
set _SJC_TAPID_6UL  0x0891d01d
set _SJC_TAPID_6ULL 0x0891e01d
set _SJC_TAPID_6ULZ 0x1891e01d

# Allow external override of the first SJC TAPID
if { [info exists SJC_TAPID] } {
    set _SJC_TAPID $SJC_TAPID
} else {
    set _SJC_TAPID $_SJC_TAPID_6UL
}

jtag newtap $_CHIPNAME sjc -irlen 5 -ircapture 0x01 -irmask 0x1f \
        -ignore-version \
        -expected-id $_SJC_TAPID \
        -expected-id $_SJC_TAPID_6ULL \
        -expected-id $_SJC_TAPID_6ULZ \

# Create DAP
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Main AHB bus
target create $_CHIPNAME.ahb mem_ap -dap $_CHIPNAME.dap -ap-num 0

# Cortex-A7 single core
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap -dbgbase 0x82130000
if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME imx7
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
        set _DAP_TAPID $DAP_TAPID
} else {
        set _DAP_TAPID 0x5ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

#
# Cortex-A7 target
#
# GDB target: Cortex-A7, using DAP, configuring only one core
# Base addresses of cores:
# core 0  -  0x80070000
# core 1  -  0x80072000
set _TARGETNAME $_CHIPNAME.cpu_a7

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME.0 cortex_a -dap $_CHIPNAME.dap \
        -coreid 0 -dbgbase 0x80070000

target create $_TARGETNAME.1 cortex_a -dap $_CHIPNAME.dap \
        -coreid 1 -dbgbase 0x80072000 -defer-examine
#
# Cortex-M4 target
#
set _TARGETNAME_2 $_CHIPNAME.cpu_m4
target create $_TARGETNAME_2 cortex_m -dap $_CHIPNAME.dap -ap-num 4 \
        -defer-examine

#
# AHB mem-ap target
#
target create $_CHIPNAME.ahb mem_ap -dap $_CHIPNAME.dap -ap-num 0

targets $_TARGETNAME.0
#
# NXP i.MX7ULP: Cortex-A7 + Cortex-M4
#

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME imx7ulp
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    # TAPID is from FreeScale!
    set _DAP_TAPID 0x188e101d
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Cortex-A7
target create $_CHIPNAME.cpu_a7 cortex_a -dap $_CHIPNAME.dap \
        -coreid 0 -dbgbase 0x80030000

# Cortex-M4
# Boots by default so don't defer examination
target create $_CHIPNAME.cpu_m4 cortex_m -dap $_CHIPNAME.dap -ap-num 3

# AHB main soc bus
target create $_CHIPNAME.ahb mem_ap -dap $_CHIPNAME.dap -ap-num 0

# Default is Cortex-A7
targets $_CHIPNAME.cpu_a7
#
# configuration file for NXP i.MX8M family of SoCs
#
if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME imx8m
}

if { [info exists CHIPCORES] } {
    set _cores $CHIPCORES
} else {
    set _cores 1
}

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
        set _DAP_TAPID $DAP_TAPID
} else {
        set _DAP_TAPID 0x5ba00477
}

# the DAP tap
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f \
        -expected-id $_DAP_TAPID

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.a53
set _CTINAME $_CHIPNAME.cti

set DBGBASE {0x80410000 0x80510000 0x80610000 0x80710000}
set CTIBASE {0x80420000 0x80520000 0x80620000 0x80720000}

for { set _core 0 } { $_core < $_cores } { incr _core } {

    cti create $_CTINAME.$_core -dap $_CHIPNAME.dap -ap-num 1 \
        -baseaddr [lindex $CTIBASE $_core]

    set _command "target create $_TARGETNAME.$_core aarch64 -dap $_CHIPNAME.dap \
        -dbgbase [lindex $DBGBASE $_core] -cti $_CTINAME.$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        set _command "$_command -defer-examine"
        set _smp_command "$_smp_command $_TARGETNAME.$_core"
    } else {
        set _smp_command "target smp $_TARGETNAME.$_core"
    }

    eval $_command
}

eval $_smp_command

# declare the auxiliary Cortex-M4 core on AP #4
target create ${_CHIPNAME}.m4 cortex_m -dap ${_CHIPNAME}.dap -ap-num 4 \
               -defer-examine

# AHB-AP for direct access to soc bus
target create ${_CHIPNAME}.ahb mem_ap -dap ${_CHIPNAME}.dap -ap-num 0

# default target is A53 core 0
targets $_TARGETNAME.0
#
# Infineon TLE987x family (Arm Cortex-M3 @ up to 40 MHz)
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME tle987x
}

source [find target/swj-dp.tcl]

if { [info exists CPU_SWD_TAPID] } {
	set _CPU_SWD_TAPID $CPU_SWD_TAPID
} else {
	set _CPU_SWD_TAPID 0x2BA01477
}

if { [using_jtag] } {
	# JTAG not supported, only SWD
	set _CPU_TAPID 0
} else {
	set _CPU_TAPID $_CPU_SWD_TAPID
}

swj_newdap $_CHIPNAME dap -irlen 4 -expected-id $_CPU_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.dap

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { ![using_hla] } {
	cortex_m reset_config sysresetreq
}

adapter speed 1000
# script for Insilica IS-5114
# AKA: Atmel AT76C114 - an ARM946 chip
# ATMEL sold his product line to Insilica...

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME is5114
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a little endian
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   # Force an error until we get a good number.
   set _CPUTAPID 0xffffffff
}

# jtag speed. We need to stick to 16kHz until we've finished reset.
adapter speed 16

reset_config trst_and_srst

# Do not specify a tap id here...
jtag newtap $_CHIPNAME unknown1 -irlen 8 -ircapture 0x01 -irmask 1
# This is the "arm946" chip.
jtag newtap $_CHIPNAME cpu      -irlen 4 -ircapture 0x0e -irmask 0xf
jtag newtap $_CHIPNAME unknown2 -irlen 5 -ircapture 1 -irmask 1


#arm946e-s and
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-start { adapter speed 16 }
$_TARGETNAME configure -event reset-init {
	# We can increase speed now that we know the target is halted.
	adapter speed 3000
}
$_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 1
#xscale ixp42x CPU

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME ixp42x
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a bigendian
   set _ENDIAN big
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x19274013
}
set _CPUTAPID2 0x19275013
set _CPUTAPID3 0x19277013
set _CPUTAPID4 0x29274013
set _CPUTAPID5 0x29275013
set _CPUTAPID6 0x29277013

jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID -expected-id $_CPUTAPID2 -expected-id $_CPUTAPID3 -expected-id $_CPUTAPID4 -expected-id $_CPUTAPID5 -expected-id $_CPUTAPID6

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME


# register constants for IXP42x SDRAM controller
global IXP425_SDRAM_IR_MODE_SET_CAS2_CMD
global IXP425_SDRAM_IR_MODE_SET_CAS3_CMD
set IXP425_SDRAM_IR_MODE_SET_CAS2_CMD	0x0000
set IXP425_SDRAM_IR_MODE_SET_CAS3_CMD	0x0001

global IXP42x_SDRAM_CL3
global IXP42x_SDRAM_CL2
set IXP42x_SDRAM_CL3			0x0008
set IXP42x_SDRAM_CL2			0x0000

global IXP42x_SDRAM_8MB_2Mx32_1BANK
global IXP42x_SDRAM_16MB_2Mx32_2BANK
global IXP42x_SDRAM_16MB_4Mx16_1BANK
global IXP42x_SDRAM_32MB_4Mx16_2BANK
global IXP42x_SDRAM_32MB_8Mx16_1BANK
global IXP42x_SDRAM_64MB_8Mx16_2BANK
global IXP42x_SDRAM_64MB_16Mx16_1BANK
global IXP42x_SDRAM_128MB_16Mx16_2BANK
global IXP42x_SDRAM_128MB_32Mx16_1BANK
global IXP42x_SDRAM_256MB_32Mx16_2BANK

set IXP42x_SDRAM_8MB_2Mx32_1BANK	0x0030
set IXP42x_SDRAM_16MB_2Mx32_2BANK	0x0031
set IXP42x_SDRAM_16MB_4Mx16_1BANK	0x0032
set IXP42x_SDRAM_32MB_4Mx16_2BANK	0x0033
set IXP42x_SDRAM_32MB_8Mx16_1BANK	0x0010
set IXP42x_SDRAM_64MB_8Mx16_2BANK	0x0011
set IXP42x_SDRAM_64MB_16Mx16_1BANK	0x0012
set IXP42x_SDRAM_128MB_16Mx16_2BANK	0x0013
set IXP42x_SDRAM_128MB_32Mx16_1BANK	0x0014
set IXP42x_SDRAM_256MB_32Mx16_2BANK	0x0015


# helper function to init SDRAM on IXP42x.
# SDRAM_CFG: one of IXP42X_SDRAM_xxx
# REFRESH: refresh counter reload value (integer)
# CASLAT: 2 or 3
proc ixp42x_init_sdram { SDRAM_CFG REFRESH CASLAT } {

    switch $CASLAT {
	2 {
	    set SDRAM_CFG [expr $SDRAM_CFG | $::IXP42x_SDRAM_CL2 ]
	    set CASCMD $::IXP425_SDRAM_IR_MODE_SET_CAS2_CMD
	}
	3 {
	    set SDRAM_CFG [expr $SDRAM_CFG | $::IXP42x_SDRAM_CL3 ]
	    set CASCMD $::IXP425_SDRAM_IR_MODE_SET_CAS3_CMD
	}
	default { error [format "unsupported cas latency \"%s\" " $CASLAT] }
    }
    echo [format "\tIXP42x SDRAM Config: 0x%x, Refresh %d " $SDRAM_CFG $REFRESH]

    mww 0xCC000000 $SDRAM_CFG ;# SDRAM_CFG: 0x2A: 64MBit, CL3
    mww 0xCC000004          0 ;# disable refresh
    mww 0xCC000008          3 ;# NOP
    sleep 100
    mww 0xCC000004   $REFRESH ;# set refresh counter
    mww 0xCC000008          2 ;# Precharge All Banks
    sleep 100
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008          4 ;# Auto Refresh
    mww 0xCC000008    $CASCMD ;# Mode Select CL2/CL3
}

proc ixp42x_set_bigendian { } {
    reg XSCALE_CTRL 0xF8
}
# K1921VK01T
# http://niiet.ru/chips/nis?id=354

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME k1921vk01t
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      # SWD IDCODE
      set _CPUTAPID 0x2ba01477
   }
}
swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

flash bank $_CHIPNAME.flash niietcm4 0 0 0 0 $_TARGETNAME

adapter speed 2000

adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# Freescale Kinetis K40 devices
#

set CHIPNAME k40
source [find target/kx.cfg]
#
# Freescale Kinetis K60 devices
#

set CHIPNAME k60
source [find target/kx.cfg]
#
# Freescale Kinetis KE0x and KEAx series devices
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME ke
}

# Work-area is a space in RAM used for flash programming
# By default use 1kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x400
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bc11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME kinetis_ke 0 0 0 0 $_TARGETNAME

adapter speed 1000

reset_config srst_nogate

if {![using_hla]} {

   # It is important that "kinetis_ke mdm check_security" is called for
   # 'examine-end' event and not 'eximine-start'. Calling it in 'examine-start'
   # causes "kinetis_ke mdm check_security" to fail the first time openocd
   # calls it when it tries to connect after the CPU has been power-cycled.
   $_CHIPNAME.cpu configure -event examine-end {
      kinetis_ke mdm check_security
   }

   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# NXP (Freescale) Kinetis KE1xF devices
#

set CHIPNAME ke

source [find target/kx.cfg]
#
# NXP (Freescale) Kinetis KE1xZ devices
#

set CHIPNAME ke

source [find target/klx.cfg]
#
# Freescale Kinetis KL25 devices
#

set CHIPNAME kl25
source [find target/klx.cfg]
#
# Freescale Kinetis KL46 devices
#

set CHIPNAME kl46
source [find target/klx.cfg]
#
# NXP (former Freescale) Kinetis KL series devices
# Also used for Cortex-M0+ equipped members of KVx and KE1xZ series
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME klx
}

# Work-area is a space in RAM used for flash programming
# By default use 1KiB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x400
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    set _CPUTAPID 0x0bc11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.pflash
flash bank $_FLASHNAME kinetis 0 0 0 0 $_TARGETNAME
kinetis create_banks

# Table 5-1. Clock Summary of KL25 Sub-Family Reference Manual
# specifies up to 1MHz for VLPR mode and up to 24MHz for run mode;
# Table 17 of Sub-Family Data Sheet rev4 lists 25MHz as the maximum frequency.
adapter speed 1000

reset_config srst_nogate

if {[using_hla]} {
   echo ""
   echo "!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!"
   echo " Kinetis MCUs have a MDM-AP dedicated mainly to MCU security related functions."
   echo " A high level adapter (like a ST-Link) you are currently using cannot access"
   echo " the MDM-AP, so commands like 'mdm mass_erase' are not available in your"
   echo " configuration. Also security locked state of the device will not be reported."
   echo ""
   echo " Be very careful as you can lock the device though there is no way to unlock"
   echo " it without mass erase. Don't set write protection on the first block."
   echo "!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!"
   echo ""
} else {
   # Detect secured MCU
   $_TARGETNAME configure -event examine-fail {
      kinetis mdm check_security
   }

   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

# Disable watchdog not to disturb OpenOCD algorithms running on MCU
# (e.g. armv7m_checksum_memory() in verify_image)
# Flash driver also disables watchdog before FTFA flash programming.
$_TARGETNAME configure -event reset-init {
   kinetis disable_wdog
}
# ARM920T CPU

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME ks869x
}

if { [info exists ENDIAN] } {
   set  _ENDIAN $ENDIAN
} else {
   set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set  _CPUTAPID $CPUTAPID
} else {
   set  _CPUTAPID 0x00922f0f
}

adapter speed 6000

# jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x20000 -work-area-size 0x20000 -work-area-backup 0

# speed up memory downloads
arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable
#
# NXP (former Freescale) Kinetis Kx series devices
# Also used for Cortex-M4 equipped members of KVx and KE1xF series
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME kx
}

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.pflash
flash bank $_FLASHNAME kinetis 0 0 0 0 $_TARGETNAME
kinetis create_banks

adapter speed 1000

reset_config srst_nogate

if {[using_hla]} {
   echo ""
   echo "!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!"
   echo " Kinetis MCUs have a MDM-AP dedicated mainly to MCU security related functions."
   echo " A high level adapter (like a ST-Link) you are currently using cannot access"
   echo " the MDM-AP, so commands like 'mdm mass_erase' are not available in your"
   echo " configuration. Also security locked state of the device will not be reported."
   echo " Expect problems connecting to a blank device without boot ROM."
   echo ""
   echo " Be very careful as you can lock the device though there is no way to unlock"
   echo " it without mass erase. Don't set write protection on the first block."
   echo "!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!"
   echo ""
} else {
   # Detect secured MCU or boot lock-up in RESET/WDOG loop
   $_TARGETNAME configure -event examine-fail {
      kinetis mdm check_security
   }
   # During RESET/WDOG loop the target is sometimes falsely examined
   $_TARGETNAME configure -event examine-end {
      kinetis mdm check_security
   }

   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

# Disable watchdog not to disturb OpenOCD algorithms running on MCU
# (e.g. armv7m_checksum_memory() in verify_image)
# Flash driver also disables watchdog before FTFA flash programming.
$_TARGETNAME configure -event reset-init {
   kinetis disable_wdog
}
# NXP LPC11xx Cortex-M0 with at least 1kB SRAM
set CHIPNAME lpc11xx
set CHIPSERIES lpc1100
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x400
}

source [find target/lpc1xxx.cfg]
# NXP LPC12xx Cortex-M0 with at least 4kB SRAM
set CHIPNAME lpc12xx
set CHIPSERIES lpc1200
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x1000
}

source [find target/lpc1xxx.cfg]
# NXP LPC13xx Cortex-M3 with at least 4kB SRAM
set CHIPNAME lpc13xx
set CHIPSERIES lpc1300
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x1000
}

source [find target/lpc1xxx.cfg]
# NXP LPC17xx Cortex-M3 with at least 8kB SRAM
set CHIPNAME lpc17xx
set CHIPSERIES lpc1700
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x2000
}

source [find target/lpc1xxx.cfg]
source [find target/swj-dp.tcl]

adapter speed 500

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME lpc1850
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}
#
# M3 JTAG mode TAP
#
if { [info exists M3_JTAG_TAPID] } {
   set _M3_JTAG_TAPID $M3_JTAG_TAPID
} else {
   set _M3_JTAG_TAPID 0x4ba00477
}

swj_newdap $_CHIPNAME m3 -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_M3_JTAG_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.m3

set _TARGETNAME $_CHIPNAME.m3
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# Main file for NXP LPC1xxx/LPC40xx series Cortex-M0/0+/3/4F parts
#
# !!!!!!
#
# This file should not be included directly, rather by the lpc11xx.cfg,
# lpc13xx.cfg, lpc17xx.cfg, etc. which set the needed variables to the
# appropriate values.
#
# !!!!!!

# LPC8xx chips support only SWD transport.
# LPC11xx chips support only SWD transport.
# LPC12xx chips support only SWD transport.
# LPC11Uxx chips support only SWD transports.
# LPC13xx chips support only SWD transports.
# LPC17xx chips support both JTAG and SWD transports.
# LPC40xx chips support both JTAG and SWD transports.
# Adapt based on what transport is active.
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	error "CHIPNAME not set. Please do not include lpc1xxx.cfg directly, but the specific chip configuration file (lpc11xx.cfg, lpc13xx.cfg, lpc17xx.cfg, etc)."
}

if { [info exists CHIPSERIES] } {
	# Validate chip series is supported
	if { $CHIPSERIES != "lpc800" && $CHIPSERIES != "lpc1100" && $CHIPSERIES != "lpc1200" && $CHIPSERIES != "lpc1300" && $CHIPSERIES != "lpc1700"  && $CHIPSERIES != "lpc4000" } {
		error "Unsupported LPC1xxx chip series specified."
	}
	set _CHIPSERIES $CHIPSERIES
} else {
	error "CHIPSERIES not set. Please do not include lpc1xxx.cfg directly, but the specific chip configuration file (lpc11xx.cfg, lpc13xx.cfg, lpc17xx.cfg, etc)."
}

# After reset, the chip is clocked by an internal RC oscillator.
# When board-specific code (reset-init handler or device firmware)
# configures another oscillator and/or PLL0, set CCLK to match; if
# you don't, then flash erase and write operations may misbehave.
# (The ROM code doing those updates cares about core clock speed...)
# CCLK is the core clock frequency in KHz
if { [info exists CCLK] } {
	# Allow user override
	set _CCLK $CCLK
} else {
	# LPC8xx/LPC11xx/LPC12xx/LPC13xx use a 12MHz one, LPC17xx uses a 4MHz one(except for LPC177x/8x,LPC407x/8x)
	if { $_CHIPSERIES == "lpc800" || $_CHIPSERIES == "lpc1100" || $_CHIPSERIES == "lpc1200" || $_CHIPSERIES == "lpc1300" } {
		set _CCLK 12000
	} elseif { $_CHIPSERIES == "lpc1700" || $_CHIPSERIES == "lpc4000" } {
		set _CCLK 4000
	}
}

if { [info exists CPUTAPID] } {
	# Allow user override
	set _CPUTAPID $CPUTAPID
} else {
	# LPC8xx/LPC11xx/LPC12xx use a Cortex-M0/M0+ core, LPC13xx/LPC17xx use a Cortex-M3 core, LPC40xx use a Cortex-M4F core.
	if { $_CHIPSERIES == "lpc800" || $_CHIPSERIES == "lpc1100" || $_CHIPSERIES == "lpc1200" } {
		set _CPUTAPID 0x0bb11477
	} elseif { $_CHIPSERIES == "lpc1300" || $_CHIPSERIES == "lpc1700" || $_CHIPSERIES == "lpc4000" } {
		if { [using_jtag] } {
			set _CPUTAPID 0x4ba00477
		} {
			set _CPUTAPID 0x2ba01477
		}
	}
}

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	error "WORKAREASIZE is not set. The $CHIPNAME part is available in several Flash and RAM size configurations. Please set WORKAREASIZE."
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

# The LPC11xx devices have 2/4/8kB of SRAM in the ARMv7-M "Code" area (at 0x10000000)
# The LPC12xx devices have 4/8kB of SRAM in the ARMv7-M "Code" area (at 0x10000000)
# The LPC11Uxx devices have 4/6/8kB of SRAM in the ARMv7-M "Code" area (at 0x10000000)
# The LPC13xx devices have 4/8kB of SRAM in the ARMv7-M "Code" area (at 0x10000000)
# The LPC17xx devices have 8/16/32/64kB of SRAM in the ARMv7-M "Code" area (at 0x10000000)
# The LPC40xx devices have 16/32/64kB of SRAM in the ARMv7-ME "Code" area (at 0x10000000)
$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE

# The LPC11xx devies have 8/16/24/32/48/56/64kB of flash memory (at 0x00000000)
# The LPC12xx devies have 32/48/64/80/96/128kB of flash memory (at 0x00000000)
# The LPC11Uxx devies have 16/24/32/40/48/64/96/128kB of flash memory (at 0x00000000)
# The LPC13xx devies have 8/16/32kB of flash memory (at 0x00000000)
# The LPC17xx devies have 32/64/128/256/512kB of flash memory (at 0x00000000)
# The LPC40xx devies have 64/128/256/512kB of flash memory (at 0x00000000)
#
# All are compatible with the "lpc1700" variant of the LPC2000 flash driver
# (same cmd51 destination boundary alignment, and all three support 256 byte
# transfers).
#
# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum] [iap entry]
set _IAP_ENTRY 0
if { [info exists IAP_ENTRY] } {
	set _IAP_ENTRY $IAP_ENTRY
}
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME lpc2000 0x0 0 0 0 $_TARGETNAME \
	auto $_CCLK calc_checksum $_IAP_ENTRY

if { $_CHIPSERIES == "lpc800" || $_CHIPSERIES == "lpc1100" || $_CHIPSERIES == "lpc1200" || $_CHIPSERIES == "lpc1300" } {
	# Do not remap 0x0000-0x0200 to anything but the flash (i.e. select
	# "User Flash Mode" where interrupt vectors are _not_ remapped,
	# and reside in flash instead).
	#
	# Table 8. System memory remap register (SYSMEMREMAP, address 0x4004 8000) bit description
	# Bit Symbol Value Description
	# 1:0 MAP          System memory remap
	#            0x0   Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM.
	#            0x1   User RAM Mode. Interrupt vectors are re-mapped to Static RAM.
	#            0x2   User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash.
	# 31:2 -     -     Reserved.
	$_TARGETNAME configure -event reset-init {
		mww 0x40048000 0x02
	}
} elseif { $_CHIPSERIES == "lpc1700" || $_CHIPSERIES == "lpc4000" } {
	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
	# "User Flash Mode" where interrupt vectors are _not_ remapped,
	# and reside in flash instead).
	#
	# See Table 612. Memory Mapping Control register (MEMMAP - 0x400F C040) bit description
	# Bit Symbol Value Description Reset
	# value
	# 0 MAP Memory map control. 0
	# 0 Boot mode. A portion of the Boot ROM is mapped to address 0.
	# 1 User mode. The on-chip Flash memory is mapped to address 0.
	# 31:1 - Reserved. The value read from a reserved bit is not defined. NA
	#
	# http://ics.nxp.com/support/documents/microcontrollers/?scope=LPC1768&type=user
	$_TARGETNAME configure -event reset-init {
		mww 0x400FC040 0x01
	}
}

# Run with *real slow* clock by default since the
# boot rom could have been playing with the PLL, so
# we have no idea what clock the target is running at.
adapter speed 10

# delays on reset lines
adapter srst delay 200
if {[using_jtag]} {
 jtag_ntrst_delay 200
}

# LPC8xx (Cortex-M0+ core) support SYSRESETREQ
# LPC11xx/LPC12xx (Cortex-M0 core) support SYSRESETREQ
# LPC13xx/LPC17xx (Cortex-M3 core) support SYSRESETREQ
# LPC40xx (Cortex-M4F core) support SYSRESETREQ
if {![using_hla]} {
    # if srst is not fitted use SYSRESETREQ to
    # perform a soft reset
    cortex_m reset_config sysresetreq
}
# NXP LPC2103 ARM7TDMI-S with 32kB flash and 8kB SRAM, clocked with 12MHz crystal

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2103 {core_freq_khz adapter_freq_khz} {
	# 32kB flash and 8kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2103 0x4f1f0f0f 0x8000 lpc2000_v2 0x2000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 12MHz crystal
	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2103 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2103 12000 1500
}
# NXP LPC2124 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2124 {core_freq_khz adapter_freq_khz} {
	# 256kB flash and 16kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2124 0x4f1f0f0f 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 12MHz crystal
	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2124 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2124 12000 1500
}
# NXP LPC2129 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2129 {core_freq_khz adapter_freq_khz} {
	# 256kB flash and 16kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2129 0xcf1f0f0f 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 12MHz crystal
	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2129 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2129 12000 1500
}
# NXP LPC2148 ARM7TDMI-S with 512kB flash (12kB used by bootloader) and 40kB SRAM (8kB for USB DMA), clocked with 12MHz crystal

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2148 {core_freq_khz adapter_freq_khz} {
	# 500kB flash and 32kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2148 "0x3f0f0f0f 0x4f1f0f0f" 0x7d000 lpc2000_v2 0x8000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 12MHz crystal
	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2148 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2148 12000 1500
}
# NXP LPC2294 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2294 {core_freq_khz adapter_freq_khz} {
	# 256kB flash and 16kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>

	# !! TAPID unknown !!
	setup_lpc2xxx lpc2294 0xffffffff 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 12MHz crystal
	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2294 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2294 12000 1500
}
# NXP LPC2378 ARM7TDMI-S with 512kB flash (8kB used by bootloader) and 56kB SRAM (16kB for ETH, 8kB for DMA), clocked with 4MHz internal oscillator

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2378 {core_freq_khz adapter_freq_khz} {
	# 504kB flash and 32kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2378 0x4f1f0f0f 0x7e000 lpc2000_v2 0x8000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 4MHz internal oscillator
	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2378 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2378 4000 500
}
# NXP LPC2460 ARM7TDMI-S with 98kB SRAM (16kB for ETH, 16kB for DMA, 2kB for RTC), clocked with 4MHz internal oscillator

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2460 {core_freq_khz adapter_freq_khz} {
	# 64kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2460 0x4f1f0f0f 0 lpc2000_v2 0x10000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 4MHz internal oscillator
	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2460 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2460 4000 500
}
# NXP LPC2478 ARM7TDMI-S with 512kB flash (8kB used by bootloader) and 98kB SRAM (16kB for ETH, 16kB for DMA, 2kB for RTC), clocked with 4MHz internal oscillator

source [find target/lpc2xxx.cfg]

# parameters:
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2478 {core_freq_khz adapter_freq_khz} {
	# 504kB flash and 64kB SRAM
	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
	setup_lpc2xxx lpc2478 0x4f1f0f0f 0x7e000 lpc2000_v2 0x10000 $core_freq_khz $adapter_freq_khz
}

proc init_targets {} {
	# default to core clocked with 4MHz internal oscillator
	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."

	# setup_lpc2478 <core_freq_khz> <adapter_freq_khz>
	setup_lpc2478 4000 500
}

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME lpc2900
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    set _CPUTAPID 0x0596802B
}

if { [info exists HAS_ETB] } {
} else {
    # Set default (no ETB).
    # Show a warning, because this should have been configured explicitly.
    set HAS_ETB 0
    # TODO: warning?
}

if { [info exists ETBTAPID] } {
    set _ETBTAPID $ETBTAPID
} else {
    set _ETBTAPID 0x1B900F0F
}

# TRST and SRST both exist, and can be controlled independently
reset_config trst_and_srst separate

# Define the _TARGETNAME
set _TARGETNAME $_CHIPNAME.cpu

# Include the ETB tap controller if asked for.
# Has to be done manually for newer devices (not an "old" LPC2917/2919).
if { $HAS_ETB == 1 } {
    # Clear the HAS_ETB flag. Must be set again for a new tap in the chain.
    set HAS_ETB 0

    # Add the ETB tap controller and the ARM9 core debug tap
    jtag newtap $_CHIPNAME etb -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_ETBTAPID
    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

    # Create the ".cpu" target
    target create $_TARGETNAME arm966e -endian little -chain-position $_TARGETNAME

    # Configure ETM and ETB
    etm config $_TARGETNAME 8 normal full etb
    etb config $_TARGETNAME $_CHIPNAME.etb

} else {
    # Add the ARM9 core debug tap
    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

    # Create the ".cpu" target
    target create $_TARGETNAME arm966e -endian little -chain-position $_TARGETNAME
}

arm7_9 dbgrq enable
arm7_9 dcc_downloads enable

# Flash bank configuration:
# Flash: flash bank lpc2900 0 0 0 0 <target#> <flash clock (CLK_SYS_FMC) in kHz>
# Flash base address, total flash size, and number of sectors are all configured automatically.
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME lpc2900 0 0 0 0 $_TARGETNAME $FLASH_CLOCK
# Common setup for the LPC2xxx parts

# parameters:
# - chip_name - name of the chip, e.g. lpc2103
# - cputapids - TAP IDs of the core, should be quoted if more than one, e.g. 0x4f1f0f0f or "0x3f0f0f0f 0x4f1f0f0f"
# - flash_size - size of on-chip flash (available for code, not including the bootloader) in bytes, e.g. 0x8000
# - flash_variant - "type" of LPC2xxx device, lpc2000_v1 (LPC22xx and older LPC21xx) or lpc2000_v2 (LPC213x, LPC214x, LPC210[123], LPC23xx and LPC24xx)
# - workarea_size - size of work-area in RAM for flashing procedures, must not exceed the size of RAM available at 0x40000000, e.g. 0x2000
# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000

proc setup_lpc2xxx {chip_name cputapids flash_size flash_variant workarea_size core_freq_khz adapter_freq_khz} {
	reset_config trst_and_srst

	# reset delays
	adapter srst delay 100
	jtag_ntrst_delay 100

	adapter speed $adapter_freq_khz

	foreach i $cputapids {
		append expected_ids "-expected-id " $i " "
	}

	eval "jtag newtap $chip_name cpu -irlen 4 -ircapture 0x1 -irmask 0xf $expected_ids"

	global _TARGETNAME
	set _TARGETNAME $chip_name.cpu
	target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME

	$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size $workarea_size -work-area-backup 0

	if { $flash_size > 0 } {
		# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
		set _FLASHNAME $chip_name.flash
		flash bank $_FLASHNAME lpc2000 0x0 $flash_size 0 0 $_TARGETNAME $flash_variant $core_freq_khz calc_checksum
	}
}

proc init_targets {} {
	# FIX!!! read out CPUTAPID here and choose right setup. In addition to the
	# CPUTAPID some querying of the target would be required.
	return -error "This is a generic LPC2xxx configuration file, use a specific target file."
}
######################################
# Target:    NXP lpc3131
######################################

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME lpc3131
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# ARM926EJS core
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926f0f
}

# Scan Tap
# Wired to separate STDO pin on the lpc3131, externally muxed to TDO on ea3131 module
# JTAGSEL pin must be 0 to activate, which reassigns arm tdo to a pass through.
if { [info exists SJCTAPID] } {
   set _SJCTAPID $SJCTAPID
} else {
   set _SJCTAPID 0x1541E02B
}

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

##################################################################
# various symbol definitions, to avoid hard-wiring addresses
##################################################################

global lpc313x
set lpc313x [ dict create ]

# Physical addresses for controllers and memory
dict set lpc313x sram0			0x11028000
dict set lpc313x sram1			0x11040000
dict set lpc313x uart			0x15001000
dict set lpc313x cgu			0x13004000
dict set lpc313x ioconfig		0x13003000
dict set lpc313x sysconfig		0x13002800
dict set lpc313x wdt			0x13002400

##################################################################
# Target configuration
##################################################################

adapter srst delay 1000
jtag_ntrst_delay 0

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME invoke-event halted

$_TARGETNAME configure -work-area-phys [dict get $lpc313x sram0] -work-area-size 0x30000 -work-area-backup 0

$_TARGETNAME configure -event reset-init {
	echo "\nRunning reset init script for LPC3131\n"
	halt
	wait_halt
	reg cpsr 0xa00000d3	;#Supervisor mode
	reg pc 0x11029000
	poll
	sleep 500
}

arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable
# lpc3250 config
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME lpc3250
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x17900f0f
}

if { [info exists CPUTAPID_REV_A0] } {
   set _CPUTAPID_REV_A0 $CPUTAPID_REV_A0
} else {
   set _CPUTAPID_REV_A0 0x17926f0f
}

if { [info exists SJCTAPID] } {
   set _SJCTAPID $SJCTAPID
} else {
   set _SJCTAPID 0x1b900f0f
}

jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_SJCTAPID

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID \
     -expected-id $_CPUTAPID_REV_A0

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian little -chain-position $_TARGETNAME -work-area-phys 0x00000000 -work-area-size 0x7d0000 -work-area-backup 0

proc power_restore {} { echo "Sensed power restore. No action." }
proc srst_deasserted {} { echo "Sensed nSRST deasserted. No action." }
# NXP LPC40xx Cortex-M4F with at least 16kB SRAM
set CHIPNAME lpc40xx
set CHIPSERIES lpc4000
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x4000
}

source [find target/lpc1xxx.cfg]
source [find target/swj-dp.tcl]

adapter speed 500

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME lpc4350
}

#
# M4 JTAG mode TAP
#
if { [info exists M4_JTAG_TAPID] } {
	set _M4_JTAG_TAPID $M4_JTAG_TAPID
} else {
	set _M4_JTAG_TAPID 0x4ba00477
}

#
# M4 SWD mode TAP
#
if { [info exists M4_SWD_TAPID] } {
	set _M4_SWD_TAPID $M4_SWD_TAPID
} else {
	set _M4_SWD_TAPID 0x2ba01477
}

if { [using_jtag] } {
	set _M4_TAPID $_M4_JTAG_TAPID
} {
	set _M4_TAPID $_M4_SWD_TAPID
}

#
# M0 TAP
#
if { [info exists M0_JTAG_TAPID] } {
	set _M0_JTAG_TAPID $M0_JTAG_TAPID
} else {
	set _M0_JTAG_TAPID 0x0ba01477
}

swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
				-expected-id $_M4_TAPID
dap create $_CHIPNAME.m4.dap -chain-position $_CHIPNAME.m4
target create $_CHIPNAME.m4 cortex_m -dap $_CHIPNAME.m4.dap

if { [using_jtag] } {
	swj_newdap $_CHIPNAME m0 -irlen 4 -ircapture 0x1 -irmask 0xf \
				-expected-id $_M0_JTAG_TAPID
	dap create $_CHIPNAME.m0.dap -chain-position $_CHIPNAME.m0
	target create $_CHIPNAME.m0 cortex_m -dap $_CHIPNAME.m0.dap
}

# LPC4350 has 96+32 KB SRAM
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x20000
}
$_CHIPNAME.m4 configure -work-area-phys 0x10000000 \
			-work-area-size $_WORKAREASIZE -work-area-backup 0

if {![using_hla]} {
   # on this CPU we should use VECTRESET to perform a soft reset and
   # manually reset the periphery
   # SRST or SYSRESETREQ disable the debug interface for the time of
   # the reset and will not fit our requirements for a consistent debug
   # session
   cortex_m reset_config vectreset
}
#
# NXP LPC4357
#

if { ![info exists CHIPNAME] } {
	set CHIPNAME lpc4357
}
set WORKAREASIZE 0x8000
source [find target/lpc4350.cfg]

flash bank $_CHIPNAME.flasha lpc2000 0x1A000000 0x80000 0 0 $_CHIPNAME.m4 lpc4300 204000 calc_checksum
flash bank $_CHIPNAME.flashb lpc2000 0x1B000000 0x80000 0 0 $_CHIPNAME.m4 lpc4300 204000 calc_checksum
#
# NXP LPC4370 - 1x ARM Cortex-M4 + 2x ARM Cortex-M0 @ up to 204 MHz each
#

adapter speed 500

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME lpc4370
}

#
# M4 JTAG mode TAP
#
if { [info exists M4_JTAG_TAPID] } {
	set _M4_JTAG_TAPID $M4_JTAG_TAPID
} else {
	set _M4_JTAG_TAPID 0x4ba00477
}

#
# M4 SWD mode TAP
#
if { [info exists M4_SWD_TAPID] } {
	set _M4_SWD_TAPID $M4_SWD_TAPID
} else {
	set _M4_SWD_TAPID 0x2ba01477
}

source [find target/swj-dp.tcl]

if { [using_jtag] } {
	set _M4_TAPID $_M4_JTAG_TAPID
} else {
	set _M4_TAPID $_M4_SWD_TAPID
}

#
# M0 TAP
#
if { [info exists M0_JTAG_TAPID] } {
	set _M0_JTAG_TAPID $M0_JTAG_TAPID
} else {
	set _M0_JTAG_TAPID 0x0ba01477
}

swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
				-expected-id $_M4_TAPID
dap create $_CHIPNAME.m4.dap -chain-position $_CHIPNAME.m4
target create $_CHIPNAME.m4 cortex_m -dap $_CHIPNAME.m4.dap

# LPC4370 has 96+32 KB contiguous SRAM
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x20000
}
$_CHIPNAME.m4 configure -work-area-phys 0x10000000 \
                        -work-area-size $_WORKAREASIZE -work-area-backup 0

if { [using_jtag] } {
	jtag newtap $_CHIPNAME m0app -irlen 4 -ircapture 0x1 -irmask 0xf \
					-expected-id $_M0_JTAG_TAPID
	jtag newtap $_CHIPNAME m0sub -irlen 4 -ircapture 0x1 -irmask 0xf \
					-expected-id $_M0_JTAG_TAPID

	dap create $_CHIPNAME.m0app.dap -chain-position $_CHIPNAME.m0app
	dap create $_CHIPNAME.m0sub.dap -chain-position $_CHIPNAME.m0sub
	target create $_CHIPNAME.m0app cortex_m -dap $_CHIPNAME.m0app.dap
	target create $_CHIPNAME.m0sub cortex_m -dap $_CHIPNAME.m0sub.dap

	# 32+8+32 KB SRAM
	$_CHIPNAME.m0app configure -work-area-phys 0x10080000 \
	                           -work-area-size 0x92000 -work-area-backup 0

	# 16+2 KB M0 subsystem SRAM
	$_CHIPNAME.m0sub configure -work-area-phys 0x18000000 \
	                           -work-area-size 0x4800 -work-area-backup 0

	# Default to the Cortex-M4
	targets $_CHIPNAME.m4
}

if { ![using_hla] } {
	cortex_m reset_config vectreset
}
# NXP LPC84x Cortex-M0+ with at least 8kB SRAM
if { ![info exists CHIPNAME] } {
	set CHIPNAME lpc84x
}
set CHIPSERIES lpc800
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x1fe0
}

set IAP_ENTRY 0x0F001FF1
source [find target/lpc1xxx.cfg]
# NXP LPC8Nxx NHS31xx Cortex-M0+ with 8kB SRAM
# Copyright (C) 2018 by Jean-Christian de Rivaz
# Based on NXP proposal https://community.nxp.com/message/1011149
# Many thanks to Dries Moors from NXP support.
# SWD only transport

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set  _CHIPNAME $CHIPNAME
} else {
	set  _CHIPNAME lpc8nxx
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id 0
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap
if {![using_hla]} {
	# If srst is not fitted use SYSRESETREQ to  perform a soft reset
	cortex_m reset_config sysresetreq
}
adapter srst delay 100

$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size 0x1ff0 -work-area-backup 0

flash bank $_CHIPNAME.flash lpc2000 0x0 0x7800 0 0 $_TARGETNAME lpc800 500

echo "*********************************************************************************"
echo "*         !!!!! IMPORTANT NOTICE FOR LPC8Nxx and NHS31xx CHIPS !!!!!"
echo "* When this IC is in power-off or peep power down mode, the SWD HW block is also"
echo "* unpowered. These modes can be entered by firmware. The default firmware image"
echo "* (flashed in production) makes use of this. Best is to avoid these power modes"
echo "* during development, and only later add them when the functionality is complete."
echo "* Hardware reset or NFC field are the only ways to connect in case the SWD is"
echo "* powered off. OpenOCD can do a hardware reset if you wire the adapter SRST"
echo "* signal to the chip RESETN pin and add the following in your configuration:"
echo "*     reset_config srst_only; flash init; catch init; reset"
echo "* But if the actual firmware immediately set the power down mode after reset,"
echo "* OpenOCD might be not fast enough to halt the CPU before the SWD lost power. In"
echo "* that case the only solution is to apply a NFC field to keep the SWD powered."
echo "*********************************************************************************"

# Using soft-reset 'reset_config none' is strongly discouraged.
# RESETN sets the system clock to 500 kHz. Unlike soft-reset does not.
# Set the system clock to 500 kHz before reset to simulate the functionality of hw reset.
#
proc set_sysclk_500khz {} {
	set SYSCLKCTRL 0x40048020
	set SYSCLKUEN 0x40048024
	mww $SYSCLKUEN 0
	mmw $SYSCLKCTRL 0x8 0xe
	mww $SYSCLKUEN 1
	echo "Notice: sysclock set to 500kHz."
}

# Do not remap the ARM interrupt vectors to anything but the beginning ot the flash.
# Table System memory remap register (SYSMEMREMAP, address 0x4004 8000) bit description
# Bit Symbol  Value   Description
# 0   map         -   interrupt vector remap. 0 after boot.
#                 0   interrupt vector reside in Flash
#                 1   interrupt vector reside in SRAM
# 5:1 offset      -   system memory remap offset. 00000b after boot.
#            00000b   interrupt vectors in flash or remapped to SRAM but no offset
#            00001b -
#            00111b   interrupt vectors offset in flash or SRAM to 1K word segment
#            01000b -
#            11111b   interrupt vectors offset in flash to 1K word segment 8 to 31
# 31:6                reserved
#
proc set_no_remap {} {
	mww 0x40048000 0x00
	echo "Notice: interrupt vector set to no remap."
}

$_TARGETNAME configure -event reset-init {
	set_sysclk_500khz
	set_no_remap
}
# NXP LPC8xx Cortex-M0+ with at least 1kB SRAM
if { ![info exists CHIPNAME] } {
	set CHIPNAME lpc8xx
}
set CHIPSERIES lpc800
if { ![info exists WORKAREASIZE] } {
	set WORKAREASIZE 0x400
}

source [find target/lpc1xxx.cfg]
#
# NXP LS1012A
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME ls1012a
}

if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x5ba00477
}

if { [info exists SAP_TAPID] } {
	set _SAP_TAPID $SAP_TAPID
} else {
	set _SAP_TAPID 0x06b2001d
}

jtag newtap $_CHIPNAME dap -irlen 4 -expected-id $_DAP_TAPID
jtag newtap $_CHIPNAME sap -irlen 8 -expected-id $_SAP_TAPID

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.dap

cti create $_CHIPNAME.cti -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0x80420000

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80410000 -cti $_CHIPNAME.cti

target smp $_TARGETNAME

adapter speed 2000
# Marvell Armada 3710

set CORES 1

source [find target/marvell/88f37x0.cfg]
# Marvell Armada 3720

set CORES 2

source [find target/marvell/88f37x0.cfg]
# Main file for Marvell Armada 3700 series targets
#
# !!!!!!
#
# This file should not be included directly. Instead, please include
# either marvell/88f3710.cfg or marvell/88f3720.cfg, which set the needed
# variables to the appropriate values.
#
# !!!!!!

# Armada 3700 supports both JTAG and SWD transports.
source [find target/swj-dp.tcl]

if { [info exists CORES] } {
    set _cores $CORES
} else {
    error "CORES not set. Please do not include marvell/88f37x0.cfg directly, but the specific chip configuration file (marvell/88f3710.cfg, marvell/88f3720.cfg, etc.)."
}

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME [format a37%s0 $_cores]
}

set _ctis {0x80820000 0x80920000}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x4ba00477
}

# declare the one JTAG tap to access the DAP
swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -ignore-version -enable
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# declare the main application cores
set _TARGETNAME $_CHIPNAME.cpu
set _smp_command ""

for { set _core 0 } { $_core < $_cores } { incr _core 1 } {

    cti create cti$_core -dap $_CHIPNAME.dap -baseaddr [lindex $_ctis $_core] -ap-num 0

    set _command "target create ${_TARGETNAME}$_core aarch64 \
                         -dap $_CHIPNAME.dap -coreid $_core \
                         -cti cti$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        set _command "$_command -defer-examine"
        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
    } else {
        # uncomment when "hawt" rtos is merged
        # set _command "$_command -rtos hawt"
        set _smp_command "target smp ${_TARGETNAME}$_core"
    }

    eval $_command
}

eval $_smp_command

# declare the auxiliary Cortex-M3 core on AP #3
target create ${_TARGETNAME}.m3 cortex_m -dap $_CHIPNAME.dap -ap-num 3 -defer-examine

targets ${_TARGETNAME}0
# Maxim Integrated MAX32620 OpenOCD target configuration file
# www.maximintegrated.com

# adapter speed
adapter speed 4000

# reset pin configuration
reset_config srst_only

if {[using_jtag]} {
    jtag newtap max32620 cpu -irlen 4 -irmask 0xf -expected-id 0x4ba00477 -ignore-version
    jtag newtap maxtest tap -irlen 4 -irmask 0xf -ircapture 0x1 -ignore-version
} else {
    swd newdap max32620 cpu -irlen 4 -irmask 0xf -expected-id 0x2ba01477 -ignore-version
}

# target configuration
target create max32620.cpu cortex_m -chain-position max32620.cpu
max32620.cpu configure -work-area-phys 0x20005000 -work-area-size 0x2000

# Config Command: flash bank name driver base size chip_width bus_width target [driver_options]
#   flash bank <name> max32xxx <base> <size> 0 0 <target> <flc base> <sector> <clk> <burst>
#   max32620 flash base address   0x00000000
#   max32620 flash size           0x200000 (2MB)
#   max32620 FLC base address     0x40002000
#   max32620 sector (page) size   0x2000 (8kB)
#   max32620 clock speed          96 (MHz)
flash bank max32620.flash max32xxx 0x00000000 0x200000 0 0 max32620.cpu 0x40002000 0x2000 96
# Maxim Integrated MAX32625 OpenOCD target configuration file
# www.maximintegrated.com

# adapter speed
adapter speed 4000

# reset pin configuration
reset_config srst_only

if {[using_jtag]} {
    jtag newtap max32625 cpu -irlen 4 -irmask 0xf -expected-id 0x4ba00477 -ignore-version
    jtag newtap maxtest tap -irlen 4 -irmask 0xf -ircapture 0x1 -expected-id 0x07f71197 -ignore-version
} else {
    swd newdap max32625 cpu -irlen 4 -irmask 0xf -expected-id 0x2ba01477 -ignore-version
}

# target configuration
target create max32625.cpu cortex_m -chain-position max32625.cpu
max32625.cpu configure -work-area-phys 0x20005000 -work-area-size 0x2000

# Config Command: flash bank name driver base size chip_width bus_width target [driver_options]
#   flash bank <name> max32xxx <base> <size> 0 0 <target> <flc base> <sector> <clk> <burst>
#   max32625 flash base address   0x00000000
#   max32625 flash size           0x80000 (512k)
#   max32625 FLC base address     0x40002000
#   max32625 sector (page) size   0x2000 (8kB)
#   max32625 clock speed          96 (MHz)
flash bank max32625.flash max32xxx 0x00000000 0x80000 0 0 max32625.cpu 0x40002000 0x2000 96
# Maxim Integrated MAX3263X OpenOCD target configuration file
# www.maximintegrated.com

# adapter speed
adapter speed 4000

# reset pin configuration
reset_config srst_only

if {[using_jtag]} {
    jtag newtap max3263x cpu -irlen 4 -irmask 0xf -expected-id 0x4ba00477 -ignore-version
    jtag newtap maxtest tap -irlen 4 -irmask 0xf -ircapture 0x1 -expected-id 0x07f76197 -ignore-version
} else {
    swd newdap max3263x cpu -irlen 4 -irmask 0xf -expected-id 0x2ba01477 -ignore-version
}

# target configuration
target create max3263x.cpu cortex_m -chain-position max3263x.cpu
max3263x.cpu configure -work-area-phys 0x20005000 -work-area-size 0x2000

# Config Command: flash bank name driver base size chip_width bus_width target [driver_options]
#   flash bank <name> max32xxx <base> <size> 0 0 <target> <flc base> <sector> <clk> <burst>
#   max3263x flash base address   0x00000000
#   max3263x flash size           0x200000 (2MB)
#   max3263x FLC base address     0x40002000
#   max3263x sector (page) size   0x2000 (8kB)
#   max3263x clock speed          96 (MHz)
flash bank max3263x.flash max32xxx 0x00000000 0x200000 0 0 max3263x.cpu 0x40002000 0x2000 96
source [find bitsbytes.tcl]
source [find cpu/arm/arm7tdmi.tcl]
source [find memory.tcl]
source [find mmr_helpers.tcl]

set CHIP_MAKER             freescale
set CHIP_FAMILY            mc1322x
set CHIP_NAME              mc13224
set N_RAM                  1
set RAM(0,BASE)            0x00400000
set RAM(0,LEN)             0x18000
set RAM(0,HUMAN)           "internal SRAM"
set RAM(0,TYPE)            "ram"
set RAM(0,RWX)             $RWX_RWX
set RAM(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

# I AM LAZY... I create 1 region for all MMRs.
set N_MMREGS                  1
set MMREGS(0,CHIPSELECT)      -1
set MMREGS(0,BASE)            0x80000000
set MMREGS(0,LEN)             0x00030000
set MMREGS(0,HUMAN)           "mm-regs"
set MMREGS(0,TYPE)            "mmr"
set MMREGS(0,RWX)             $RWX_RW
set MMREGS(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY

set N_XMEM 0

set _CHIPNAME mc13224v
set _CPUTAPID 0x1f1f001d

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

reset_config srst_only
jtag_ntrst_delay 200

# rclk hasn't been working well. This maybe the mc13224v or something else.
#adapter speed 2000
adapter speed 2000

######################
# Target configuration
######################

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME

# Internal sram memory
$_TARGETNAME configure -work-area-phys 0x00408000 \
                       -work-area-size 0x1000     \
                       -work-area-backup 1

# flash support is pending (should be straightforward to implement)
#flash bank mc1322x 0 0 0 0 $_TARGETNAME
# MDR32F9Q2I (198692)
# http://milandr.ru/index.php?mact=Products,cntnt01,details,0&cntnt01productid=57&cntnt01returnid=68

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME mdr32f9q2i
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x8000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x4ba00477
   } {
      # SWD IDCODE
      set _CPUTAPID 0x2ba01477
   }
}
swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# can't handle overlapping memory regions
if { [info exists IMEMORY] && [string equal $IMEMORY true] } {
   flash bank ${_CHIPNAME}_info.flash mdr 0x08000000 0x01000 0 0 $_TARGETNAME 1 1 4
} else {
   flash bank $_CHIPNAME.flash mdr 0x08000000 0x20000 0 0 $_TARGETNAME 0 32 4
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
   jtag_ntrst_delay 100
}

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
#
# Andes Core
#
# http://www.andestech.com
#

jtag newtap $_CHIPNAME cpu -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME nds32_v2 -endian little -chain-position $_TARGETNAME
#
# Andes Core
#
# http://www.andestech.com
#

jtag newtap $_CHIPNAME cpu -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME nds32_v3 -endian little -chain-position $_TARGETNAME
#
# Andes Core
#
# http://www.andestech.com
#

jtag newtap $_CHIPNAME cpu -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME nds32_v3m -endian little -chain-position $_TARGETNAME
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Andes Core
#
# http://www.andestech.com
#

set _CHIPNAME nds
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x1000563D

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME riscv -chain-position $_TARGETNAME
# NXP NHS31xx Cortex-M0+ with 8kB SRAM

set CHIPNAME nhs31xx
source [find target/lpc8nxx.cfg]
#
# script for Nordic nRF51 series, a Cortex-M0 chip
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME nrf51
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# Work-area is a space in RAM used for flash programming
# By default use 16kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

if {![using_hla]} {
   # The chip supports standard ARM/Cortex-M0 SYSRESETREQ signal
   cortex_m reset_config sysresetreq
}

flash bank $_CHIPNAME.flash nrf51 0x00000000 0 1 1 $_TARGETNAME
flash bank $_CHIPNAME.uicr nrf51 0x10001000 0 1 1 $_TARGETNAME

#
#  The chip should start up from internal 16Mhz RC, so setting adapter
#  clock to 1Mhz should be OK
#
adapter speed 1000

proc enable_all_ram {} {
	# nRF51822 Product Anomaly Notice (PAN) #16 explains that not all RAM banks
	# are reliably enabled after reset on some revisions (contrary to spec.) So after
	# resetting we enable all banks via the RAMON register
	mww 0x40000524 0xF
}
$_TARGETNAME configure -event reset-end {  enable_all_ram }
#
# Nordic nRF52 series: ARM Cortex-M4 @ 64 MHz
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME nrf52
}

# Work-area is a space in RAM used for flash programming
# By default use 16kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x2ba01477
}

swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

adapter speed 1000

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

if { [using_hla] } {
	echo ""
	echo "nRF52 device has a CTRL-AP dedicated to recover the device from AP lock."
	echo "A high level adapter (like a ST-Link) you are currently using cannot access"
	echo "the CTRL-AP so 'nrf52_recover' command will not work."
	echo "Do not enable UICR APPROTECT."
	echo ""
} else {
	cortex_m reset_config sysresetreq

	$_TARGETNAME configure -event examine-fail nrf52_check_ap_lock
}

flash bank $_CHIPNAME.flash nrf5 0x00000000 0 1 1 $_TARGETNAME
flash bank $_CHIPNAME.uicr nrf5 0x10001000 0 1 1 $_TARGETNAME

# Test if MEM-AP is locked by UICR APPROTECT
proc nrf52_check_ap_lock {} {
	set dap [[target current] cget -dap]
	set err [catch {set APPROTECTSTATUS [$dap apreg 1 0xc]}]
	if {$err == 0 && $APPROTECTSTATUS != 1} {
		echo "****** WARNING ******"
		echo "nRF52 device has AP lock engaged (see UICR APPROTECT register)."
		echo "Debug access is denied."
		echo "Use 'nrf52_recover' to erase and unlock the device."
		echo ""
		poll off
	}
}

# Mass erase and unlock the device using proprietary nRF CTRL-AP (AP #1)
# http://www.ebyte.com produces modules with nRF52 locked by default,
# use nrf52_recover to enable flashing and debug.
proc nrf52_recover {} {
	set target [target current]
	set dap [$target cget -dap]

	set IDR [$dap apreg 1 0xfc]
	if {$IDR != 0x02880000} {
		echo "Error: Cannot access nRF52 CTRL-AP!"
		return
	}

	poll off

	# Reset and trigger ERASEALL task
	$dap apreg 1 4 0
	$dap apreg 1 4 1

	for {set i 0} {1} {incr i} {
		set ERASEALLSTATUS [$dap apreg 1 8]
		if {$ERASEALLSTATUS == 0} {
			echo "$target device has been successfully erased and unlocked."
			break
		}
		if {$i == 0} {
			echo "Waiting for chip erase..."
		}
		if {$i >= 150} {
			echo "Error: $target recovery failed."
			break
		}
		sleep 100
	}

	# Assert reset
	$dap apreg 1 0 1

	# Deassert reset
	$dap apreg 1 0 0

	# Reset ERASEALL task
	$dap apreg 1 4 0

	sleep 100
	$target arp_examine
	poll on
}

add_help_text nrf52_recover "Mass erase and unlock nRF52 device"
#
# Nuvoton nuc910 (previously W90P910) based soc
#

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME nuc910
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
  # set useful default
   set _CPUTAPID 0x07926f0f
}

set _TARGETNAME $_CHIPNAME.cpu
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
# script for Nuvoton MuMicro Cortex-M0 Series

# Adapt based on what transport is active.
source [find target/swj-dp.tcl]

# Set Chipname
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME NuMicro
}

# SWD DP-ID Nuvoton NuMicro Cortex-M0 has SWD Transport only.
if { [info exists CPUDAPID] } {
	set _CPUDAPID $CPUDAPID
} else {
	set _CPUDAPID 0x0BB11477
}

# Work-area is a space in RAM used for flash programming
# By default use 2kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}


# Debug Adapter Target Settings
swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUDAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash bank <name> numicro <base> <size(autodetect,set to 0)> 0 0 <target#>
#set _FLASHNAME $_CHIPNAME.flash
#flash bank $_FLASHNAME numicro 0 $_FLASHSIZE 0 0 $_TARGETNAME
# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash_aprom
flash bank $_FLASHNAME numicro 0x00000000 0 0 0 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash_data
flash bank $_FLASHNAME numicro 0x0001F000 0 0 0 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash_ldrom
flash bank $_FLASHNAME numicro 0x00100000 0 0 0 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash_config
flash bank $_FLASHNAME numicro 0x00300000 0 0 0 $_TARGETNAME

# set default SWCLK frequency
adapter speed 1000

# set default srst setting "none"
reset_config none

# HLA doesn't have cortex_m commands
if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}
# Texas Instruments OMAP 2420
#	http://www.ti.com/omap
# as seen in Nokia N8x0 tablets

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME omap2420
}

# NOTE: likes slowish clock on reset (1.5 MBit/s or less) or use RCLK
reset_config srst_nogate

# Subsidiary TAP: ARM7TDMIr4 plus imaging ... must add via ICEpick (addr 6).
jtag newtap $_CHIPNAME iva -irlen 4 -disable

# Subsidiary TAP: C55x DSP ... must add via ICEpick (addr 2).
jtag newtap $_CHIPNAME dsp -irlen 38 -disable

# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
if { [info exists ETB_TAPID] } {
   set _ETB_TAPID $ETB_TAPID
} else {
   set _ETB_TAPID 0x2b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -expected-id $_ETB_TAPID

# Subsidiary TAP: ARM1136jf-s with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
if { [info exists CPU_TAPID] } {
   set _CPU_TAPID $CPU_TAPID
} else {
   set _CPU_TAPID 0x07b3602f
}
jtag newtap $_CHIPNAME arm -irlen 5 -expected-id $_CPU_TAPID

# Primary TAP: ICEpick-B (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x01ce4801
}
jtag newtap $_CHIPNAME jrc -irlen 2 -expected-id $_JRC_TAPID

# GDB target: the ARM.
set _TARGETNAME $_CHIPNAME.arm
target create $_TARGETNAME arm11 -chain-position $_TARGETNAME

# scratch: framebuffer, may be initially unavailable in some chips
$_TARGETNAME configure -work-area-phys 0x40210000
$_TARGETNAME configure -work-area-size 0x00081000
$_TARGETNAME configure -work-area-backup 0

# trace setup ... NOTE, "normal full" mode fudges the real ETMv3.1 mode
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb

# RM_RSTCTRL_WKUP.RST.GS - Trigger a global software reset, and
# give it a chance to finish before we talk to the chip again.
set RM_RSTCTRL_WKUP 0x48008450
$_TARGETNAME configure -event reset-assert \
	"halt; $_TARGETNAME mww $RM_RSTCTRL_WKUP 2; sleep 200"
# TI OMAP3530
# http://focus.ti.com/docs/prod/folders/print/omap3530.html
# Other OMAP3 chips remove DSP and/or the OpenGL support

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME omap3530
}

# ICEpick-C ... used to route Cortex, DSP, and more not shown here
source [find target/icepick.cfg]

# Subsidiary TAP: C64x+ DSP ... must enable via ICEpick
jtag newtap $_CHIPNAME dsp -irlen 38 -ircapture 0x25 -irmask 0x3f -disable

# Subsidiary TAP: CoreSight Debug Access Port (DAP)
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x0b6d602f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 3"

# Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b7ae02f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
	-expected-id $_JRC_TAPID

# GDB target: Cortex-A8, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap

# SRAM: 64K at 0x4020.0000; use the first 16K
$_TARGETNAME configure -work-area-phys 0x40200000 -work-area-size 0x4000

###################

# the reset sequence is event-driven
# and kind of finicky...

# some TCK tycles are required to activate the DEBUG power domain
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"

# have the DAP "always" be active
jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"

proc omap3_dbginit {target} {
     # General Cortex-A8 debug initialisation
     cortex_a dbginit
     # Enable DBGU signal for OMAP353x
     $target mww phys 0x5401d030 0x00002000
}

# be absolutely certain the JTAG clock will work with the worst-case
# 16.8MHz/2 = 8.4MHz core clock, even before a bootloader kicks in.
# OK to speed up *after* PLL and clock tree setup.
adapter speed 1000
$_TARGETNAME configure -event "reset-start" { adapter speed 1000 }

# Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
# ourselves using PRM_RSTCTRL.  RST_GS (2) is a warm reset, like ICEpick
# would issue.  RST_DPLL3 (4) is a cold reset.
set PRM_RSTCTRL 0x48307250
$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww $PRM_RSTCTRL 2"

$_TARGETNAME configure -event reset-assert-post "omap3_dbginit $_TARGETNAME"
# OMAP4430

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME omap4430
}


# Although the OMAP4430 supposedly has an ICEpick-D, only the
# ICEpick-C router commands seem to work.
# See http://processors.wiki.ti.com/index.php/ICEPICK
source [find target/icepick.cfg]


#
# A9 DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x3BA00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 9"


#
# M3 DAPs, one per core
#
if { [info exists M3_DAP_TAPID] } {
	set _M3_DAP_TAPID $M3_DAP_TAPID
} else {
	set _M3_DAP_TAPID 0x4BA00477
}

jtag newtap $_CHIPNAME m31 -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_M3_DAP_TAPID -disable
jtag configure $_CHIPNAME.m31 -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 5"

jtag newtap $_CHIPNAME m30 -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_M3_DAP_TAPID -disable
jtag configure $_CHIPNAME.m30 -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 4"


#
# ICEpick-D JRC (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID  0x3b95c02f
	set _JRC_TAPID2 0x1b85202f
}

# PandaBoard REV EA1 (PEAP platforms)
if { [info exists JRC_TAPID2] } {
	set _JRC_TAPID2 $JRC_TAPID2
} else {
	set _JRC_TAPID2 0x1b85202f
}



jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
	-expected-id $_JRC_TAPID -expected-id $_JRC_TAPID2

# Required by ICEpick to power-up the debug domain
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"


#
# GDB target: Cortex-A9, using DAP
#
# The debugger can connect to either core of the A9, but currently
# not both simultaneously.  Change -coreid to 1 to connect to the
# second core.
#
set _TARGETNAME $_CHIPNAME.cpu

# APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
# 0x80000000 is cpu0 coresight region
#
#
# CORTEX_A8_PADDRDBG_CPU_SHIFT 13
# 0x80000000 | (coreid << CORTEX_A8_PADDRDBG_CPU_SHIFT)

set _coreid 0
set _dbgbase [expr 0x80000000 | ($_coreid << 13)]
echo "Using dbgbase = [format 0x%x $_dbgbase]"

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap \
  -coreid 0 -dbgbase $_dbgbase

# SRAM: 56KiB at 0x4030.0000
$_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000


#
# M3 targets, separate TAP/DAP for each core
#
dap create $_CHIPNAME.m30_dap -chain-position $_CHIPNAME.m30
dap create $_CHIPNAME.m31_dap -chain-position $_CHIPNAME.m31
target create $_CHIPNAME.m30 cortex_m -dap $_CHIPNAME.m30_dap
target create $_CHIPNAME.m31 cortex_m -dap $_CHIPNAME.m31_dap


# Once the JRC is up, enable our TAPs
jtag configure $_CHIPNAME.jrc -event setup "
	jtag tapenable $_CHIPNAME.cpu
	jtag tapenable $_CHIPNAME.m30
	jtag tapenable $_CHIPNAME.m31
"

# Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
# ourselves using PRM_RSTCTRL.  1 is a warm reset, 2 a cold reset.
set PRM_RSTCTRL 0x4A307B00
$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww phys $PRM_RSTCTRL 0x1"
$_CHIPNAME.m30 configure -event reset-assert { }
$_CHIPNAME.m31 configure -event reset-assert { }

# Soft breakpoints don't currently work due to broken cache handling
gdb_breakpoint_override hard
# OMAP4460

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME omap4460
}


# Although the OMAP4430 supposedly has an ICEpick-D, only the
# ICEpick-C router commands seem to work.
# See http://processors.wiki.ti.com/index.php/ICEPICK
source [find target/icepick.cfg]


#
# A9 DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x3BA00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 9"


#
# M3 DAPs, one per core
#
if { [info exists M3_DAP_TAPID] } {
	set _M3_DAP_TAPID $M3_DAP_TAPID
} else {
	set _M3_DAP_TAPID 0x4BA00477
}

jtag newtap $_CHIPNAME m31 -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_M3_DAP_TAPID -disable
jtag configure $_CHIPNAME.m31 -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 5"

jtag newtap $_CHIPNAME m30 -irlen 4 -ircapture 0x1 -irmask 0xf \
	-expected-id $_M3_DAP_TAPID -disable
jtag configure $_CHIPNAME.m30 -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 4"


#
# ICEpick-D JRC (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID  0x2b94e02f
	set _JRC_TAPID2 0x1b85202f
}

# PandaBoard REV EA1 (PEAP platforms)
if { [info exists JRC_TAPID2] } {
	set _JRC_TAPID2 $JRC_TAPID2
} else {
	set _JRC_TAPID2 0x1b85202f
}



jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
	-expected-id $_JRC_TAPID -expected-id $_JRC_TAPID2

# Required by ICEpick to power-up the debug domain
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"


#
# GDB target: Cortex-A9, using DAP
#
# The debugger can connect to either core of the A9, but currently
# not both simultaneously.  Change -coreid to 1 to connect to the
# second core.
#
set _TARGETNAME $_CHIPNAME.cpu

# APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
# 0x80000000 is cpu0 coresight region
#
#
# CORTEX_A8_PADDRDBG_CPU_SHIFT 13
# 0x80000000 | (coreid << CORTEX_A8_PADDRDBG_CPU_SHIFT)

set _coreid 0
set _dbgbase [expr 0x80000000 | ($_coreid << 13)]
echo "Using dbgbase = [format 0x%x $_dbgbase]"

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_a -dap $_CHIPNAME.dap \
  -coreid 0 -dbgbase $_dbgbase

# SRAM: 56KiB at 0x4030.0000
$_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000


#
# M3 targets, separate TAP/DAP for each core
#
dap create $_CHIPNAME.m30_dap -chain-position $_CHIPNAME.m30
dap create $_CHIPNAME.m31_dap -chain-position $_CHIPNAME.m31
target create $_CHIPNAME.m30 cortex_m -dap $_CHIPNAME.m30_dap
target create $_CHIPNAME.m31 cortex_m -dap $_CHIPNAME.m31_dap


# Once the JRC is up, enable our TAPs
jtag configure $_CHIPNAME.jrc -event setup "
	jtag tapenable $_CHIPNAME.cpu
	jtag tapenable $_CHIPNAME.m30
	jtag tapenable $_CHIPNAME.m31
"

# Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
# ourselves using PRM_RSTCTRL.  1 is a warm reset, 2 a cold reset.
set PRM_RSTCTRL 0x4A307B00
$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww phys $PRM_RSTCTRL 0x1"
$_CHIPNAME.m30 configure -event reset-assert { }
$_CHIPNAME.m31 configure -event reset-assert { }

# Soft breakpoints don't currently work due to broken cache handling
gdb_breakpoint_override hard
# TI OMAP5912 dual core processor
# http://focus.ti.com/docs/prod/folders/print/omap5912.html

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME omap5912
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   # NOTE: validated with XOMAP5912 part
   set _CPUTAPID 0x0692602f
}

adapter srst delay 100

# NOTE: presumes irlen 38 is the C55x DSP, matching BSDL for
# its standalone siblings (like TMS320VC5502) of the same era

#jtag scan chain
jtag newtap $_CHIPNAME dsp -irlen 38 -expected-id 0x03df1d81
jtag newtap $_CHIPNAME arm -irlen 4 -expected-id $_CPUTAPID
jtag newtap $_CHIPNAME unknown -irlen 8

set _TARGETNAME $_CHIPNAME.arm
target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME

proc omap5912_reset {} {
	#
	# halt target
	#
	poll
	sleep 1
	halt
	wait_halt
	#
	# disable wdt
	#
	mww 0xfffec808 0x000000f5
	mww 0xfffec808 0x000000a0

	mww 0xfffeb048 0x0000aaaa
	sleep 500
	mww 0xfffeb048 0x00005555
	sleep 500
}

# omap5912 lcd frame buffer as working area
$_TARGETNAME configure -work-area-phys 0x20000000 \
	-work-area-size 0x3e800 -work-area-backup 0
#
# Texas Instruments DaVinci family: OMAPL138
#
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME omapl138
}

source [find target/icepick.cfg]

# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
if { [info exists ETB_TAPID] } {
   set _ETB_TAPID $ETB_TAPID
} else {
   set _ETB_TAPID 0x2b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETB_TAPID -disable
jtag configure $_CHIPNAME.etb -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 3"

# Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
if { [info exists CPU_TAPID] } {
   set _CPU_TAPID $CPU_TAPID
} else {
   set _CPU_TAPID 0x07926001
}
jtag newtap $_CHIPNAME arm -irlen 4 -irmask 0xf -expected-id $_CPU_TAPID -disable
jtag configure $_CHIPNAME.arm -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 2"

# Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b7d102f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version

jtag configure $_CHIPNAME.jrc -event setup \
	"jtag tapenable $_CHIPNAME.etb; jtag tapenable $_CHIPNAME.arm"

################
# GDB target:  the ARM, using SRAM1 for scratch.  SRAM0 (also 8K)
# and the ETB memory (4K) are other options, while trace is unused.
# Little-endian; use the OpenOCD default.
set _TARGETNAME $_CHIPNAME.arm

target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x2000

# be absolutely certain the JTAG clock will work with the worst-case
# CLKIN = 20 MHz (best case: 30 MHz) even when no bootloader turns
# on the PLL and starts using it.  OK to speed up after clock setup.
adapter speed 1500
$_TARGETNAME configure -event "reset-start" { adapter speed 1500 }

arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb

gdb_breakpoint_override hard
arm7_9 dbgrq enable
set  _ENDIAN big

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME or1k
}

if { [info exists TAP_TYPE] } {
   set _TAP_TYPE $TAP_TYPE
} else {
   puts "You need to select a tap type"
   shutdown
}

# Configure the target
if { [string compare $_TAP_TYPE "VJTAG"] == 0 } {
	if { [info exists FPGATAPID] } {
	   set _FPGATAPID $FPGATAPID
	} else {
	   puts "You need to set your FPGA JTAG ID"
		shutdown
	}

	jtag newtap $_CHIPNAME cpu -irlen 10 -expected-id $_FPGATAPID

	set _TARGETNAME $_CHIPNAME.cpu
	target create $_TARGETNAME or1k -endian $_ENDIAN -chain-position $_TARGETNAME

	# Select the TAP core we are using
	tap_select vjtag

} elseif { [string compare $_TAP_TYPE "XILINX_BSCAN"] == 0 } {

	if { [info exists FPGATAPID] } {
	   set _FPGATAPID $FPGATAPID
	} else {
	   puts "You need to set your FPGA JTAG ID"
		shutdown
	}

	jtag newtap $_CHIPNAME cpu -irlen 6 -expected-id $_FPGATAPID

	set _TARGETNAME $_CHIPNAME.cpu
	target create $_TARGETNAME or1k -endian $_ENDIAN -chain-position $_TARGETNAME

	# Select the TAP core we are using
	tap_select xilinx_bscan
} else {
	# OpenCores Mohor JTAG TAP ID
	set _CPUTAPID  0x14951185

	jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID

	set _TARGETNAME $_CHIPNAME.cpu
	target create $_TARGETNAME or1k -endian $_ENDIAN -chain-position $_TARGETNAME

	# Select the TAP core we are using
	tap_select mohor
}

# Select the debug unit core we are using. This debug unit as an option.

set ADBG_USE_HISPEED		1
set ENABLE_JSP_SERVER		2
set ENABLE_JSP_MULTI		4

# If ADBG_USE_HISPEED is set (options bit 1), status bits will be skipped
# on burst reads and writes to improve download speeds.
# This option must match the RTL configured option.

du_select adv [expr $ADBG_USE_HISPEED | $ENABLE_JSP_SERVER | $ENABLE_JSP_MULTI]
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME pic32mx
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x30938053
}

# default working area is 16384
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

adapter srst delay 100
jtag_ntrst_delay 100

#jtag scan chain
#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME

#
# At reset the pic32mx does not allow code execution from RAM
# we have to setup the BMX registers to allow this.
# One limitation is that we loose the first 2k of RAM.
#

global _PIC32MX_DATASIZE
global _WORKAREASIZE
set _PIC32MX_DATASIZE 0x800
set _PIC32MX_PROGSIZE [expr ($_WORKAREASIZE - $_PIC32MX_DATASIZE)]

$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size $_PIC32MX_PROGSIZE -work-area-backup 0
$_TARGETNAME configure -event reset-init {
	#
	# from reset the pic32 cannot execute code in ram - enable ram execution
	# minimum offset from start of ram is 2k
	#
	global _PIC32MX_DATASIZE
	global _WORKAREASIZE

	# BMXCON	set 0 wait state option by clearing BMXWSDRM bit, bit 6
	mww 0xbf882000 0x001f0000
	# BMXDKPBA: 2k kernel data @ 0xa0000000
	mww 0xbf882010 $_PIC32MX_DATASIZE
	# BMXDUDBA: 14k kernel program @ 0xa0000800 - (BMXDUDBA - BMXDKPBA)
	mww 0xbf882020 $_WORKAREASIZE
	# BMXDUPBA: 0k user program - (BMXDUPBA - BMXDUDBA)
	mww 0xbf882030 $_WORKAREASIZE

	#
	# Set system clock to 8Mhz if the default clock configuration is set
	#

	# SYSKEY register, make sure OSCCON is locked
	mww 0xbf80f230 0x0
	# SYSKEY register, write unlock sequence
	mww 0xbf80f230 0xaa996655
	mww 0xbf80f230 0x556699aa
	# OSCCON register + 4, clear OSCCON FRCDIV bits: 24, 25 and 26, divided by 1
	mww 0xbf80f004 0x07000000
	# SYSKEY register, relock OSCCON
	mww 0xbf80f230 0x0
}

set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
# add virtual banks for kseg0 and kseg1
flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME

set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME pic32mx 0x1d000000 0 0 0 $_TARGETNAME
# add virtual banks for kseg0 and kseg1
flash bank vbank2 virtual 0xbd000000 0 0 0 $_TARGETNAME $_FLASHNAME
flash bank vbank3 virtual 0x9d000000 0 0 0 $_TARGETNAME $_FLASHNAME
# script for Cypress PSoC 4 devices

#
# PSoC 4 devices support SWD transports only.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME psoc4
}

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME psoc4 0 0 0 0 $_TARGETNAME

adapter speed 1500

# Reset, bloody PSoC 4 reset
#
# 1) XRES (nSRST) resets also SWD DP so SWD line reset and DP reinit is needed.
# High level adapter stops working after SRST and needs OpenOCD restart.
# If your hw does not use SRST for other circuits, use sysresetreq instead
#
# 2) PSoC 4 executes initialization code from system ROM after reset.
# This code subsequently jumps to user flash reset vector address.
# Unfortunately the system ROM code is protected from reading and debugging.
# Protection breaks vector catch VC_CORERESET used for "reset halt" by cortex_m.
#
# Cypress uses TEST_MODE flag to loop CPU in system ROM before executing code
# from user flash. Programming specifications states that TEST_MODE flag must be
# set in time frame 400 usec delayed about 1 msec from reset.
#
# OpenOCD have no standard way how to set TEST_MODE in specified time frame.
# As a workaround the TEST_MODE flag is set before reset instead.
# It worked for the oldest family PSoC4100/4200 even though it is not guaranteed
# by specification.
#
# Newer families like PSoC 4000, 4100M, 4200M, 4100L, 4200L and PSoC 4 BLE
# clear TEST_MODE flag during device reset so workaround is not possible.
# Use a KitProg adapter for theese devices or "reset halt" will not stop
# before executing user code.
#
# 3) SWD cannot be connected during system initialization after reset.
# This might be a reason for unconnecting ST-Link v2 when deasserting reset.
# As a workaround arp_reset deassert is not called for hla

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

proc psoc4_get_family_id {} {
	set err [catch "mem2array romtable_pid 32 0xF0000FE0 3"]
	if { $err } {
		return 0
	}
	if { [expr $romtable_pid(0) & 0xffffff00 ]
	  || [expr $romtable_pid(1) & 0xffffff00 ]
	  || [expr $romtable_pid(2) & 0xffffff00 ] } {
		echo "Unexpected data in ROMTABLE"
		return 0
	}
	set designer_id [expr (( $romtable_pid(1) & 0xf0 ) >> 4) | (( $romtable_pid(2) & 0xf ) << 4 ) ]
	if { $designer_id != 0xb4 } {
		echo [format "ROMTABLE Designer ID 0x%02x is not Cypress" $designer_id]
		return 0
	}
	set family_id [expr ( $romtable_pid(0) & 0xff ) | (( $romtable_pid(1) & 0xf ) << 8 ) ]
	return $family_id
}

proc ocd_process_reset_inner { MODE } {
	global PSOC4_USE_ACQUIRE PSOC4_TEST_MODE_WORKAROUND
	global _TARGETNAME

	if { 0 != [string compare $_TARGETNAME [target names]] } {
		return -code error "PSoC 4 reset can handle only one $_TARGETNAME target";
	}
	set t $_TARGETNAME

	# If this target must be halted...
	set halt -1
	if { 0 == [string compare $MODE halt] } {
		set halt 1
	}
	if { 0 == [string compare $MODE init] } {
		set halt 1;
	}
	if { 0 == [string compare $MODE run ] } {
		set halt 0;
	}
	if { $halt < 0 } {
		return -code error "Invalid mode: $MODE, must be one of: halt, init, or run";
	}

	if { ! [info exists PSOC4_USE_ACQUIRE] } {
		if { 0 == [string compare [adapter name] kitprog ] } {
			set PSOC4_USE_ACQUIRE 1
		} else {
			set PSOC4_USE_ACQUIRE 0
		}
	}
	if { $PSOC4_USE_ACQUIRE } {
		set PSOC4_TEST_MODE_WORKAROUND 0
	} elseif { ! [info exists PSOC4_TEST_MODE_WORKAROUND] } {
		if { [psoc4_get_family_id] == 0x93 } {
			set PSOC4_TEST_MODE_WORKAROUND 1
		} else {
			set PSOC4_TEST_MODE_WORKAROUND 0
		}
	}

	#$t invoke-event reset-start
	$t invoke-event reset-assert-pre

	if { $halt && $PSOC4_USE_ACQUIRE } {
		catch { [adapter name] acquire_psoc }
		$t arp_examine
	} else {
		if { $PSOC4_TEST_MODE_WORKAROUND } {
			set TEST_MODE 0x40030014
			if { $halt == 1 } {
				catch { mww $TEST_MODE 0x80000000 }
			} else {
				catch { mww $TEST_MODE 0 }
			}
		}

		$t arp_reset assert 0
	}

	$t invoke-event reset-assert-post
	$t invoke-event reset-deassert-pre
	if {![using_hla]} {	# workaround ST-Link v2 fails and forcing reconnect
		$t arp_reset deassert 0
	}
	$t invoke-event reset-deassert-post

	# Pass 1 - Now wait for any halt (requested as part of reset
	# assert/deassert) to happen.  Ideally it takes effect without
	# first executing any instructions.
	if { $halt } {
		# Now PSoC CPU should loop in system ROM
		$t arp_waitstate running 200
		$t arp_halt

		# Catch, but ignore any errors.
		catch { $t arp_waitstate halted 1000 }

		# Did we succeed?
		set s [$t curstate]

		if { 0 != [string compare $s "halted" ] } {
			return -code error [format "TARGET: %s - Not halted" $t]
		}

		# Check if PSoC CPU is stopped in system ROM
		set pc [reg pc]
		regsub {pc[^:]*: } $pc "" pc
		if { $pc < 0x10000000 || $pc > 0x1000ffff } {
			set hint ""
			set family_id [psoc4_get_family_id]
			if { $family_id == 0x93 } {
				set hint ", use 'reset_config none'"
			} elseif { $family_id > 0x93 } {
				set hint ", use a KitProg adapter"
			}
			return -code error [format "TARGET: %s - Not halted in system ROM%s" $t $hint]
		}

		# Set registers to reset vector values
		mem2array value 32 0 2
		reg pc [expr $value(1) & 0xfffffffe ]
		reg msp $value(0)

		if { $PSOC4_TEST_MODE_WORKAROUND } {
			catch { mww $TEST_MODE 0 }
		}
	}

	#Pass 2 - if needed "init"
	if { 0 == [string compare init $MODE] } {
		set err [catch "$t arp_waitstate halted 5000"]

		# Did it halt?
		if { $err == 0 } {
			$t invoke-event reset-init
		}
	}

	$t invoke-event reset-end
}
#
# Cypress PSoC 5LP
#

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME psoc5lp
}

if { [info exists CPUTAPID] } {
	set _CPU_TAPID $CPUTAPID
} else {
	set _CPU_TAPID 0x4BA00477
}

if { [using_jtag] } {
	set _CPU_DAP_ID $_CPU_TAPID
} else {
	set _CPU_DAP_ID 0x2ba01477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_DAP_ID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x2000
}

$_TARGETNAME configure -work-area-phys [expr 0x20000000 - $_WORKAREASIZE / 2] \
                       -work-area-size $_WORKAREASIZE -work-area-backup 0

source [find mem_helper.tcl]

$_TARGETNAME configure -event reset-init {
	# Configure Target Device (PSoC 5LP Device Programming Specification 5.2)

	set PANTHER_DBG_CFG 0x4008000C
	set PANTHER_DBG_CFG_BYPASS [expr 1 << 1]
	mmw $PANTHER_DBG_CFG $PANTHER_DBG_CFG_BYPASS 0

	set PM_ACT_CFG0 0x400043A0
	mww $PM_ACT_CFG0 0xBF

	set FASTCLK_IMO_CR 0x40004200
	set FASTCLK_IMO_CR_F_RANGE_2    [expr 2 << 0]
	set FASTCLK_IMO_CR_F_RANGE_MASK [expr 7 << 0]
	mmw $FASTCLK_IMO_CR $FASTCLK_IMO_CR_F_RANGE_2 $FASTCLK_IMO_CR_F_RANGE_MASK
}

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME psoc5lp 0x00000000 0 0 0 $_TARGETNAME
flash bank $_CHIPNAME.eeprom psoc5lp_eeprom 0x40008000 0 0 0 $_TARGETNAME
flash bank $_CHIPNAME.nvl psoc5lp_nvl 0 0 0 0 $_TARGETNAME

if {![using_hla]} {
	cortex_m reset_config sysresetreq
}
#
# Configuration script for Cypress PSoC6 family of microcontrollers (CY8C6xxx)
# PSoC6 is a dual-core device with CM0+ and CM4 cores. Both cores share
# the same Flash/RAM/MMIO address space.
#

source [find target/swj-dp.tcl]

adapter speed 1000

global _CHIPNAME
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME psoc6
}

global TARGET
set TARGET $_CHIPNAME.cpu

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Is CM0 Debugging enabled ?
global _ENABLE_CM0
if { [info exists ENABLE_CM0] } {
	set _ENABLE_CM0 $ENABLE_CM0
} else {
	set _ENABLE_CM0 1
}

# Is CM4 Debugging enabled ?
global _ENABLE_CM4
if { [info exists ENABLE_CM4] } {
	set _ENABLE_CM4 $ENABLE_CM4
} else {
	set _ENABLE_CM4 1
}

global _WORKAREASIZE_CM0
if { [info exists WORKAREASIZE_CM0] } {
	set _WORKAREASIZE_CM0 $WORKAREASIZE_CM0
} else {
	set _WORKAREASIZE_CM0 0x4000
}

global _WORKAREASIZE_CM4
if { [info exists WORKAREASIZE_CM4] } {
	set _WORKAREASIZE_CM4 $WORKAREASIZE_CM4
} else {
	set _WORKAREASIZE_CM4 0x4000
}

global _WORKAREAADDR_CM0
if { [info exists WORKAREAADDR_CM0] } {
	set _WORKAREAADDR_CM0 $WORKAREAADDR_CM0
} else {
	set _WORKAREAADDR_CM0 0x08000000
}

global _WORKAREAADDR_CM4
if { [info exists WORKAREAADDR_CM4] } {
	set _WORKAREAADDR_CM4 $WORKAREAADDR_CM4
} else {
	set _WORKAREAADDR_CM4 0x08000000
}

proc init_reset { mode } {
	global RESET_MODE
	set RESET_MODE $mode

	if {[using_jtag]} {
		jtag arp_init-reset
	}
}

# Utility to make 'reset halt' work as reset;halt on a target
# It does not prevent running code after reset
proc psoc6_deassert_post { target } {
	# PSoC6 cleared AP registers including TAR during reset
	# Force examine to synchronize OpenOCD target status
	$target arp_examine

	global RESET_MODE
	global TARGET

	if { $RESET_MODE ne "run" } {
		$target arp_poll
		$target arp_poll
		set st [$target curstate]

		if { $st eq "reset" } {
			# we assume running state follows
			# if reset accidentally halts, waiting is useless
			catch { $target arp_waitstate running 100 }
			set st [$target curstate]
		}

		if { $st eq "running" } {
			echo "$target: Ran after reset and before halt..."
			if { $target eq "${TARGET}.cm0" } {
				# Try to cleanly reset whole system
				# and halt the CM0 at entry point
				psoc6 reset_halt
				$target arp_waitstate halted 100
			} else {
				$target arp_halt
			}
		}
	}
}

if { $_ENABLE_CM0 } {
	target create ${TARGET}.cm0 cortex_m -dap $_CHIPNAME.dap -ap-num 1 -coreid 0
	${TARGET}.cm0 configure -work-area-phys $_WORKAREAADDR_CM0 -work-area-size $_WORKAREASIZE_CM0 -work-area-backup 0

	flash bank main_flash_cm0		psoc6 0x10000000 0 0 0 ${TARGET}.cm0
	flash bank work_flash_cm0		psoc6 0x14000000 0 0 0 ${TARGET}.cm0
	flash bank super_flash_user_cm0	psoc6 0x16000800 0 0 0 ${TARGET}.cm0
	flash bank super_flash_nar_cm0	psoc6 0x16001A00 0 0 0 ${TARGET}.cm0
	flash bank super_flash_key_cm0	psoc6 0x16005A00 0 0 0 ${TARGET}.cm0
	flash bank super_flash_toc2_cm0	psoc6 0x16007C00 0 0 0 ${TARGET}.cm0

	${TARGET}.cm0 cortex_m reset_config sysresetreq
	${TARGET}.cm0 configure -event reset-deassert-post "psoc6_deassert_post ${TARGET}.cm0"
}

if { $_ENABLE_CM4 } {
	target create ${TARGET}.cm4 cortex_m -dap $_CHIPNAME.dap -ap-num 2 -coreid 1
	${TARGET}.cm4 configure -work-area-phys $_WORKAREAADDR_CM4 -work-area-size $_WORKAREASIZE_CM4 -work-area-backup 0

	flash bank main_flash_cm4		psoc6 0x10000000 0 0 0 ${TARGET}.cm4
	flash bank work_flash_cm4		psoc6 0x14000000 0 0 0 ${TARGET}.cm4
	flash bank super_flash_user_cm4	psoc6 0x16000800 0 0 0 ${TARGET}.cm4
	flash bank super_flash_nar_cm4	psoc6 0x16001A00 0 0 0 ${TARGET}.cm4
	flash bank super_flash_key_cm4	psoc6 0x16005A00 0 0 0 ${TARGET}.cm4
	flash bank super_flash_toc2_cm4	psoc6 0x16007C00 0 0 0 ${TARGET}.cm4

	${TARGET}.cm4 cortex_m reset_config vectreset
	${TARGET}.cm4 configure -event reset-deassert-post "psoc6_deassert_post ${TARGET}.cm4"
}

if { $_ENABLE_CM0 } {
	# Use CM0+ by default on dual-core devices
	targets ${TARGET}.cm0
}

if {[using_jtag]} {
	jtag newtap $_CHIPNAME bs -irlen 18 -expected-id 0x2e200069
}
# PXA255 chip ... originally from Intel, PXA line was sold to Marvell.
# This chip is now at end-of-life.  Final orders have been taken.

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME pxa255
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x69264013
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME xscale -endian $_ENDIAN \
	-chain-position $_CHIPNAME.cpu

# PXA255 comes out of reset using 3.6864 MHz oscillator.
# Until the PLL kicks in, keep the JTAG clock slow enough
# that we get no errors.
adapter speed 300
$_TARGETNAME configure -event "reset-start" { adapter speed 300 }

# both TRST and SRST are *required* for debug
# DCSR is often accessed with SRST active
reset_config trst_and_srst separate srst_nogate

# reset processing that works with PXA
proc init_reset {mode} {
	# assert both resets; equivalent to power-on reset
	adapter assert trst assert srst

	# drop TRST after at least 32 cycles
	sleep 1
	adapter deassert trst assert srst

	# minimum 32 TCK cycles to wake up the controller
	runtest 50

	# now the TAP will be responsive; validate scanchain
	jtag arp_init

	# ... and take it out of reset
	adapter deassert trst deassert srst
}

proc jtag_init {} {
	init_reset startup
}
#Marvell/Intel PXA270 Script

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME pxa270
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

#IDs for pxa270. Are there more?
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
  # set useful default
   set _CPUTAPID 0x49265013
}

if { [info exists CPUTAPID2] } {
   set _CPUTAPID2 $CPUTAPID2
} else {
  # set useful default
   set _CPUTAPID2 0x79265013
}

if { [info exists CPUTAPID3] } {
   set _CPUTAPID2 $CPUTAPID3
} else {
  # set useful default
   set _CPUTAPID3 0x89265013
}

# set adapter srst delay to the delay introduced by your reset circuit
# the rest of the needed delays are built into the openocd program
adapter srst delay 260
# set the jtag_ntrst_delay to the delay introduced by a reset circuit
# the rest of the needed delays are built into the openocd program
jtag_ntrst_delay 250

set _TARGETNAME $_CHIPNAME.cpu
jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID -expected-id $_CPUTAPID2 -expected-id $_CPUTAPID3

target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME
# maps to PXA internal RAM. If you are using a PXA255
# you must initialize SDRAM or leave this option off
$_TARGETNAME configure -work-area-phys 0x5c000000 -work-area-size 0x10000 -work-area-backup 0
# Marvell PXA3xx

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME pxa3xx
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# IDs for all currently known PXA3xx chips
if { [info exists CPUTAPID_PXA30X_A0] } {
   set _CPUTAPID_PXA30X_A0 $CPUTAPID_PXA30X_A0
} else {
   set _CPUTAPID_PXA30X_A0 0x0E648013
}
if { [info exists CPUTAPID_PXA30X_A1] } {
   set _CPUTAPID_PXA30X_A1 $CPUTAPID_PXA30X_A1
} else {
   set _CPUTAPID_PXA30X_A1 0x1E648013
}
if { [info exists CPUTAPID_PXA31X_A0] } {
   set _CPUTAPID_PXA31X_A0 $CPUTAPID_PXA31X_A0
} else {
   set _CPUTAPID_PXA31X_A0 0x0E649013
}
if { [info exists CPUTAPID_PXA31X_A1] } {
   set _CPUTAPID_PXA31X_A1 $CPUTAPID_PXA31X_A1
} else {
   set _CPUTAPID_PXA31X_A1 0x1E649013
}
if { [info exists CPUTAPID_PXA31X_A2] } {
   set _CPUTAPID_PXA31X_A2 $CPUTAPID_PXA31X_A2
} else {
   set _CPUTAPID_PXA31X_A2 0x2E649013
}
if { [info exists CPUTAPID_PXA31X_B0] } {
   set _CPUTAPID_PXA31X_B0 $CPUTAPID_PXA31X_B0
} else {
   set _CPUTAPID_PXA31X_B0 0x3E649013
}
if { [info exists CPUTAPID_PXA32X_B1] } {
   set _CPUTAPID_PXA32X_B1 $CPUTAPID_PXA32X_B1
} else {
   set _CPUTAPID_PXA32X_B1 0x5E642013
}
if { [info exists CPUTAPID_PXA32X_B2] } {
   set _CPUTAPID_PXA32X_B2 $CPUTAPID_PXA32X_B2
} else {
   set _CPUTAPID_PXA32X_B2 0x6E642013
}
if { [info exists CPUTAPID_PXA32X_C0] } {
   set _CPUTAPID_PXA32X_C0 $CPUTAPID_PXA32X_C0
} else {
   set _CPUTAPID_PXA32X_C0 0x7E642013
}

# set adapter srst delay to the delay introduced by your reset circuit
# the rest of the needed delays are built into the openocd program
adapter srst delay 260

# set the jtag_ntrst_delay to the delay introduced by a reset circuit
# the rest of the needed delays are built into the openocd program
jtag_ntrst_delay 250

set _TARGETNAME $_CHIPNAME.cpu
jtag newtap $_CHIPNAME cpu -irlen 11 -ircapture 0x1 -irmask 0x7f \
	-expected-id $_CPUTAPID_PXA30X_A0 \
	-expected-id $_CPUTAPID_PXA30X_A1 \
	-expected-id $_CPUTAPID_PXA31X_A0 \
	-expected-id $_CPUTAPID_PXA31X_A1 \
	-expected-id $_CPUTAPID_PXA31X_A2 \
	-expected-id $_CPUTAPID_PXA31X_B0 \
	-expected-id $_CPUTAPID_PXA32X_B1 \
	-expected-id $_CPUTAPID_PXA32X_B2 \
	-expected-id $_CPUTAPID_PXA32X_C0

target create $_TARGETNAME xscale -endian $_ENDIAN \
	-chain-position $_TARGETNAME

# work area in internal RAM.
$_TARGETNAME configure -work-area-phys 0x5c030000 -work-area-size 0x10000
# The QCA4531 is a two stream (2x2) 802.11b/g/n single-band programmable
# Wi-Fi System-on-Chip (SoC) for the Internet of Things (IoT).
#
# Product page:
# https://www.qualcomm.com/products/qca4531
#
# Notes:
# - MIPS Processor ID (PRId): 0x00019374
# - 24Kc MIPS processor with 64 KB I-Cache and 32 KB D-Cache,
#   operating at up to 650 MHz
# - External 16-bit DDR1, operating at up to 200 MHz, DDR2 operating at up
#   to 300 MHz
# - TRST is not available.
# - EJTAG PrRst signal is not supported
# - RESET_L pin B56 on the SoC will reset internal JTAG logic.
#
# Pins related for debug and bootstrap:
# Name		Pin		Description
#   JTAG
# JTAG_TCK	GPIO0, (A27)	Software configurable, default JTAG
# JTAG_TDI	GPIO1, (B23)	Software configurable, default JTAG
# JTAG_TDO	GPIO2, (A28)	Software configurable, default JTAG
# JTAG_TMS	GPIO3, (A29)	Software configurable, default JTAG
#   Reset
# RESET_L	-, (B56)	Input only
# SYS_RST_L	GPIO17, (A79)	Output reset request or GPIO
#   Bootstrap
# JTAG_MODE	GPIO16, (A78)	0 - JTAG (Default); 1 - EJTAG
# DDR_SELECT	GPIO10, (A57)	0 - DDR2; 1 - DDR1
#   UART
# UART0_SOUT	GPIO10, (A57)
# UART0_SIN	GPIO9, (B49)

# Per default we need to use "none" variant to be able properly "reset init"
# or "reset halt" the CPU.
reset_config none srst_pulls_trst

# For SRST based variant we still need proper timings.
# For ETH part the reset should be asserted at least for 10ms
# Since there is no other information let's take 100ms to be sure.
adapter srst pulse_width 100

# according to the SoC documentation it should take at least 5ms from
# reset end till bootstrap end. In the practice we need 8ms to get JTAG back
# to live.
adapter srst delay 8

if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME qca4531
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x00000001

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

# provide watchdog helper.
proc disable_watchdog { } {
	mww 0xb8060008 0x0
}

$_TARGETNAME configure -event halted { disable_watchdog }

# Since PrRst is not supported and SRST will reset complete chip
# with JTAG engine, we need to reset CPU from CPU itself.
$_TARGETNAME configure -event reset-assert-pre {
	halt
}

$_TARGETNAME configure -event reset-assert {
	catch "mww 0xb806001C 0x01000000"
}

# To be able to trigger complete chip reset, in case JTAG is blocked
# or CPU not responding, we still can use this helper.
proc full_reset { } {
	reset_config srst_only
	reset
	halt
	reset_config none
}

# Section with helpers which can be used by boards
proc qca4531_ddr2_550_550_init {} {
	# Clear reset flags for different SoC components
	mww 0xb806001c 0xfeceffff
	mww 0xb806001c 0xeeceffff
	mww 0xb806001c 0xe6ceffff

	# PMU configurations
	# Internal Switcher
	mww 0xb8116c40 0x633c8176
	# Increase the DDR voltage
	mww 0xb8116c44 0x10200000
	# XTAL Configurations
	mww 0xb81162c0 0x4b962100
	mww 0xb81162c4 0x480
	mww 0xb81162c8 0x04000144
	# Recommended PLL configurations
	mww 0xb81161c4 0x54086000
	mww 0xb8116244 0x54086000

	# PLL init
	mww 0xb8050008 0x0131001c
	mww 0xb8050000 0x40001580
	mww 0xb8050004 0x40015800
	mww 0xb8050008 0x0131001c
	mww 0xb8050000 0x00001580
	mww 0xb8050004 0x00015800
	mww 0xb8050008 0x01310000
	mww 0xb8050044 0x781003ff
	mww 0xb8050048 0x003c103f

	# DDR2 init
	mww 0xb8000108 0x401f0042
	mww 0xb80000b8 0x0000166d
	mww 0xb8000000 0xcfaaf33b
	mww 0xb800015c 0x0000000f
	mww 0xb8000004 0xa272efa8
	mww 0xb8000018 0x0000ffff
	mww 0xb80000c4 0x74444444
	mww 0xb80000c8 0x00000444
	mww 0xb8000004 0xa210ee28
	mww 0xb8000004 0xa2b2e1a8
	mww 0xb8000010 0x8
	mww 0xb80000bc 0x0
	mww 0xb8000010 0x10
	mww 0xb80000c0 0x0
	mww 0xb8000010 0x40
	mww 0xb800000c 0x2
	mww 0xb8000010 0x2
	mww 0xb8000008 0xb43
	mww 0xb8000010 0x1
	mww 0xb8000010 0x8
	mww 0xb8000010 0x4
	mww 0xb8000010 0x4
	mww 0xb8000008 0xa43
	mww 0xb8000010 0x1
	mww 0xb800000c 0x382
	mww 0xb8000010 0x2
	mww 0xb800000c 0x402
	mww 0xb8000010 0x2
	mww 0xb8000014 0x40be
	mww 0xb800001C 0x20
	mww 0xb8000020 0x20
	mww 0xb80000cc 0xfffff

	# UART GPIO programming
	mww 0xb8040000 0xff30b
	mww 0xb8040044 0x908
	mww 0xb8040034 0x160000
}
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x38289013
}

jtag newtap quark_d20xx quark -irlen 8 -irmask 0xff -expected-id $_CPUTAPID -disable
jtag newtap quark_d20xx cltap -irlen 8 -irmask 0xff -expected-id 0x0e786013 -enable

proc quark_d20xx_tapenable {} {
	echo "enabling quark core tap"
	irscan quark_d20xx.cltap 0x11
	drscan quark_d20xx.cltap 12 1
	runtest 10
}

proc quark_d20xx_tapdisable {} {
	echo "disabling quark core tap"
	irscan quark_d20xx.cltap 0x11
	drscan quark_d20xx.cltap 12 0
	runtest 10
}

proc quark_d20xx_setup {} {
	jtag tapenable quark_d20xx.quark
}

jtag configure quark_d20xx.quark -event tap-enable \
   "quark_d20xx_tapenable"

jtag configure quark_d20xx.quark -event tap-disable \
   "quark_d20xx_tapdisable"

target create quark_d20xx.quark quark_d20xx -endian little -chain-position quark_d20xx.quark

quark_d20xx.quark configure -event reset-start {
	# need to halt the target to write to memory
	if {[quark_d20xx.quark curstate] ne "halted"} { halt }
	# set resetbreak via the core tap
	irscan quark_d20xx.quark 0x35 ; drscan quark_d20xx.quark 1 0x1
	# trigger a warm reset
	mww 0xb0800570 0x2
	# clear resetbreak
	irscan quark_d20xx.quark 0x35 ; drscan quark_d20xx.quark 1 0x0
}

jtag configure quark_d20xx.quark -event setup \
   "quark_d20xx_setup"
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME quark_x10xx
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}


if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x18289013
}

jtag newtap quark_x10xx cpu   -irlen 8  -irmask 0xff  -expected-id   $_CPUTAPID  -disable
jtag newtap quark_x10xx cltap -irlen 8  -irmask 0xff  -expected-id   0x0e681013  -enable

#openocd puts tap at front of chain not end of chain
proc quark_x10xx_tapenable {} {
	echo "enabling core tap"
	irscan quark_x10xx.cltap 0x11
	drscan quark_x10xx.cltap 64 1
	runtest 10
}

proc quark_x10xx_tapdisable {} {
	echo "disabling core tap"
	irscan quark_x10xx.cltap 0x11
	drscan quark_x10xx.cltap 64 0
	runtest 10
}

proc quark_x10xx_setup {} {
	jtag tapenable quark_x10xx.cpu
}

jtag configure $_CHIPNAME.cpu -event tap-enable \
   "quark_x10xx_tapenable"

jtag configure $_CHIPNAME.cpu -event tap-disable \
   "quark_x10xx_tapdisable"

set _TARGETNAME $_CHIPNAME.cpu
target create quark_x10xx.cpu quark_x10xx -endian $_ENDIAN -chain-position quark_x10xx.cpu

jtag configure $_CHIPNAME.cpu -event setup \
   "quark_x10xx_setup"
Prerequisites:
The users of OpenOCD as well as computer programs interacting with OpenOCD are expecting that certain commands
do the same thing across all the targets.

Rules to follow when writing scripts:

1. The configuration script should be defined such as , for example, the following sequences are working:
	reset
	flash info <bank>
and
	reset
	flash erase_address <start> <len>
and
	reset init
	load

In most cases this can be accomplished by specifying the default startup mode as reset_init (target command
in the configuration file).

2. If the target is correctly configured, flash must be writable without any other helper commands. It is
assumed that all write-protect mechanisms should be disabled.

3. The configuration scripts should be defined such as the binary that was written to flash verifies
(turn off remapping, checksums, etc...)

flash write_image [file] <parameters>
verify_image [file] <parameters>

4. adapter speed sets the maximum speed (or alternatively RCLK). If invoked
multiple times only the last setting is used.

interface/xxx.cfg files are always executed *before* target/xxx.cfg
files, so any adapter speed in interface/xxx.cfg will be overridden by
target/xxx.cfg. adapter speed in interface/xxx.cfg would then, effectively,
set the default JTAG speed.

Note that a target/xxx.cfg file can invoke another target/yyy.cfg file,
so one can create target subtype configurations where e.g. only
amount of DRAM, oscillator speeds differ and having a single
config file for the default/common settings.
# Renesas RZ/A1H
# https://www.renesas.com/eu/en/products/microcontrollers-microprocessors/rz/rza/rza1h.html

if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME r7s72100
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f -expected-id $_DAP_TAPID

# Configuring only one core using DAP.
# Base addresses of cores:
#  core 0  -  0x80030000
set _TARGETNAME $_CHIPNAME.ca9
dap create ${_CHIPNAME}.dap -chain-position $_CHIPNAME.cpu
target create ${_TARGETNAME} cortex_a -dap ${_CHIPNAME}.dap -coreid 0 -dbgbase 0x80030000

targets ${_TARGETNAME}
# Renesas R-Car Generation 2 SOCs
# - There are a combination of Cortex-A15s and Cortex-A7s for each Gen2 SOC
# - Each SOC can boot through any of the, up to 2, core types that it has
#   e.g. H2 can boot through Cortex-A15 or Cortex-A7

# Supported Gen2 SOCs and their cores:
# H2:  Cortex-A15 x 4, Cortex-A7 x 4
# M2:  Cortex-A15 x 2
# V2H: Cortex-A15 x 2
# M2N: Cortex-A15 x 2
# E2:                  Cortex-A7 x 2

# Usage:
# There are 2 configuration options:
# SOC:       Selects the supported SOC. (Default 'H2')
# BOOT_CORE: Selects the booting core. 'CA15', or 'CA7'
#            Defaults to 'CA15' if the SOC has one, else defaults to 'CA7'

if { [info exists SOC] } {
	set _soc $SOC
} else {
	set _soc H2
}

# Set configuration for each SOC and the default 'BOOT_CORE'
switch $_soc {
	H2 {
		set _CHIPNAME r8a7790
		set _num_ca15 4
		set _num_ca7 4
		set _boot_core CA15
	}
	M2 {
		set _CHIPNAME r8a7791
		set _num_ca15 2
		set _num_ca7 0
		set _boot_core CA15
	}
	V2H {
		set _CHIPNAME r8a7792
		set _num_ca15 2
		set _num_ca7 0
		set _boot_core CA15
	}
	M2N {
		set _CHIPNAME r8a7793
		set _num_ca15 2
		set _num_ca7 0
		set _boot_core CA15
	}
	E2 {
		set _CHIPNAME r8a7794
		set _num_ca15 0
		set _num_ca7 2
		set _boot_core CA7
	}
	default {
		error "'$_soc' is invalid!"
	}
}

# If configured, override the default 'CHIPNAME'
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
}

# If configured, override the default 'BOOT_CORE'
if { [info exists BOOT_CORE] } {
	set _boot_core $BOOT_CORE
}

if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

echo "\t$_soc - $_num_ca15 CA15(s), $_num_ca7 CA7(s)"
echo "\tBoot Core - $_boot_core\n"

set _DAPNAME $_CHIPNAME.dap

# TAP and DAP
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f -expected-id $_DAP_TAPID
dap create $_DAPNAME -chain-position $_CHIPNAME.cpu

set CA15_DBGBASE {0x800B0000 0x800B2000 0x800B4000 0x800B6000}
set CA7_DBGBASE  {0x800F0000 0x800F2000 0x800F4000 0x800F6000}

set smp_targets ""

proc setup_ca {core_name dbgbase num boot} {
	global _CHIPNAME
	global _DAPNAME
	global smp_targets
	for { set _core 0 } { $_core < $num } { incr _core } {
		set _TARGETNAME $_CHIPNAME.$core_name.$_core
		set _CTINAME $_TARGETNAME.cti
		set _command "target create $_TARGETNAME cortex_a -dap $_DAPNAME \
			-coreid $_core -dbgbase [lindex $dbgbase $_core]"
		if { $_core == 0  && $boot == 1 } {
			set _targets "$_TARGETNAME"
		} else {
			set _command "$_command -defer-examine"
		}
		set smp_targets "$smp_targets $_TARGETNAME"
		eval $_command
	}
}

# Organize target list based on the boot core
if { [string equal $_boot_core CA15] } {
	setup_ca a15 $CA15_DBGBASE $_num_ca15 1
	setup_ca a7  $CA7_DBGBASE  $_num_ca7 0
} elseif { [string equal $_boot_core CA7] } {
	setup_ca a7  $CA7_DBGBASE  $_num_ca7 1
	setup_ca a15 $CA15_DBGBASE $_num_ca15 0
} else {
	setup_ca a15 $CA15_DBGBASE $_num_ca15 0
	setup_ca a7  $CA7_DBGBASE  $_num_ca7 0
}

source [find target/renesas_rcar_reset_common.cfg]

eval "target smp $smp_targets"
# Renesas R-Car Generation 3 SOCs
# - There are a combination of Cortex-A57s, Cortex-A53s, and Cortex-R7 for each Gen3 SOC
# - Each SOC can boot through any of the, up to 3, core types that it has
#   e.g. H3 can boot through Cortex-A57, Cortex-A53, or Cortex-R7

# Supported Gen3 SOCs and their cores:
#  H3: Cortex-A57 x 4, Cortex-A53 x 4, Cortex-R7 x 2 (Lock-Step)
# M3W: Cortex-A57 x 2, Cortex-A53 x 4, Cortex-R7 x 2 (Lock-Step)
# M3N: Cortex-A57 x 2,                 Cortex-R7 x 2 (Lock-Step)
# V3H:                 Cortex-A53 x 4, Cortex-R7 x 2 (Lock-Step)
# V3M:                 Cortex-A53 x 2, Cortex-R7 x 2 (Lock-Step)
#  E3:                 Cortex-A53 x 1, Cortex-R7 x 2 (Lock-Step)
#  D3:                 Cortex-A53 x 1

# Usage:
# There are 2 configuration options:
# SOC:       Selects the supported SOC. (Default 'H3')
# BOOT_CORE: Selects the booting core. 'CA57', 'CA53', or 'CR7'
#            Defaults to 'CA57' if the SOC has one, else defaults to 'CA53'

if { [info exists SOC] } {
	set _soc $SOC
} else {
	set _soc H3
}

# Set configuration for each SOC and the default 'BOOT_CORE'
switch $_soc {
	H3 {
		set _CHIPNAME r8a77950
		set _num_ca57 4
		set _num_ca53 4
		set _num_cr7 1
		set _boot_core CA57
	}
	M3W {
		set _CHIPNAME r8a77960
		set _num_ca57 2
		set _num_ca53 4
		set _num_cr7 1
		set _boot_core CA57
	}
	M3N {
		set _CHIPNAME r8a77965
		set _num_ca57 2
		set _num_ca53 4
		set _num_cr7 1
		set _boot_core CA57
	}
	V3M {
		set _CHIPNAME r8a77970
		set _num_ca57 0
		set _num_ca53 2
		set _num_cr7 1
		set _boot_core CA53
	}
	V3H {
		set _CHIPNAME r8a77980
		set _num_ca57 0
		set _num_ca53 4
		set _num_cr7 1
		set _boot_core CA53
	}
	E3 {
		set _CHIPNAME r8a77990
		set _num_ca57 0
		set _num_ca53 1
		set _num_cr7 1
		set _boot_core CA53
	}
	D3 {
		set _CHIPNAME r8a77995
		set _num_ca57 0
		set _num_ca53 1
		set _num_cr7 0
		set _boot_core CA53
	}
	default {
		error "'$_soc' is invalid!"
	}
}

# If configured, override the default 'CHIPNAME'
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
}

# If configured, override the default 'BOOT_CORE'
if { [info exists BOOT_CORE] } {
	set _boot_core $BOOT_CORE
}

if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x5ba00477
}

echo "\t$_soc - $_num_ca57 CA57(s), $_num_ca53 CA53(s), $_num_cr7 CR7(s)"
echo "\tBoot Core - $_boot_core\n"

set _DAPNAME $_CHIPNAME.dap

# TAP and DAP
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f -expected-id $_DAP_TAPID
dap create $_DAPNAME -chain-position $_CHIPNAME.cpu

set CA57_DBGBASE {0x80410000 0x80510000 0x80610000 0x80710000}
set CA57_CTIBASE {0x80420000 0x80520000 0x80620000 0x80720000}
set CA53_DBGBASE {0x80C10000 0x80D10000 0x80E10000 0x80F10000}
set CA53_CTIBASE {0x80C20000 0x80D20000 0x80E20000 0x80F20000}
set  CR7_DBGBASE 0x80910000
set  CR7_CTIBASE 0x80918000

set smp_targets ""

proc setup_a5x {core_name dbgbase ctibase num boot} {
	global _CHIPNAME
	global _DAPNAME
	global smp_targets
	for { set _core 0 } { $_core < $num } { incr _core } {
		set _TARGETNAME $_CHIPNAME.$core_name.$_core
		set _CTINAME $_TARGETNAME.cti
		cti create $_CTINAME -dap $_DAPNAME -ap-num 1 \
			-baseaddr [lindex $ctibase $_core]
		set _command "target create $_TARGETNAME aarch64 -dap $_DAPNAME \
			-ap-num 1 -dbgbase [lindex $dbgbase $_core] -cti $_CTINAME"
		if { $_core == 0  && $boot == 1 } {
			set _targets "$_TARGETNAME"
		} else {
			set _command "$_command -defer-examine"
		}
		set smp_targets "$smp_targets $_TARGETNAME"
		eval $_command
	}
}

proc setup_cr7 {dbgbase ctibase boot} {
	global _CHIPNAME
	global _DAPNAME
	set _TARGETNAME $_CHIPNAME.r7
	set _CTINAME $_TARGETNAME.cti
	cti create $_CTINAME -dap $_DAPNAME -ap-num 1 -baseaddr $ctibase
	set _command "target create $_TARGETNAME cortex_r4 -dap $_DAPNAME \
		-ap-num 1 -dbgbase $dbgbase"
	if { $boot == 1 } {
		set _targets "$_TARGETNAME"
	} else {
		set _command "$_command -defer-examine"
	}
	eval $_command
}

# Organize target list based on the boot core
if { [string equal $_boot_core CA57] } {
	setup_a5x a57 $CA57_DBGBASE $CA57_CTIBASE $_num_ca57 1
	setup_a5x a53 $CA53_DBGBASE $CA53_CTIBASE $_num_ca53 0
	setup_cr7 $CR7_DBGBASE $CR7_CTIBASE 0
} elseif { [string equal $_boot_core CA53] } {
	setup_a5x a53 $CA53_DBGBASE $CA53_CTIBASE $_num_ca53 1
	setup_a5x a57 $CA57_DBGBASE $CA57_CTIBASE $_num_ca57 0
	setup_cr7 $CR7_DBGBASE $CR7_CTIBASE 0
} else {
	setup_cr7 $CR7_DBGBASE $CR7_CTIBASE 1
	setup_a5x a57 $CA57_DBGBASE $CA57_CTIBASE $_num_ca57 0
	setup_a5x a53 $CA53_DBGBASE $CA53_CTIBASE $_num_ca53 0
}

source [find target/renesas_rcar_reset_common.cfg]

eval "target smp $smp_targets"
# Renesas R-Car Gen2 Evaluation Board common settings

reset_config trst_and_srst srst_nogate

proc init_reset {mode} {
    # Assert both resets: equivalent to a power-on reset
    adapter assert trst assert srst

    # Deassert TRST to begin TAP communication
    adapter deassert trst assert srst

    # TAP should now be responsive, validate the scan-chain
    jtag arp_init
}
#
# Renesas Synergy S7 G2 w/ ARM Cortex-M4 @ 240 MHz
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME s7g2
}

if { [info exists CPU_JTAG_TAPID] } {
	set _CPU_JTAG_TAPID $CPU_JTAG_TAPID
} else {
	set _CPU_JTAG_TAPID 0x5ba00477
}

if { [info exists CPU_SWD_TAPID] } {
	set _CPU_SWD_TAPID $CPU_SWD_TAPID
} else {
	set _CPU_SWD_TAPID 0x5ba02477
}

source [find target/swj-dp.tcl]

if { [using_jtag] } {
	set _CPU_TAPID $_CPU_JTAG_TAPID
} else {
	set _CPU_TAPID $_CPU_SWD_TAPID
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	# 640 KB On-Chip SRAM
	set _WORKAREASIZE 0xa0000
}

$_TARGETNAME configure -work-area-phys 0x1ffe0000 \
                       -work-area-size $_WORKAREASIZE -work-area-backup 0

if { ![using_hla] } {
	cortex_m reset_config sysresetreq
}

adapter speed 1000
# Rockchip RK3308 Target
# https://rockchip.fr/RK3308%20datasheet%20V1.5.pdf
# https://dl.radxa.com/rockpis/docs/hw/datasheets/Rockchip%20RK3308TRM%20V1.1%20Part1-20180810.pdf

if { [info exists CHIPNAME] } {
  set _CHIPNAME $CHIPNAME
} else {
  set _CHIPNAME rk3308
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x2ba01477
}

adapter speed 12000

transport select swd

# declare the one SWD tap to access the DAP
swd newdap $_CHIPNAME cpu -expected-id $_DAP_TAPID -ignore-version

# create the DAP
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_CHIPNAME.ahb mem_ap -dap $_CHIPNAME.dap -ap-num 0

# declare the 4 main application cores
set _TARGETNAME $_CHIPNAME.core
set _smp_command ""

set $_TARGETNAME.base(0) 0x81010000
set $_TARGETNAME.base(1) 0x81012000
set $_TARGETNAME.base(2) 0x81014000
set $_TARGETNAME.base(3) 0x81016000

set $_TARGETNAME.cti(0) 0x81018000
set $_TARGETNAME.cti(1) 0x81019000
set $_TARGETNAME.cti(2) 0x8101a000
set $_TARGETNAME.cti(3) 0x8101b000

set _cores 4
for { set _core 0 } { $_core < $_cores } { incr _core 1 } {

    cti create cti$_core -dap $_CHIPNAME.dap -baseaddr [set $_TARGETNAME.cti($_core)] -ap-num 0

    set _command "target create ${_TARGETNAME}$_core aarch64 \
                         -dap $_CHIPNAME.dap -coreid $_core -cti cti$_core \
                         -dbgbase [set $_TARGETNAME.base($_core)]"

    if { $_core != 0 } {
        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
        set _command "$_command -defer-examine"
    } else {
        # uncomment to use hardware threads pseudo rtos
        # set _command "$_command -rtos hwthread"
        set _command "$_command -work-area-size 0x40000 -work-area-phys 0xfff80000 \
                                -work-area-backup 0"
        set _smp_command "target smp ${_TARGETNAME}$_core"
    }

    eval $_command
}

eval $_smp_command

targets ${_TARGETNAME}0
# Found on the 'TinCanTools' Hammer board.

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME s3c2410
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # This config file was defaulting to big endian..
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   # Force an error until we get a good number.
   set _CPUTAPID 0xffffffff
}

#use combined on interfaces or targets that cannot set TRST/SRST separately
reset_config trst_and_srst

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x30800000 -work-area-size 0x20000 -work-area-backup 0

# speed up memory downloads
arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable
# Target configuration for the Samsung 2440 system on chip
# Tested on a S3C2440 Evaluation board by keesj
# Processor       : ARM920Tid(wb) rev 0 (v4l)
# Info:   JTAG tap: s3c2440.cpu tap/device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME s3c2440
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a bigendian
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0032409d
}

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x200000 -work-area-size 0x4000 -work-area-backup 1

#reset configuration
reset_config trst_and_srst
# Target configuration for the Samsung 2450 system on chip
# Processor       : ARM926ejs (wb) rev 0 (v4l)
# Info:   JTAG tap: s3c2450.cpu tap/device found: 0x07926F0F


# FIX!!! what to use here?
#
# RCLK?
#
# adapter speed 0
#
# Really low clock during reset?
#
# adapter speed 1

if { [info exists CHIPNAME] } {
  set _CHIPNAME $CHIPNAME
} else {
  set _CHIPNAME s3c2450
}

if { [info exists ENDIAN] } {
  set _ENDIAN $ENDIAN
} else {
 # this defaults to a bigendian
  set _ENDIAN little
}

if { [info exists CPUTAPID] } {
  set _CPUTAPID $CPUTAPID
} else {
  set _CPUTAPID 0x07926f0f
}

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0xE -irmask 0x0f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

# FIX!!!!! should this really use srst_pulls_trst?
# With srst_pulls_trst "reset halt" will not reset into the
# halted mode, but rather "reset run" and then halt the target.
#
# However, without "srst_pulls_trst", then "reset halt" produces weird
# errors:
# WARNING: unknown debug reason: 0x0
reset_config trst_and_srst
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME s3c4510
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}


# This appears to be a "Version 1" arm7tdmi.
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x1f0f0f0f
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
# -*- tcl -*-
# Target configuration for the Samsung s3c6410 system on chip
# Tested on a SMDK6410
# Processor       : ARM1176
# Info:   JTAG device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
# [Duane Ellis 27/nov/2008: Above 0x0032409d appears to be copy/paste from other places]
# [and I do not believe it to be accurate, hence the 0xffffffff below]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME s3c6410
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
  # this defaults to a bigendian
   set _ENDIAN little
}

# trace buffer
if { [info exists ETBTAPID] } {
   set _ETBTAPID $ETBTAPID
} else {
   set _ETBTAPID 0x2b900f0f
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07b76f0f
}

#jtag scan chain

jtag newtap $_CHIPNAME etb -irlen 4 -expected-id $_ETBTAPID
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME

adapter srst delay 500
jtag_ntrst_delay 500

#reset configuration
reset_config trst_and_srst

# trace setup ... NOTE, "normal full" mode fudges the real ETMv3.1 mode
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
reset_config srst_only srst_pulls_trst

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME lh79532
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
  # sharp changed the number!
   set _CPUTAPID 0x00002061
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
#
# Silicon Laboratories SiM3x Cortex-M3
#

# SiM3x devices support both JTAG and SWD transports.
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME SiM3x
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4ba00477
}

if { [info exists CPURAMSIZE] } {
  set _CPURAMSIZE $CPURAMSIZE
} else {
# Minimum size of RAM in the Silicon Labs product matrix (8KB)
	set _CPURAMSIZE 0x2000
}

if { [info exists CPUROMSIZE] } {
  set _CPUROMSIZE $CPUROMSIZE
} else {
# Minimum size of FLASH in the Silicon Labs product matrix (32KB)
	set _CPUROMSIZE 0x8000
}

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE $_CPURAMSIZE
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME sim3x 0 $_CPUROMSIZE 0 0 $_TARGETNAME

adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}
# script for Sigma Designs SMP8634 (eventually even SMP8635)

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME smp8634
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x08630001
}

adapter srst delay 100
jtag_ntrst_delay 100

reset_config trst_and_srst separate

# jtag scan chain
# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian $_ENDIAN
#  Copyright (C) 2014-2015,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
#  SPDX-License-Identifier: GPL-2.0-or-later

#
# Xilinx Spartan-6 XC6SLX45  FPGA on EM Starter Kit v1.
# Xilinx Spartan-6 XC6SLX150 FPGA on EM Starter Kit v2.
#

source [find cpu/arc/em.tcl]

set _CHIPNAME arc-em
set _TARGETNAME $_CHIPNAME.cpu

# EM SK IDENTITY is 0x200444b1
# EM SK v2 IDENTITY is 0x200044b1
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200444b1 \
  -expected-id 0x200044b1

set _coreid 0
set _dbgbase [expr 0x00000000 | ($_coreid << 13)]

target create $_TARGETNAME arcv2 -chain-position $_TARGETNAME \
  -coreid 0 -dbgbase $_dbgbase -endian little

# There is no SRST, so do a software reset
$_TARGETNAME configure -event reset-assert "arc_em_reset $_TARGETNAME"

arc_em_init_regs

# vim:ft=tcl
#  Copyright (C) 2019,2020 Synopsys, Inc.
#  Anton Kolesov <anton.kolesov@synopsys.com>
#  Didin Evgeniy <didin@synopsys.com>
#
# SPDX-License-Identifier: GPL-2.0-or-later

#
# HS Development Kit SoC.
#
# Contains quad-core ARC HS38.
#

source [find cpu/arc/hs.tcl]

set _coreid 0
set _dbgbase [expr ($_coreid << 13)]

# CHIPNAME will be used to choose core family (600, 700 or EM). As far as
# OpenOCD is concerned EM and HS are identical.
set _CHIPNAME arc-em

# OpenOCD discovers JTAG TAPs in reverse order.

# ARC HS38 core 4
set _TARGETNAME $_CHIPNAME.cpu4
jtag newtap $_CHIPNAME cpu4 -irlen 4 -ircapture 0x1 -expected-id 0x200c24b1

target create $_TARGETNAME arcv2 -chain-position $_TARGETNAME
$_TARGETNAME configure -coreid $_coreid
$_TARGETNAME configure -dbgbase $_dbgbase
# Flush L2$.
$_TARGETNAME configure -event reset-assert "arc_hs_reset $_TARGETNAME"
set _coreid [expr $_coreid + 1]
set _dbgbase [expr ($_coreid << 13)]

arc_hs_init_regs

# Enable L2 cache support for core 4.
$_TARGETNAME arc cache l2 auto 1

# ARC HS38 core 3
set _TARGETNAME $_CHIPNAME.cpu3
jtag newtap $_CHIPNAME cpu3 -irlen 4 -ircapture 0x1 -expected-id 0x200824b1

target create $_TARGETNAME arcv2 -chain-position $_TARGETNAME
$_TARGETNAME configure -coreid $_coreid
$_TARGETNAME configure -dbgbase $_dbgbase
$_TARGETNAME configure -event reset-assert "arc_common_reset $_TARGETNAME"
set _coreid [expr $_coreid + 1]
set _dbgbase [expr ($_coreid << 13)]

arc_hs_init_regs

# Enable L2 cache support for core 3.
$_TARGETNAME arc cache l2 auto 1

# ARC HS38 core 2
set _TARGETNAME $_CHIPNAME.cpu2
jtag newtap $_CHIPNAME cpu2 -irlen 4 -ircapture 0x1 -expected-id 0x200424b1

target create $_TARGETNAME arcv2 -chain-position $_TARGETNAME
$_TARGETNAME configure -coreid $_coreid
$_TARGETNAME configure -dbgbase $_dbgbase
$_TARGETNAME configure -event reset-assert "arc_common_reset $_TARGETNAME"
set _coreid [expr $_coreid + 1]
set _dbgbase [expr ($_coreid << 13)]

arc_hs_init_regs

# Enable L2 cache support for core 2.
$_TARGETNAME arc cache l2 auto 1

# ARC HS38 core 1
set _TARGETNAME $_CHIPNAME.cpu1
jtag newtap $_CHIPNAME cpu1 -irlen 4 -ircapture 0x1 -expected-id 0x200024b1

target create $_TARGETNAME arcv2 -chain-position $_TARGETNAME
$_TARGETNAME configure -coreid $_coreid
$_TARGETNAME configure -dbgbase $_dbgbase
$_TARGETNAME configure -event reset-assert "arc_common_reset $_TARGETNAME"
set _coreid [expr $_coreid + 1]
set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
arc_hs_init_regs

# Enable L2 cache support for core 1.
$_TARGETNAME arc cache l2 auto 1
# Target configuration for the ST SPEAr3xx family of system on chip
# Supported SPEAr300, SPEAr310, SPEAr320
# http://www.st.com/spear
#
# Processor: ARM926ejs
# Info:      JTAG tap: spear3xx.cpu tap/device found: 0x07926041
# Date:      2009-10-31
# Author:    Antonio Borneo <borneo.antonio@gmail.com>

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME spear3xx
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x07926041
}

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x03 \
	-expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN \
	-chain-position $_TARGETNAME

# SPEAr3xx has a 8K block of sram @ 0xd280.0000
# REVISIT: what OS puts virtual address equal to phys?
$_TARGETNAME configure \
	-work-area-virt 0xd2800000 \
	-work-area-phys 0xd2800000 \
	-work-area-size 0x2000 \
	-work-area-backup 0
# TI/Luminary Stellaris LM3S chip family

# Some devices have errata in returning their device class.
# DEVICECLASS is provided as a manual override
# Manual setting of a device class of 0xff is not allowed

global _DEVICECLASS

if { [info exists DEVICECLASS] } {
   set _DEVICECLASS $DEVICECLASS
} else {
   set _DEVICECLASS 0xff
}

# Luminary chips support both JTAG and SWD transports.
# Adapt based on what transport is active.
source [find target/swj-dp.tcl]

# For now we ignore the SPI and UART options, which
# are usable only for ISP style initial flash programming.

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME lm3s
}

# CPU TAP ID 0x1ba00477 for early Sandstorm parts
# CPU TAP ID 0x2ba00477 for later SandStorm parts, e.g. lm3s811 Rev C2
# CPU TAP ID 0x3ba00477 for Cortex-M3 r1p2 (on Fury, DustDevil)
# CPU TAP ID 0x4ba00477 for Cortex-M3 r2p0 (on Tempest, Firestorm)
# CPU TAP ID 0x4ba00477 for Cortex-M4 r0p1 (on Blizzard)
# ... we'll ignore the JTAG version field, rather than list every
# chip revision that turns up.
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0ba00477
}

# SWD DAP, and JTAG TAP, take same params for now;
# ... even though SWD ignores all except TAPID, and
# JTAG shouldn't need anything more then irlen. (and TAPID).
swj_newdap $_CHIPNAME cpu -irlen 4 -irmask 0xf \
    -expected-id $_CPUTAPID -ignore-version
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   # default to 2K working area
   set _WORKAREASIZE 0x800
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

# 8K working area at base of ram, not backed up
#
# NOTE: you may need or want to reconfigure the work area;
# some parts have just 6K, and you may want to use other
# addresses (at end of mem not beginning) or back it up.
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE

# JTAG speed ... slow enough to work with a 12 MHz RC oscillator;
# LM3S parts don't support RTCK
#
# NOTE: this may be increased by a reset-init handler, after it
# configures and enables the PLL.  Or you might need to decrease
# this, if you're using a slower clock.
adapter speed 500

source [find mem_helper.tcl]

proc reset_peripherals {family} {

	source [find chip/ti/lm3s/lm3s.tcl]

	echo "Resetting Core Peripherals"

	# Disable the PLL and the system clock divider (nop if disabled)
	mmw $SYSCTL_RCC 0 $SYSCTL_RCC_USESYSDIV
	mmw $SYSCTL_RCC2 $SYSCTL_RCC2_BYPASS2 0

	# RCC and RCC2 to their reset values
	mww $SYSCTL_RCC [expr (0x078e3ad0 | ([mrw $SYSCTL_RCC] & $SYSCTL_RCC_MOSCDIS))]
	mww $SYSCTL_RCC2 0x07806810
	mww $SYSCTL_RCC 0x078e3ad1

	# Reset the deep sleep clock configuration register
	mww $SYSCTL_DSLPCLKCFG 0x07800000

	# Reset the clock gating registers
	mww $SYSCTL_RCGC0 0x00000040
	mww $SYSCTL_RCGC1 0
	mww $SYSCTL_RCGC2 0
	mww $SYSCTL_SCGC0 0x00000040
	mww $SYSCTL_SCGC1 0
	mww $SYSCTL_SCGC2 0
	mww $SYSCTL_DCGC0 0x00000040
	mww $SYSCTL_DCGC1 0
	mww $SYSCTL_DCGC2 0

	# Reset the remaining SysCtl registers
	mww $SYSCTL_PBORCTL 0
	mww $SYSCTL_IMC 0
	mww $SYSCTL_GPIOHBCTL 0
	mww $SYSCTL_MOSCCTL 0
	mww $SYSCTL_PIOSCCAL 0
	mww $SYSCTL_I2SMCLKCFG 0

	# Reset the peripherals
	mww $SYSCTL_SRCR0 0xffffffff
	mww $SYSCTL_SRCR1 0xffffffff
	mww $SYSCTL_SRCR2 0xffffffff
	mww $SYSCTL_SRCR0 0
	mww $SYSCTL_SRCR1 0
	mww $SYSCTL_SRCR2 0

	# Clear any pending SysCtl interrupts
	mww $SYSCTL_MISC 0xffffffff

	# Wait for any pending flash operations to complete
	while {[expr [mrw $FLASH_FMC] & 0xffff] != 0} { sleep 1 }
	while {[expr [mrw $FLASH_FMC2] & 0xffff] != 0} { sleep 1 }

	# Reset the flash controller registers
	mww $FLASH_FMA 0
	mww $FLASH_FCIM 0
	mww $FLASH_FCMISC 0xffffffff
	mww $FLASH_FWBVAL 0
}

$_TARGETNAME configure -event reset-start {
	adapter speed 500

	#
	# When nRST is asserted on most Stellaris devices, it clears some of
	# the debug state.  The ARMv7M and Cortex-M3 TRMs say that's wrong;
	# and OpenOCD depends on those TRMs.  So we won't use SRST on those
	# chips.  (Only power-on reset should affect debug state, beyond a
	# few specified bits; not the chip's nRST input, wired to SRST.)
	#
	# REVISIT current errata specs don't seem to cover this issue.
	# Do we have more details than this email?
	#   https://lists.berlios.de/pipermail
	#	/openocd-development/2008-August/003065.html
	#

	global _DEVICECLASS

	if {$_DEVICECLASS != 0xff} {
	   set device_class $_DEVICECLASS
	} else {
	   set device_class [expr (([mrw 0x400fe000] >> 16) & 0xff)]
	}

	if {$device_class == 0 || $device_class == 1 ||
		$device_class == 3 || $device_class == 5 || $device_class == 0xa} {
		if {![using_hla]} {
		   # Sandstorm, Fury, DustDevil, Blizzard and Snowflake are able to use NVIC SYSRESETREQ
		   cortex_m reset_config sysresetreq
		}
	} else {
		if {![using_hla]} {
		   # Tempest and Firestorm default to using NVIC VECTRESET
		   # peripherals will need resetting manually, see proc reset_peripherals
		   cortex_m reset_config vectreset
		}
		# reset peripherals, based on code in
		# http://www.ti.com/lit/er/spmz573a/spmz573a.pdf
		reset_peripherals $device_class
	}
}

# flash configuration ... autodetects sizes, autoprobed
flash bank $_CHIPNAME.flash stellaris 0 0 0 0 $_TARGETNAME
# script for stm32f0x family

#
# stm32 devices support SWD transports only.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f0x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

# Allow overriding the Flash bank size
if { [info exists FLASH_SIZE] } {
	set _FLASH_SIZE $FLASH_SIZE
} else {
	# autodetect size
	set _FLASH_SIZE 0
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
  # See STM Document RM0091
  # Section 29.5.3
   set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f1x 0x08000000 $_FLASH_SIZE 0 0 $_TARGETNAME

# adapter speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
adapter speed 1000

adapter srst delay 100

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

proc stm32f0x_default_reset_start {} {
	# Reset clock is HSI (8 MHz)
	adapter speed 1000
}

proc stm32f0x_default_examine_end {} {
	# Enable debug during low power modes (uses more power)
	mmw 0x40015804 0x00000006 0 ;# DBGMCU_CR |= DBG_STANDBY | DBG_STOP

	# Stop watchdog counters during halt
	mmw 0x40015808 0x00001800 0 ;# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
}

proc stm32f0x_default_reset_init {} {
	# Configure PLL to boost clock to HSI x 6 (48 MHz)
	mww 0x40021004 0x00100000   ;# RCC_CFGR = PLLMUL[2]
	mmw 0x40021000 0x01000000 0 ;# RCC_CR[31:16] |= PLLON
	mww 0x40022000 0x00000011   ;# FLASH_ACR = PRFTBE | LATENCY[0]
	sleep 10                    ;# Wait for PLL to lock
	mmw 0x40021004 0x00000002 0 ;# RCC_CFGR |= SW[1]

	# Boost JTAG frequency
	adapter speed 8000
}

# Default hooks
$_TARGETNAME configure -event examine-end { stm32f0x_default_examine_end }
$_TARGETNAME configure -event reset-start { stm32f0x_default_reset_start }
$_TARGETNAME configure -event reset-init { stm32f0x_default_reset_init }
# script for stm32f1x family

#
# stm32 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f1x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 4kB (as found on some STM32F100s)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

# Allow overriding the Flash bank size
if { [info exists FLASH_SIZE] } {
    set _FLASH_SIZE $FLASH_SIZE
} else {
    # autodetect size
    set _FLASH_SIZE 0
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0008 Section 26.6.3
      set _CPUTAPID 0x3ba00477
   } {
      # this is the SW-DP tap id not the jtag tap id
      set _CPUTAPID 0x1ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f1x 0x08000000 $_FLASH_SIZE 0 0 $_TARGETNAME

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
    # if srst is not fitted use SYSRESETREQ to
    # perform a soft reset
    cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_WWDG_STOP | DBG_IWDG_STOP |
	#              DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000307 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}
# script for stm32f2x family

#
# stm32 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f2x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x10000
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
#
# Since we may be running of an RC oscilator, we crank down the speed a
# bit more to be on the safe side. Perhaps superstition, but if are
# running off a crystal, we can run closer to the limit. Note
# that there can be a pretty wide band where things are more or less stable.
adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0033
      # Section 32.6.3 - corresponds to Cortex-M3 r2p0
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
	jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f2x 0 0 0 0 $_TARGETNAME
flash bank $_CHIPNAME.otp stm32f2x 0x1fff7800 0 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}
# script for stm32f3x family

#
# stm32 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f3x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 16kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
#
# Since we may be running of an RC oscilator, we crank down the speed a
# bit more to be on the safe side. Perhaps superstition, but if are
# running off a crystal, we can run closer to the limit. Note
# that there can be a pretty wide band where things are more or less stable.
adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0316
      # Section 29.6.3 - corresponds to Cortex-M4 r0p1
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f1x 0 0 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

proc stm32f3x_default_reset_start {} {
	# Reset clock is HSI (8 MHz)
	adapter speed 1000
}

proc stm32f3x_default_examine_end {} {
	# Enable debug during low power modes (uses more power)
	mmw 0xe0042004 0x00000007 0 ;# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP

	# Stop watchdog counters during halt
	mmw 0xe0042008 0x00001800 0 ;# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
}

proc stm32f3x_default_reset_init {} {
	# Configure PLL to boost clock to HSI x 8 (64 MHz)
	mww 0x40021004 0x00380400   ;# RCC_CFGR = PLLMUL[3:1] | PPRE1[2]
	mmw 0x40021000 0x01000000 0 ;# RCC_CR |= PLLON
	mww 0x40022000 0x00000012   ;# FLASH_ACR = PRFTBE | LATENCY[1]
	sleep 10                    ;# Wait for PLL to lock
	mmw 0x40021004 0x00000002 0 ;# RCC_CFGR |= SW[1]

	# Boost JTAG frequency
	adapter speed 8000
}

# Default hooks
$_TARGETNAME configure -event examine-end { stm32f3x_default_examine_end }
$_TARGETNAME configure -event reset-start { stm32f3x_default_reset_start }
$_TARGETNAME configure -event reset-init { stm32f3x_default_reset_init }

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xe0042004 0x00000020 0
}
# script for stm32f4x family

#
# stm32 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f4x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 32kB (Available RAM in smallest device STM32F410)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x8000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0090
      # Section 38.6.3 - corresponds to Cortex-M4 r0p1
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f2x 0 0 0 0 $_TARGETNAME

flash bank $_CHIPNAME.otp stm32f2x 0x1fff7800 0 0 0 $_TARGETNAME

if { [info exists QUADSPI] && $QUADSPI } {
   set a [llength [flash list]]
   set _QSPINAME $_CHIPNAME.qspi
   flash bank $_QSPINAME stmqspi 0x90000000 0 0 0 $_TARGETNAME 0xA0001000
}

# JTAG speed should be <= F_CPU/6. F_CPU after reset is 16MHz, so use F_JTAG = 2MHz
#
# Since we may be running of an RC oscilator, we crank down the speed a
# bit more to be on the safe side. Perhaps superstition, but if are
# running off a crystal, we can run closer to the limit. Note
# that there can be a pretty wide band where things are more or less stable.
adapter speed 2000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event examine-end {
	# Enable debug during low power modes (uses more power)
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}

$_TARGETNAME configure -event reset-init {
	# Configure PLL to boost clock to HSI x 4 (64 MHz)
	mww 0x40023804 0x08012008   ;# RCC_PLLCFGR 16 Mhz /8 (M) * 128 (N) /4(P)
	mww 0x40023C00 0x00000102   ;# FLASH_ACR = PRFTBE | 2(Latency)
	mmw 0x40023800 0x01000000 0 ;# RCC_CR |= PLLON
	sleep 10                    ;# Wait for PLL to lock
	mmw 0x40023808 0x00001000 0 ;# RCC_CFGR |= RCC_CFGR_PPRE1_DIV2
	mmw 0x40023808 0x00000002 0 ;# RCC_CFGR |= RCC_CFGR_SW_PLL

	# Boost JTAG frequency
	adapter speed 8000
}

$_TARGETNAME configure -event reset-start {
	# Reduce speed since CPU speed will slow down to 16MHz with the reset
	adapter speed 2000
}
# script for stm32f7x family

#
# stm32f7 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32f7x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 128kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x20000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0385
      # Section 40.6.3 - corresponds to Cortex-M7 with FPU r0p0
      set _CPUTAPID 0x5ba00477
   } {
      set _CPUTAPID 0x5ba02477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f2x 0 0 0 0 $_TARGETNAME
flash bank $_CHIPNAME.otp stm32f2x 0x1ff0f000 0 0 0 $_TARGETNAME

# On the STM32F7, the Flash is mapped at address 0x08000000 via the AXI and
# also address 0x00200000 via the ITCM. The former mapping is read-write in
# hardware, while the latter is read-only. By presenting an alias, we
# accomplish two things:
# (1) We allow writing at 0x00200000 (because the alias acts identically to the
#     original bank), which allows code intended to run from that address to
#     also be linked for loading at that address, simplifying linking.
# (2) We allow the proper memory map to be delivered to GDB, which will cause
#     it to use hardware breakpoints at the 0x00200000 mapping (correctly
#     identifying it as Flash), which it would otherwise not do. Configuring
#     the Flash via ITCM alias as virtual
flash bank $_CHIPNAME.itcm-flash.alias virtual 0x00200000 0 0 0 $_TARGETNAME $_FLASHNAME

if { [info exists QUADSPI] && $QUADSPI } {
   set a [llength [flash list]]
   set _QSPINAME $_CHIPNAME.qspi
   flash bank $_QSPINAME stmqspi 0x90000000 0 0 0 $_TARGETNAME 0xA0001000
}

# adapter speed should be <= F_CPU/6. F_CPU after reset is 16MHz, so use F_JTAG = 2MHz
adapter speed 2000

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

# Use hardware reset.
#
# This target is compatible with connect_assert_srst, which may be set in a
# board file.
reset_config srst_only srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq

   # Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
   # HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
   # makes the data access cacheable. This allows reading and writing data in the
   # CPU cache from the debugger, which is far more useful than going straight to
   # RAM when operating on typical variables, and is generally no worse when
   # operating on special memory locations.
   $_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}

$_TARGETNAME configure -event reset-init {
	# If the HSE was previously enabled and the external clock source
	# disappeared, RCC_CR.HSERDY can get stuck at 1 and the PLL cannot be
	# properly switched back to HSI. This situation persists even over a system
	# reset, including a pin reset via SRST. However, activating the clock
	# security system will detect the problem and clear HSERDY to 0, which in
	# turn allows the PLL to switch back to HSI properly. Since we just came
	# out of reset, HSEON should be 0. If HSERDY is 1, then this situation must
	# have happened; in that case, activate the clock security system to clear
	# HSERDY.
	if {[mrw 0x40023800] & 0x00020000} {
		mmw 0x40023800 0x00090000 0 ;# RCC_CR = CSSON | HSEON
		sleep 10                    ;# Wait for CSS to fire, if it wants to
		mmw 0x40023800 0 0x00090000 ;# RCC_CR &= ~CSSON & ~HSEON
		mww 0x4002380C 0x00800000   ;# RCC_CIR = CSSC
		sleep 1                     ;# Wait for CSSF to clear
	}

	# If the clock security system fired, it will pend an NMI. A pending NMI
	# will cause a bad time for any subsequent executing code, such as a
	# programming algorithm.
	if {[mrw 0xE000ED04] & 0x80000000} {
		# ICSR.NMIPENDSET reads as 1. Need to clear it. A pending NMI cant be
		# cleared by any normal means (such as ICSR or NVIC). It can only be
		# cleared by entering the NMI handler or by resetting the processor.
		echo "[target current]: Clock security system generated NMI. Clearing."

		# Keep the old DEMCR value.
		set old [mrw 0xE000EDFC]

		# Enable vector catch on reset.
		mww 0xE000EDFC 0x01000001

		# Issue local reset via AIRCR.
		mww 0xE000ED0C 0x05FA0001

		# Restore old DEMCR value.
		mww 0xE000EDFC $old
	}

	# Configure PLL to boost clock to HSI x 10 (160 MHz)
	mww 0x40023804 0x08002808   ;# RCC_PLLCFGR 16 Mhz /10 (M) * 128 (N) /2(P)
	mww 0x40023C00 0x00000107   ;# FLASH_ACR = PRFTBE | 7(Latency)
	mmw 0x40023800 0x01000000 0 ;# RCC_CR |= PLLON
	sleep 10                    ;# Wait for PLL to lock
	mww 0x40023808 0x00009400   ;# RCC_CFGR_PPRE1 = 5(div 4), PPRE2 = 4(div 2)
	mmw 0x40023808 0x00000002 0 ;# RCC_CFGR |= RCC_CFGR_SW_PLL

	# Boost SWD frequency
	# Do not boost JTAG frequency and slow down JTAG memory access or flash write algo
	# suffers from DAP WAITs
	if {[using_jtag]} {
		[[target current] cget -dap] memaccess 16
	} {
		adapter speed 8000
	}
}

$_TARGETNAME configure -event reset-start {
	# Reduce speed since CPU speed will slow down to 16MHz with the reset
	adapter speed 2000
}
# script for stm32g0x family

#
# stm32g0 devices support SWD transports only.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32g0x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# Smallest proposed target has 8kB ram, use 4kB by default to avoid surprises
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x1000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	# Section 37.5.5 - corresponds to Cortex-M0+
	set _CPUTAPID 0x0bc11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME

# reasonable default
adapter speed 2000

adapter srst delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	cortex_m reset_config sysresetreq
}

proc stm32g0x_default_reset_start {} {
	# Reset clock is HSI16 (16 MHz)
	adapter speed 2000
}

proc stm32g0x_default_examine_end {} {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP
	mmw 0x40015804 0x00000006 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0x40015808 0x00001800 0
}

proc stm32g0x_default_reset_init {} {
	# Increase clock to 64 Mhz
	mmw 0x40022000 0x00000002 0x00000005	;# FLASH_ACR: Latency = 2
	mww 0x4002100C 0x30000802				;# RCC_PLLCFGR = PLLR=/2, PLLN=8, PLLM=/1, PLLSRC=0x2
	mmw 0x40021000 0x01000000 0x00000000	;# RCC_CR |= PLLON
	mmw 0x40021008 0x00000002 0x00000005	;# RCC_CFGR: SW=PLLRCLK

	# Boost JTAG frequency
	adapter speed 4000
}

# Default hooks
$_TARGETNAME configure -event examine-end { stm32g0x_default_examine_end }
$_TARGETNAME configure -event reset-start { stm32g0x_default_reset_start }
$_TARGETNAME configure -event reset-init { stm32g0x_default_reset_init }
# script for stm32g4x family

#
# stm32g4 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32g4x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# Smallest current target has 32kB ram, use 16kB by default to avoid surprises
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x4000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		# See STM Document RM0440
		# Section 46.6.3 - corresponds to Cortex-M4 r0p1
		set _CPUTAPID 0x4ba00477
	} {
		set _CPUTAPID 0x2ba01477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
	jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME

if { [info exists QUADSPI] && $QUADSPI } {
	set a [llength [flash list]]
	set _QSPINAME $_CHIPNAME.qspi
	flash bank $_QSPINAME stmqspi 0x90000000 0 0 0 $_TARGETNAME 0xA0001000
}

# reasonable default
adapter speed 2000

adapter srst delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event reset-init {
	# CPU comes out of reset with HSION | HSIRDY.
	# Use HSI 16 MHz clock, compliant even with VOS == 2.
	# 1 WS compliant with VOS == 2 and 16 MHz.
	mmw 0x40022000 0x00000001 0x0000000E	;# FLASH_ACR: Latency = 1
	mmw 0x40021000 0x00000100 0x00000000	;# RCC_CR |= HSION
	mmw 0x40021008 0x00000001 0x00000002	;# RCC_CFGR: SW=HSI16
}

$_TARGETNAME configure -event reset-start {
	# Reset clock is HSI (16 MHz)
	adapter speed 2000
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZR1 |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}
# script for stm32h7x family

#
# stm32h7 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32h7x
}

if { [info exists DUAL_BANK] } {
	set $_CHIPNAME.DUAL_BANK $DUAL_BANK
	unset DUAL_BANK
} else {
	set $_CHIPNAME.DUAL_BANK 0
}

if { [info exists DUAL_CORE] } {
	set $_CHIPNAME.DUAL_CORE $DUAL_CORE
	unset DUAL_CORE
} else {
	set $_CHIPNAME.DUAL_CORE 0
}

# Issue a warning when hla is used, and fallback to single core configuration
if { [set $_CHIPNAME.DUAL_CORE] && [using_hla] } {
	echo "Warning : hla does not support multicore debugging"
	set $_CHIPNAME.DUAL_CORE 0
}

if { [info exists USE_CTI] } {
	set $_CHIPNAME.USE_CTI $USE_CTI
	unset USE_CTI
} else {
	set $_CHIPNAME.USE_CTI 0
}

# Issue a warning when DUAL_CORE=0 and USE_CTI=1, and fallback to USE_CTI=0
if { ![set $_CHIPNAME.DUAL_CORE] && [set $_CHIPNAME.USE_CTI] } {
	echo "Warning : could not use CTI with a single core device, CTI is disabled"
	set $_CHIPNAME.USE_CTI 0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
	  set _CPUTAPID 0x6ba00477
   } {
      set _CPUTAPID 0x6ba02477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

if {![using_hla]} {
	# STM32H7 provides an APB-AP at access port 2, which allows the access to
	# the debug and trace features on the system APB System Debug Bus (APB-D).
	target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2
}

target create $_CHIPNAME.cpu0 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 0

$_CHIPNAME.cpu0 configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

flash bank $_CHIPNAME.bank1.cpu0 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cpu0

if {[set $_CHIPNAME.DUAL_BANK]} {
	flash bank $_CHIPNAME.bank2.cpu0 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cpu0
}

if {[set $_CHIPNAME.DUAL_CORE]} {
	target create $_CHIPNAME.cpu1 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 3

	$_CHIPNAME.cpu1 configure -work-area-phys 0x38000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

	flash bank $_CHIPNAME.bank1.cpu1 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cpu1

	if {[set $_CHIPNAME.DUAL_BANK]} {
		flash bank $_CHIPNAME.bank2.cpu1 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cpu1
	}
}

# Make sure that cpu0 is selected
targets $_CHIPNAME.cpu0

if { [info exists QUADSPI] && $QUADSPI } {
   set a [llength [flash list]]
   set _QSPINAME $_CHIPNAME.qspi
   flash bank $_QSPINAME stmqspi 0x90000000 0 0 0 $_CHIPNAME.cpu0 0x52005000
} else {
   if { [info exists OCTOSPI1] && $OCTOSPI1 } {
      set a [llength [flash list]]
      set _OCTOSPINAME1 $_CHIPNAME.octospi1
      flash bank $_OCTOSPINAME1 stmqspi 0x90000000 0 0 0 $_CHIPNAME.cpu0 0x52005000
   }
   if { [info exists OCTOSPI2] && $OCTOSPI2 } {
      set b [llength [flash list]]
      set _OCTOSPINAME2 $_CHIPNAME.octospi2
      flash bank $_OCTOSPINAME2 stmqspi 0x70000000 0 0 0 $_CHIPNAME.cpu0 0x5200A000
   }
}

# Clock after reset is HSI at 64 MHz, no need of PLL
adapter speed 1800

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

# use hardware reset
#
# The STM32H7 does not support connect_assert_srst mode because the AXI is
# unavailable while SRST is asserted, and that is used to access the DBGMCU
# component at 0x5C001000 in the examine-end event handler.
#
# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead
# of the default AP0, and that works with SRST asserted; however, nonzero AP
# usage does not work with HLA, so is not done by default. That change could be
# made in a local configuration file if connect_assert_srst mode is needed for
# a specific application and a non-HLA adapter is in use.
reset_config srst_only srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
	$_CHIPNAME.cpu0 cortex_m reset_config sysresetreq

	if {[set $_CHIPNAME.DUAL_CORE]} {
		$_CHIPNAME.cpu1 cortex_m reset_config sysresetreq
	}

   # Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
   # HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
   # makes the data access cacheable. This allows reading and writing data in the
   # CPU cache from the debugger, which is far more useful than going straight to
   # RAM when operating on typical variables, and is generally no worse when
   # operating on special memory locations.
   $_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

$_CHIPNAME.cpu0 configure -event examine-end {
	# Enable D3 and D1 DBG clocks
	# DBGMCU_CR |= D3DBGCKEN | D1DBGCKEN
	stm32h7x_dbgmcu_mmw 0x004 0x00600000 0

	# Enable debug during low power modes (uses more power)
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP D1 Domain
	stm32h7x_dbgmcu_mmw 0x004 0x00000007 0
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP D2 Domain
	stm32h7x_dbgmcu_mmw 0x004 0x00000038 0

	# Stop watchdog counters during halt
	# DBGMCU_APB3FZ1 |= WWDG1
	stm32h7x_dbgmcu_mmw 0x034 0x00000040 0
	# DBGMCU_APB1LFZ1 |= WWDG2
	stm32h7x_dbgmcu_mmw 0x03C 0x00000800 0
	# DBGMCU_APB4FZ1 |= WDGLSD1 | WDGLSD2
	stm32h7x_dbgmcu_mmw 0x054 0x000C0000 0
}

$_CHIPNAME.cpu0 configure -event trace-config {
	# Set TRACECLKEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	stm32h7x_dbgmcu_mmw 0x004 0x00100000 0
}

$_CHIPNAME.cpu0 configure -event reset-init {
	# Clock after reset is HSI at 64 MHz, no need of PLL
	adapter speed 4000
}

# get _CHIPNAME from current target
proc stm32h7x_get_chipname {} {
	set t [target current]
	set sep [string last "." $t]
	if {$sep == -1} {
		return $t
	}
	return [string range $t 0 [expr $sep - 1]]
}

if {[set $_CHIPNAME.DUAL_CORE]} {
	$_CHIPNAME.cpu1 configure -event examine-end {
		set _CHIPNAME [stm32h7x_get_chipname]
		global $_CHIPNAME.USE_CTI

		# Stop watchdog counters during halt
		# DBGMCU_APB3FZ2 |= WWDG1
		stm32h7x_dbgmcu_mmw 0x038 0x00000040 0
		# DBGMCU_APB1LFZ2 |= WWDG2
		stm32h7x_dbgmcu_mmw 0x040 0x00000800 0
		# DBGMCU_APB4FZ2 |= WDGLSD1 | WDGLSD2
		stm32h7x_dbgmcu_mmw 0x058 0x000C0000 0

		if {[set $_CHIPNAME.USE_CTI]} {
			stm32h7x_cti_start
		}
	}
}

# like mrw, but with target selection
proc stm32h7x_mrw {used_target reg} {
	set value ""
	$used_target mem2array value 32 $reg 1
	return $value(0)
}

# like mmw, but with target selection
proc stm32h7x_mmw {used_target reg setbits clearbits} {
	set old [stm32h7x_mrw $used_target $reg]
	set new [expr ($old & ~$clearbits) | $setbits]
	$used_target mww $reg $new
}

# mmw for dbgmcu component registers, it accepts the register offset from dbgmcu base
# this procedure will use the mem_ap on AP2 whenever possible
proc stm32h7x_dbgmcu_mmw {reg_offset setbits clearbits} {
	# use $_CHIPNAME.ap2 if possible, and use the proper dbgmcu base address
	if {![using_hla]} {
		set _CHIPNAME [stm32h7x_get_chipname]
		set used_target $_CHIPNAME.ap2
		set reg_addr [expr 0xE00E1000 + $reg_offset]
	} {
		set used_target [target current]
		set reg_addr [expr 0x5C001000 + $reg_offset]
	}

	stm32h7x_mmw $used_target $reg_addr $setbits $clearbits
}

if {[set $_CHIPNAME.USE_CTI]} {
	# create CTI instances for both cores
	cti create $_CHIPNAME.cti0 -dap $_CHIPNAME.dap -ap-num 0 -baseaddr 0xE0043000
	cti create $_CHIPNAME.cti1 -dap $_CHIPNAME.dap -ap-num 3 -baseaddr 0xE0043000

	$_CHIPNAME.cpu0 configure -event halted { stm32h7x_cti_prepare_restart_all }
	$_CHIPNAME.cpu1 configure -event halted { stm32h7x_cti_prepare_restart_all }

	$_CHIPNAME.cpu0 configure -event debug-halted { stm32h7x_cti_prepare_restart_all }
	$_CHIPNAME.cpu1 configure -event debug-halted { stm32h7x_cti_prepare_restart_all }

	proc stm32h7x_cti_start {} {
		set _CHIPNAME [stm32h7x_get_chipname]

		# Configure Cores' CTIs to halt each other
		# TRIGIN0 (DBGTRIGGER) and TRIGOUT0 (EDBGRQ) at CTM_CHANNEL_0
		$_CHIPNAME.cti0 write INEN0 0x1
		$_CHIPNAME.cti0 write OUTEN0 0x1
		$_CHIPNAME.cti1 write INEN0 0x1
		$_CHIPNAME.cti1 write OUTEN0 0x1

		# enable CTIs
		$_CHIPNAME.cti0 enable on
		$_CHIPNAME.cti1 enable on
	}

	proc stm32h7x_cti_stop {} {
		set _CHIPNAME [stm32h7x_get_chipname]

		$_CHIPNAME.cti0 enable off
		$_CHIPNAME.cti1 enable off
	}

	proc stm32h7x_cti_prepare_restart_all {} {
		stm32h7x_cti_prepare_restart cti0
		stm32h7x_cti_prepare_restart cti1
	}

	proc stm32h7x_cti_prepare_restart {cti} {
		set _CHIPNAME [stm32h7x_get_chipname]

		# Acknowlodge EDBGRQ at TRIGOUT0
		$_CHIPNAME.$cti write INACK 0x01
		$_CHIPNAME.$cti write INACK 0x00
	}
}
# script for stm32h7x family (dual flash bank)

# STM32H7xxxI 2Mo have a dual bank flash.
set DUAL_BANK 1

source [find target/stm32h7x.cfg]
#
# M0+ devices only have SW-DP, but swj-dp code works, just don't
# set any jtag related features
#

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32l0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 2kB (max ram on smallest part)
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x800
}

# JTAG speed should be <= F_CPU/6.
# F_CPU after reset is ~2MHz, so use F_JTAG max = 333kHz
adapter speed 300

adapter srst delay 100

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    # Arm, m0+, non-multidrop.
    # http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka16088.html
    set _CPUTAPID 0x0bc11477
}

swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32lx 0x08000000 0 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

proc stm32l0_enable_HSI16 {} {
	# Enable HSI16 as clock source
	echo "STM32L0: Enabling HSI16"

	# Set HSI16ON in RCC_CR (leave MSI enabled)
    mmw 0x40021000 0x00000101 0

	# Set HSI16 as SYSCLK (RCC_CFGR)
	mmw 0x4002100c 0x00000001 0

	# Wait until System clock switches to HSI16
	while { ([ mrw 0x4002100c ] & 0x0c) != 0x04 } { }

	# Increase speed
	adapter speed 2500
}

$_TARGETNAME configure -event reset-init {
	stm32l0_enable_HSI16
}

$_TARGETNAME configure -event reset-start {
	adapter speed 300
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0x40015804 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0x40015808 0x00001800 0
}
source [find target/stm32l0.cfg]

# Add the second flash bank.
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME stm32lx 0 0 0 0 $_TARGETNAME
#
# stm32l1 devices support both JTAG and SWD transports.
#

source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32l1
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 10kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x2800
}

# JTAG speed should be <= F_CPU/6.
# F_CPU after reset is 2MHz, so use F_JTAG max = 333kHz
adapter speed 300

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0038
      # Section 30.6.3 - corresponds to Cortex-M3 r2p0
      set _CPUTAPID 0x4ba00477
   } else {
      # SWD IDCODE (single drop, arm)
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32lx 0x08000000 0 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

proc stm32l_enable_HSI {} {
	# Enable HSI as clock source
	echo "STM32L: Enabling HSI"

	# Set HSION in RCC_CR
	mmw 0x40023800 0x00000101 0

	# Set HSI as SYSCLK
	mmw 0x40023808 0x00000001 0

	# Increase JTAG speed
	adapter speed 2000
}

$_TARGETNAME configure -event reset-init {
	stm32l_enable_HSI
}

$_TARGETNAME configure -event reset-start {
	adapter speed 300
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}
source [find target/stm32l1.cfg]

# The stm32l1x 384kb have a dual bank flash.
# Let's add a definition for the second bank here.

# Add the second flash bank.
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME stm32lx 0 0 0 0 $_TARGETNAME
# script for stm32l4x family

#
# stm32l4 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32l4x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# Smallest current target has 64kB ram, use 32kB by default to avoid surprises
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x8000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      # See STM Document RM0351
      # Section 44.6.3 - corresponds to Cortex-M4 r0p1
      set _CPUTAPID 0x4ba00477
   } {
      set _CPUTAPID 0x2ba01477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME

if { [info exists QUADSPI] && $QUADSPI } {
   set a [llength [flash list]]
   set _QSPINAME $_CHIPNAME.qspi
   flash bank $_QSPINAME stmqspi 0x90000000 0 0 0 $_TARGETNAME 0xA0001000
} else {
   if { [info exists OCTOSPI1] && $OCTOSPI1 } {
      set a [llength [flash list]]
      set _OCTOSPINAME1 $_CHIPNAME.octospi1
      flash bank $_OCTOSPINAME1 stmqspi 0x90000000 0 0 0 $_TARGETNAME 0xA0001000
   }
   if { [info exists OCTOSPI2] && $OCTOSPI2 } {
      set b [llength [flash list]]
      set _OCTOSPINAME2 $_CHIPNAME.octospi2
      flash bank $_OCTOSPINAME2 stmqspi 0x70000000 0 0 0 $_TARGETNAME 0xA0001400
   }
}

# Common knowledges tells JTAG speed should be <= F_CPU/6.
# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
# the safe side.
#
# Note that there is a pretty wide band where things are
# more or less stable, see http://openocd.zylin.com/#/c/3366/
adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event reset-init {
	# CPU comes out of reset with MSI_ON | MSI_RDY | MSI Range 6 (4 MHz).
	# Use MSI 24 MHz clock, compliant even with VOS == 2.
	# 3 WS compliant with VOS == 2 and 24 MHz.
	mww 0x40022000 0x00000103   ;# FLASH_ACR = PRFTBE | 3(Latency)
	mww 0x40021000 0x00000099   ;# RCC_CR = MSI_ON | MSIRGSEL | MSI Range 9
	# Boost JTAG frequency
	adapter speed 4000
}

$_TARGETNAME configure -event reset-start {
	# Reset clock is MSI (4 MHz)
	adapter speed 500
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0042008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0042004 0x00000020 0
}
# SPDX-License-Identifier: GPL-2.0-or-later

# script for stm32l5x family

#
# stm32l5 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32l5x
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		# See STM Document RM0438
		# RM0438 Rev5, Section 52.2.8 JTAG debug port - Table 425. JTAG-DP data registers
		# Corresponds to Cortex-M33 JTAG debug port ID code
		set _CPUTAPID 0x0ba04477
	} {
		# SWD IDCODE (single drop, arm)
		set _CPUTAPID 0x0be12477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
	jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

# use non-secure RAM by default
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

# declare non-secure flash
flash bank $_CHIPNAME.flash_ns stm32l4x 0 0 0 0 $_TARGETNAME

# Common knowledges tells JTAG speed should be <= F_CPU/6.
# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
# the safe side.
#
# Note that there is a pretty wide band where things are
# more or less stable, see http://openocd.zylin.com/#/c/3366/
adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	cortex_m reset_config sysresetreq
}

proc clock_config_110_mhz {} {
	# MCU clock is MSI (4MHz) after reset, set MCU freq at 110 MHz with PLL
	# RCC_APB1ENR1 = PWREN
	mww 0x40021058 0x10000000
	# delay for register clock enable (read back reg)
	mrw 0x40021058
	# PWR_CR1 : VOS Range 0
	mww 0x40007000 0
	# while (PWR_SR2 & VOSF)
	while {([mrw 0x40007014] & 0x0400)} {}
	# FLASH_ACR : 5 WS for 110 MHz HCLK
	mww 0x40022000 0x00000005
	# RCC_PLLCFGR = PLLP=PLLQ=0, PLLR=00=2, PLLREN=1, PLLN=55, PLLM=0000=1, PLLSRC=MSI 4MHz
	# fVCO = 4 x 55 /1 = 220
	# SYSCLOCK = fVCO/PLLR = 220/2 = 110 MHz
	mww 0x4002100C 0x01003711
	# RCC_CR |= PLLON
	mmw 0x40021000 0x01000000 0
	# while !(RCC_CR & PLLRDY)
	while {!([mrw 0x40021000] & 0x02000000)} {}
	# RCC_CFGR |= SW_PLL
	mmw 0x40021008 0x00000003 0
	# while ((RCC_CFGR & SWS) != PLL)
	while {([mrw 0x40021008] & 0x0C) != 0x0C} {}
}

$_TARGETNAME configure -event reset-init {
	clock_config_110_mhz
	# Boost JTAG frequency
	adapter speed 4000
}

$_TARGETNAME configure -event reset-start {
	# Reset clock is MSI (4 MHz)
	adapter speed 480
}

$_TARGETNAME configure -event examine-end {
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP
	mmw 0xE0044004 0x00000006 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE0044008 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0xE0044004 0x00000020 0
}
# STMicroelectronics STM32MP15x (Single/Dual Cortex-A7 plus Cortex-M4)
# http://www.st.com/stm32mp1

# HLA does not support multi-cores nor custom CSW nor AP other than 0
if { [using_hla] } {
	echo "ERROR: HLA transport cannot work with this target."
	echo "ERROR: To use STLink switch to DAP mode, as in \"board/stm32mp15x_dk2.cfg\"."
	shutdown
}

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32mp15x
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		set _CPUTAPID 0x6ba00477
	} else {
		set _CPUTAPID 0x6ba02477
	}
}

# Chip Level TAP Controller, only in jtag mode
if { [info exists CLCTAPID] } {
	set _CLCTAPID $CLCTAPID
} else {
	set _CLCTAPID 0x06500041
}

swj_newdap $_CHIPNAME tap -expected-id $_CPUTAPID -irlen 4
if { [using_jtag] } {
	jtag newtap $_CHIPNAME.clc tap -expected-id $_CLCTAPID -irlen 5
}

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap -ignore-syspwrupack

# FIXME: Cortex-M code requires target accessible during reset, but this is not possible in STM32MP1
# so defer-examine it until the reset framework get merged
# NOTE: keep ap-num and dbgbase to speed-up examine after reset
# NOTE: do not change the order of target create
target create $_CHIPNAME.ap1 mem_ap -dap $_CHIPNAME.dap -ap-num 1
target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2
target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 0
target create $_CHIPNAME.cpu0 cortex_a -dap $_CHIPNAME.dap -ap-num 1 -coreid 0 -dbgbase 0xE00D0000
target create $_CHIPNAME.cpu1 cortex_a -dap $_CHIPNAME.dap -ap-num 1 -coreid 1 -dbgbase 0xE00D2000
target create $_CHIPNAME.cm4 cortex_m -dap $_CHIPNAME.dap -ap-num 2 -defer-examine

targets $_CHIPNAME.cpu0

target smp $_CHIPNAME.cpu0 $_CHIPNAME.cpu1
$_CHIPNAME.cpu0 cortex_a maskisr on
$_CHIPNAME.cpu1 cortex_a maskisr on
$_CHIPNAME.cpu0 cortex_a dacrfixup on
$_CHIPNAME.cpu1 cortex_a dacrfixup on

cti create $_CHIPNAME.cti.sys  -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0xE0094000
cti create $_CHIPNAME.cti.cpu0 -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0xE00D8000
cti create $_CHIPNAME.cti.cpu1 -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0xE00D9000
cti create $_CHIPNAME.cti.cm4  -dap $_CHIPNAME.dap -ap-num 2 -baseaddr 0xE0043000

# interface does not work while srst is asserted
# this is target specific, valid for every board
# Errata "2.3.5 Incorrect reset of glitch-free kernel clock switch" requires
# srst to force VDDCORE power cycle or pull srst_core. Both cases reset the
# debug unit, behavior equivalent to "srst_pulls_trst"
reset_config srst_gates_jtag srst_pulls_trst

adapter speed 5000
adapter srst pulse_width 200
# bootrom has an internal timeout of 1 second for detecting the boot flash.
# wait at least 1 second to guarantee we are out of bootrom
adapter srst delay 1100

add_help_text axi_secure "Set secure mode for following AXI accesses"
proc axi_secure {} {
	$::_CHIPNAME.dap apsel 0
	$::_CHIPNAME.dap apcsw 0x10006000
}

add_help_text axi_nsecure "Set non-secure mode for following AXI accesses"
proc axi_nsecure {} {
	$::_CHIPNAME.dap apsel 0
	$::_CHIPNAME.dap apcsw 0x30006000
}

axi_secure

proc dbgmcu_enable_debug {} {
	# set debug enable bits in DBGMCU_CR to get ap2 and cm4 visible
	catch {$::_CHIPNAME.ap1 mww 0xe0081004 0x00000007}
}

proc toggle_cpu0_dbg_claim0 {} {
	# toggle CPU0 DBG_CLAIM[0]
	$::_CHIPNAME.ap1 mww 0xe00d0fa0 1
	$::_CHIPNAME.ap1 mww 0xe00d0fa4 1
}

proc detect_cpu1 {} {
	$::_CHIPNAME.ap1 mem2array cpu1_prsr 32 0xE00D2314 1
	set dual_core [expr $cpu1_prsr(0) & 1]
	if {! $dual_core} {$::_CHIPNAME.cpu1 configure -defer-examine}
}

# FIXME: most of handler below will be removed once reset framework get merged
$_CHIPNAME.ap1  configure -event reset-deassert-pre  {adapter deassert srst deassert trst;dap init;catch {$::_CHIPNAME.dap apid 1}}
$_CHIPNAME.ap2  configure -event reset-deassert-pre  {dbgmcu_enable_debug}
$_CHIPNAME.cpu0 configure -event reset-deassert-pre  {$::_CHIPNAME.cpu0 arp_examine}
$_CHIPNAME.cpu1 configure -event reset-deassert-pre  {$::_CHIPNAME.cpu1 arp_examine allow-defer}
$_CHIPNAME.cpu0 configure -event reset-deassert-post {toggle_cpu0_dbg_claim0}
$_CHIPNAME.cm4  configure -event reset-deassert-post {$::_CHIPNAME.cm4 arp_examine;if {[$::_CHIPNAME.ap2 curstate] == "halted"} {$::_CHIPNAME.cm4 arp_poll;$::_CHIPNAME.cm4 arp_poll;$::_CHIPNAME.cm4 arp_halt}}
$_CHIPNAME.ap1  configure -event examine-start       {dap init}
$_CHIPNAME.ap2  configure -event examine-start       {dbgmcu_enable_debug}
$_CHIPNAME.cpu0 configure -event examine-end         {detect_cpu1}
$_CHIPNAME.ap2  configure -event examine-end         {$::_CHIPNAME.cm4 arp_examine}
#
# Target configuration for the ST STM32W108xx chips
#
# Processor: ARM Cortex-M3
# Date:      2013-06-09
# Author:    Giuseppe Barba <giuseppe.barba@gmail.com>

#
# stm32 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] == 0 } {
   set _CHIPNAME stm32w108
} else {
   set _CHIPNAME $CHIPNAME
}

# Work-area is a space in RAM used for flash programming
# By default use 8kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x2000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x3ba00477
   } {
      set _CPUTAPID 0x1ba01477
   }
}

set _ENDIAN little

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
 if { [info exists BSTAPID] } {
   set _BSTAPID $BSTAPID
   jtag newtap $_CHIPNAME bs -irlen 4 -ircapture 0xe -irmask 0xf -expected-id _BSTAPID
 } else {
   set _BSTAPID_1 0x169a862b
   set _BSTAPID_2 0x269a862b
   jtag newtap $_CHIPNAME bs -irlen 4 -ircapture 0xe -irmask 0xf \
		-expected-id $_BSTAPID_1 -expected-id $_BSTAPID_2
 }
}
#
# Set Target
#
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0


# Use the flash driver from the EM357
set _FLASHNAME $_CHIPNAME.flash

# 64k (0x10000) of flash
flash bank $_FLASHNAME em357 0x08000000 0x10000 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
   cortex_m reset_config sysresetreq
}
# script for stm32wbx family

#
# stm32wb devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32wbx
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
      set _CPUTAPID 0x6ba00477
   } else {
      # SWD IDCODE (single drop, arm)
      set _CPUTAPID 0x6ba02477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
   jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME

# Common knowledges tells JTAG speed should be <= F_CPU/6.
# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
# the safe side.
#
# Note that there is a pretty wide band where things are
# more or less stable, see http://openocd.zylin.com/#/c/3366/
adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event reset-init {
    # CPU comes out of reset with MSI_ON | MSI_RDY | MSI Range 4 MHz.
    # Configure system to use MSI 24 MHz clock, compliant with VOS default Range1.
    # 2 WS compliant with VOS=Range1 and 24 MHz.
    mmw 0x58004000 0x00000102 0  ;# FLASH_ACR |= PRFTBE | 2(Latency)
    mmw 0x58000000 0x00000091 0  ;# RCC_CR = MSI_ON | MSI Range 24 MHz
    # Boost JTAG frequency
    adapter speed 4000
}

$_TARGETNAME configure -event reset-start {
    # Reset clock is MSI (4 MHz)
    adapter speed 500
}

$_TARGETNAME configure -event examine-end {
    # Enable debug during low power modes (uses more power)
    # DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
    mmw 0xE0042004 0x00000007 0

    # Stop watchdog counters during halt
    # DBGMCU_APB1_FZR1 |= DBG_IWDG_STOP | DBG_WWDG_STOP
    mmw 0xE004203C 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
    # Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
    # change this value accordingly to configure trace pins
    # assignment
    mmw 0xE0042004 0x00000020 0
}
# script for stm32wlx family

#
# stm32wl devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32wlx
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 20kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x5000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		set _CPUTAPID 0x6ba00477
	} else {
		# SWD IDCODE (single drop, arm)
		set _CPUTAPID 0x6ba02477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
	jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME

# Common knowledges tells JTAG speed should be <= F_CPU/6.
# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
# the safe side.
#
# Note that there is a pretty wide band where things are
# more or less stable, see http://openocd.zylin.com/#/c/3366/
adapter speed 500

adapter srst delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

reset_config srst_nogate

if {![using_hla]} {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	cortex_m reset_config sysresetreq
}

$_TARGETNAME configure -event reset-init {
	# CPU comes out of reset with MSI_ON | MSI_RDY | MSI Range 4 MHz.
	# Configure system to use MSI 24 MHz clock, compliant with VOS default Range1.
	# 2 WS compliant with VOS=Range1 and 24 MHz.
	mmw 0x58004000 0x00000102 0  ;# FLASH_ACR |= PRFTEN | 2(Latency)
	mmw 0x58000000 0x00000091 0  ;# RCC_CR = MSI_ON | MSI Range 24 MHz
	# Boost JTAG frequency
	adapter speed 4000
}

$_TARGETNAME configure -event reset-start {
	# Reset clock is MSI (4 MHz)
	adapter speed 500
}

$_TARGETNAME configure -event examine-end {
	# Enable debug during low power modes (uses more power)
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
	mmw 0xE0042004 0x00000007 0

	# Stop watchdog counters during halt
	# DBGMCU_APB1_FZR1 |= DBG_IWDG_STOP | DBG_WWDG_STOP
	mmw 0xE004203C 0x00001800 0
}

$_TARGETNAME configure -event trace-config {
	# nothing to do
}
# script for stm32xl family (dual flash bank)
source [find target/stm32f1x.cfg]

# flash size will be probed
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME stm32f1x 0x08080000 0 0 0 $_TARGETNAME
# script for stm8l family

#
# stm8 devices support SWIM transports only.
#

transport select swim

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm8l
}

# Work-area is a space in RAM used for flash programming
# By default use 1kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x400
}

if { [info exists FLASHSTART] } {
   set _FLASHSTART $FLASHSTART
} else {
   set _FLASHSTART 0x8000
}

if { [info exists FLASHEND] } {
   set _FLASHEND $FLASHEND
} else {
   set _FLASHEND 0xffff
}

if { [info exists EEPROMSTART] } {
   set _EEPROMSTART $EEPROMSTART
} else {
   set _EEPROMSTART 0x4000
}

if { [info exists EEPROMEND] } {
   set _EEPROMEND $EEPROMEND
} else {
   set _EEPROMEND 0x43ff
}

if { [info exists OPTIONSTART] } {
   set _OPTIONSTART $OPTIONSTART
} else {
   set _OPTIONSTART 0x4800
}

if { [info exists OPTIONEND] } {
   set _OPTIONEND $OPTIONEND
} else {
   set _OPTIONEND 0x487f
}

if { [info exists BLOCKSIZE] } {
   set _BLOCKSIZE $BLOCKSIZE
} else {
   set _BLOCKSIZE 0x80
}

swim newtap $_CHIPNAME cpu

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME stm8 -chain-position $_CHIPNAME.cpu

$_TARGETNAME configure -work-area-phys 0x0 -work-area-size $_WORKAREASIZE -work-area-backup 1
$_TARGETNAME configure -flashstart $_FLASHSTART -flashend $_FLASHEND -eepromstart $_EEPROMSTART -eepromend $_EEPROMEND
$_TARGETNAME configure -optionstart $_OPTIONSTART -optionend $_OPTIONEND -blocksize $_BLOCKSIZE

# Uncomment this line to enable interrupts while instruction step
#$_TARGETNAME configure -enable_step_irq

# Set stm8l type
$_TARGETNAME configure -enable_stm8l

# Set high speed
adapter speed 800
# Set low speed
#adapter speed 363

reset_config srst_only

#uncomment this line to connect under reset
#reset_config srst_nogate connect_assert_srst
#config script for STM8L152

set EEPROMSTART 0x1000
set EEPROMEND 0x13ff

proc stm8_reset_rop {} {
   mwb 0x4800 0xaa
   mwb 0x4800 0xaa
   reset halt
}

source [find target/stm8l.cfg]
# script for stm8s family

#
# stm8 devices support SWIM transports only.
#

transport select swim

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm8s
}

# Work-area is a space in RAM used for flash programming
# By default use 1kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x400
}

if { [info exists FLASHSTART] } {
   set _FLASHSTART $FLASHSTART
} else {
   set _FLASHSTART 0x8000
}

if { [info exists FLASHEND] } {
   set _FLASHEND $FLASHEND
} else {
   set _FLASHEND 0xffff
}

if { [info exists EEPROMSTART] } {
   set _EEPROMSTART $EEPROMSTART
} else {
   set _EEPROMSTART 0x4000
}

if { [info exists EEPROMEND] } {
   set _EEPROMEND $EEPROMEND
} else {
   set _EEPROMEND 0x43ff
}

if { [info exists OPTIONSTART] } {
   set _OPTIONSTART $OPTIONSTART
} else {
   set _OPTIONSTART 0x4800
}

if { [info exists OPTIONEND] } {
   set _OPTIONEND $OPTIONEND
} else {
   set _OPTIONEND 0x487f
}

if { [info exists BLOCKSIZE] } {
   set _BLOCKSIZE $BLOCKSIZE
} else {
   set _BLOCKSIZE 0x80
}

swim newtap $_CHIPNAME cpu

set _TARGETNAME $_CHIPNAME.cpu

target create $_TARGETNAME stm8 -chain-position $_CHIPNAME.cpu

$_TARGETNAME configure -work-area-phys 0x0 -work-area-size $_WORKAREASIZE -work-area-backup 1
$_TARGETNAME configure -flashstart $_FLASHSTART -flashend $_FLASHEND -eepromstart $_EEPROMSTART -eepromend $_EEPROMEND
$_TARGETNAME configure -optionstart $_OPTIONSTART -optionend $_OPTIONEND -blocksize $_BLOCKSIZE

# Uncomment this line to enable interrupts while instruction step
#$_TARGETNAME configure -enable_step_irq

# Set high speed
adapter speed 800
# Set low speed
#adapter speed 363

reset_config srst_only

# uncomment this line to connect under reset
#reset_config srst_nogate connect_assert_srst
#config script for STM8S003

set FLASHEND 0x9FFF
set BLOCKSIZE 0x40

proc stm8_reset_rop {} {
   mwb 0x4800 0x00
   reset halt
}

source [find target/stm8s.cfg]
#config script for STM8S103

set FLASHEND 0x9FFF
set EEPROMEND 0x427F
set OPTIONEND 0x480A
set BLOCKSIZE 0x40

proc stm8_reset_rop {} {
   mwb 0x4800 0x00
   reset halt
}

source [find target/stm8s.cfg]
#config script for STM8S105

proc stm8_reset_rop {} {
   mwb 0x4800 0x00
   reset halt
}

source [find target/stm8s.cfg]
#start slow, speed up after reset
adapter speed 10

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME str710
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst srst_pulls_trst

#jtag scan chain

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-start { adapter speed 10 }
$_TARGETNAME configure -event reset-init {
	adapter speed 6000

# Because the hardware cannot be interrogated for the protection state
# of sectors, initialize all the sectors to be unprotected. The initial
# state is reflected by the driver, too.
	flash protect 0 0 last off
	flash protect 1 0 last off
}
$_TARGETNAME configure -event gdb-flash-erase-start {
	flash protect 0 0 7 off
	flash protect 1 0 1 off
}

$_TARGETNAME configure -work-area-phys 0x2000C000 -work-area-size 0x4000 -work-area-backup 0

#flash bank str7x <base> <size> 0 0 <target#> <variant>
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME str7x 0x400C0000 0x00004000 0 0 $_TARGETNAME STR71x
#STR730 CPU

adapter speed 3000

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME str730
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x3f0f0f0f
}

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst srst_pulls_trst

#jtag scan chain
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID

#jtag nTRST and nSRST delay
adapter srst delay 500
jtag_ntrst_delay 500

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian little -chain-position 0

$_TARGETNAME configure -event reset-start { adapter speed 10 }
$_TARGETNAME configure -event reset-init {
	adapter speed 3000

# Because the hardware cannot be interrogated for the protection state
# of sectors, initialize all the sectors to be unprotected. The initial
# state is reflected by the driver, too.
	flash protect 0 0 last off
}
$_TARGETNAME configure -event gdb-flash-erase-start {
	flash protect 0 0 7 off
}

$_TARGETNAME configure -work-area-phys 0xA0000000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base> <size> <chip_width> <bus_width>
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME str7x 0x80000000 0x00040000 0 0 $_TARGETNAME STR73x
#STR750 CPU

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME str750
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x4f1f0041
}

# jtag speed
adapter speed 10

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst srst_pulls_trst

#jtag scan chain

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID

#jtag nTRST and nSRST delay
adapter srst delay 500
jtag_ntrst_delay 500

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian little -chain-position 0

$_TARGETNAME configure -event reset-start { adapter speed 10 }
$_TARGETNAME configure -event reset-init {
	adapter speed 3000

	init_smi
# Because the hardware cannot be interrogated for the protection state
# of sectors, initialize all the sectors to be unprotected. The initial
# state is reflected by the driver, too.
	flash protect 0 0 last off
	flash protect 1 0 last off
}
$_TARGETNAME configure -event gdb-flash-erase-start {
	flash protect 0 0 7 off
	flash protect 1 0 1 off
}

$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0

#flash bank <driver> <base> <size> <chip_width> <bus_width>
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 $_TARGETNAME STR75x
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME str7x 0x200C0000 0x00004000 0 0 $_TARGETNAME STR75x

# Serial NOR on SMI CS0.
set _FLASHNAME $_CHIPNAME.snor
flash bank $_FLASHNAME stmsmi 0x80000000 0 0 0 $_TARGETNAME

source [find mem_helper.tcl]

proc init_smi {} {
	mmw 0x60000030 0x01000000 0x00000000; # enable clock for GPIO regs
	mmw 0xffffe420 0x00000001 0x00000000; # set SMI_EN bit
	mmw 0x90000000 0x00000001 0x00000000; # set BLOCK_EN_1
}
# script for str9

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME str912
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

# jtag speed. We need to stick to 16kHz until we've finished reset.
adapter speed 16

adapter srst delay 100
jtag_ntrst_delay 100

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst

if { [info exists FLASHTAPID] } {
   set _FLASHTAPID $FLASHTAPID
} else {
   set _FLASHTAPID 0x04570041
}
jtag newtap $_CHIPNAME flash -irlen 8 -ircapture 0x1 -irmask 0x1 -expected-id $_FLASHTAPID

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x25966041
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID


if { [info exists BSTAPID] } {
   set _BSTAPID $BSTAPID
} else {
   # possible values: 0x1457f041, 0x2457f041
   # we ignore version in check below
   set _BSTAPID 0x1457f041
}
jtag newtap $_CHIPNAME bs -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID -ignore-version

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-start { adapter speed 16 }

$_TARGETNAME configure -event reset-init {
	# We can increase speed now that we know the target is halted.
	#adapter speed 3000

	# -- Enable 96K RAM
	# PFQBC enabled / DTCM & AHB wait-states disabled
	mww 0x5C002034 0x0191

	str9x flash_config 0 4 2 0 0x80000
	flash protect 0 0 7 off
}

$_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 0

#flash bank str9x <base> <size> 0 0 <target#> <variant>
set _FLASHNAME $_CHIPNAME.flash0
flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 $_TARGETNAME
set _FLASHNAME $_CHIPNAME.flash1
flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 $_TARGETNAME
# ARM Debug Interface V5 (ADI_V5) utility
# ... Mostly for SWJ-DP (not SW-DP or JTAG-DP, since
# SW-DP and JTAG-DP targets don't need to switch based
# on which transport is active.
#
# declare a JTAG or SWD Debug Access Point (DAP)
# based on the transport in use with this session.
# You can't access JTAG ops when SWD is active, etc.

# params are currently what "jtag newtap" uses
# because OpenOCD internals are still strongly biased
# to JTAG ....  but for SWD, "irlen" etc are ignored,
# and the internals work differently

# for now, ignore non-JTAG and non-SWD transports
# (e.g. initial flash programming via SPI or UART)

# split out "chip" and "tag" so we can someday handle
# them more uniformly irlen too...)

if [catch {transport select}] {
  echo "Error: unable to select a session transport. Can't continue."
  shutdown
}

proc swj_newdap {chip tag args} {
 if [using_jtag] {
     eval jtag newtap $chip $tag $args
 } elseif [using_swd] {
     eval swd newdap $chip $tag $args
 } else {
     echo "Error: transport '[ transport select ]' not supported by swj_newdap"
     shutdown
 }
}
# Synwit SWM050

source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME swm050
}
set _CHIPSERIES swm050

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x400
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap
$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME swm050 0x0 0x2000 0 0 $_TARGETNAME

adapter speed 1000

$_TARGETNAME configure -event reset-init {
	# Stop the watchdog, just to be safe
	mww 0x40019000 0x00
	# Set clock divider value to 1
	mww 0x400F0000 0x01
	# Set system clock to 18Mhz
	mww 0x400F0008 0x00
}

# SWM050 (Cortex-M0 core) supports SYSRESETREQ
if {![using_hla]} {
    # if srst is not fitted use SYSRESETREQ to
    # perform a soft reset
    cortex_m reset_config sysresetreq
}
# Test script to check that syntax error in reset
# script is reported properly.

# at91eb40a target

#jtag scan chain
set _CHIPNAME syntaxtest
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf

#target configuration
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -event reset-init {

	syntax error
}
# This script tests a syntax error in the startup
# config script

syntax error here
#
# Texas Instruments AR7 SOC - used in many adsl modems.
# http://www.linux-mips.org/wiki/AR7
#

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME ti-ar7
}

if { [info exists ENDIAN] } {
    set _ENDIAN $ENDIAN
} else {
    set _ENDIAN little
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    set _CPUTAPID 0x0000100f
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_CHIPNAME.cpu

# use onboard 4k sram as working area
$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x00001000
# A start sequence to change from cJTAG to 4-pin JTAG
# This is needed for CC2538 and CC26xx to be able to communicate through JTAG
# Read section 6.3 in http://www.ti.com/lit/pdf/swru319 for more information.
proc ti_cjtag_to_4pin_jtag {jrc} {
	# Bypass
	irscan $jrc 0x3f -endstate RUN/IDLE
	# Two zero bit scans and a one bit drshift
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRUPDATE RUN/IDLE
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRUPDATE RUN/IDLE
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DREXIT1 DRUPDATE RUN/IDLE
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE

	# A two bit drhift and a 9 bit drshift
	pathmove DRPAUSE DREXIT2 DRSHIFT DRSHIFT DREXIT1 DRUPDATE RUN/IDLE
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DRSHIFT DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DRSHIFT DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DRSHIFT DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DRSHIFT DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRSHIFT DREXIT1 DRPAUSE
	pathmove DRPAUSE DREXIT2 DRUPDATE RUN/IDLE
	pathmove RUN/IDLE DRSELECT DRCAPTURE DREXIT1 DRPAUSE

	# Bypass
	irscan $jrc 0x3f -endstate RUN/IDLE

	# Set ICEPick IDCODE in data register
	irscan $jrc 0x04 -endstate RUN/IDLE
}
#
# TI Calypso (lite) G2 C035 Digital Base Band chip
#
# ARM7TDMIE + DSP subchip (S28C128)
#
# 512K SRAM Calypso
# 256K SRAM Calypso lite
#
if { [info exists CHIPNAME] } {
	set  _CHIPNAME $CHIPNAME
} else {
	set  _CHIPNAME calypso
}

if { [info exists ENDIAN] } {
	set  _ENDIAN $ENDIAN
} else {
	set  _ENDIAN little
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x3100e02f
}

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x10000
}

adapter speed 1000

reset_config trst_and_srst

jtag newtap $_CHIPNAME dsp -expected-id 0x00000000 -irlen 8
jtag newtap $_CHIPNAME arm -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

# target

set _TARGETNAME $_CHIPNAME.arm
target create $_TARGETNAME arm7tdmi -endian little -chain-position $_TARGETNAME

# workarea

$_TARGETNAME configure -work-area-phys 0x00800000 -work-area-size $_WORKAREASIZE -work-area-backup 1

arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable

$_TARGETNAME configure -event examine-start {
	irscan calypso.arm 0x0b -endstate DRPAUSE
	drscan calypso.arm 2 2 -endstate RUN/IDLE
}
#
# Texas Instruments CC13x0 - ARM Cortex-M3
#
# http://www.ti.com
#

set CHIPNAME cc13x0
set JRC_TAPID 0x0B9BE02F
set WORKAREASIZE 0x4000

source [find target/ti_cc26x0.cfg]
#
# Texas Instruments CC13x2 - ARM Cortex-M4
#
# http://www.ti.com
#

set CHIPNAME cc13x2
set JRC_TAPID 0x0BB4102F
set WORKAREASIZE 0x7000

source [find target/ti_cc26x0.cfg]
#
# Texas Instruments CC26x0 - ARM Cortex-M3
#
# http://www.ti.com
#

source [find target/icepick.cfg]
source [find target/ti-cjtag.cfg]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME cc26x0
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4BA00477
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "icepick_c_tapenable $_CHIPNAME.jrc 0"

#
# ICEpick-C (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID 0x0B99A02F
}
jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version
jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.cpu"
# A start sequence is needed to change from 2-pin cJTAG to 4-pin JTAG
jtag configure $_CHIPNAME.jrc -event post-reset "ti_cjtag_to_4pin_jtag $_CHIPNAME.jrc"

set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x4000
}

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cc26xx 0 0 0 0 $_TARGETNAME

cortex_m reset_config vectreset
#
# Texas Instruments CC26x2 - ARM Cortex-M4
#
# http://www.ti.com
#

set CHIPNAME cc26x2
set JRC_TAPID 0x0BB4102F
set WORKAREASIZE 0x7000

source [find target/ti_cc26x0.cfg]
#
# Texas Instruments CC3220SF - ARM Cortex-M4
#
# http://www.ti.com/CC3220SF
#

source [find target/swj-dp.tcl]
source [find target/icepick.cfg]
source [find target/ti_cc32xx.cfg]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME cc3220sf 0 0 0 0 $_TARGETNAME

#
# On CC32xx family of devices, sysreqreset is disabled, and vectreset is
# blocked by the boot loader (stops in a while(1) statement). srst reset can
# leave the target in a state that prevents debug. The following uses the
# soft_reset_halt command to reset and halt the target. Then the PC and stack
# are initialized from internal flash. This allows for a more reliable reset,
# but with two caveats: it only works for the SF variant that has internal
# flash, and it only resets the CPU and not any peripherals.
#

proc ocd_process_reset_inner { MODE } {

	soft_reset_halt

	# Initialize MSP, PSP, and PC from vector table at flash 0x01000800
	mem2array boot 32 0x01000800 2

	reg msp $boot(0)
	reg psp $boot(0)
	reg pc $boot(1)

	if { 0 == [string compare $MODE run ] } {
		resume
	}

	cc32xx.cpu invoke-event reset-end
}
#
# Texas Instruments CC32xx - ARM Cortex-M4
#
# http://www.ti.com/product/CC3200
# http://www.ti.com/product/CC3220
#

source [find target/swj-dp.tcl]
source [find target/icepick.cfg]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME cc32xx
}

#
# Main DAP
#
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	if {[using_jtag]} {
		set _DAP_TAPID 0x4BA00477
	} else {
		set _DAP_TAPID 0x2BA01477
	}
}

if {[using_jtag]} {
	jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
	jtag configure $_CHIPNAME.cpu -event tap-enable "icepick_c_tapenable $_CHIPNAME.jrc 0"
} else {
	swj_newdap $_CHIPNAME cpu -expected-id $_DAP_TAPID
}

#
# ICEpick-C (JTAG route controller)
#
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
} else {
	set _JRC_TAPID 0x0B97C02F
}

if {[using_jtag]} {
	jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f -expected-id $_JRC_TAPID -ignore-version
	jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.cpu"
}

set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x2000
}

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
#
# Texas Instruments DaVinci family: TMS320DM355
#
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dm355
}

# TI boards default to EMU0/EMU1 *high* -- ARM and ETB are *disabled*
# after JTAG reset until ICEpick is used to route them in.
set EMU01 "-disable"

# With EMU0/EMU1 jumpered *low* ARM and ETB are *enabled* without
# needing any ICEpick interaction.
#set EMU01 "-enable"

source [find target/icepick.cfg]

#
# Also note: when running without RTCK before the PLLs are set up, you
# may need to slow the JTAG clock down quite a lot (under 2 MHz).
#

# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
if { [info exists ETB_TAPID] } {
   set _ETB_TAPID $ETB_TAPID
} else {
   set _ETB_TAPID 0x2b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETB_TAPID $EMU01
jtag configure $_CHIPNAME.etb -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 1"

# Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
if { [info exists CPU_TAPID] } {
   set _CPU_TAPID $CPU_TAPID
} else {
   set _CPU_TAPID 0x07926001
}
jtag newtap $_CHIPNAME arm -irlen 4 -irmask 0xf -expected-id $_CPU_TAPID $EMU01
jtag configure $_CHIPNAME.arm -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 0"

# Primary TAP: ICEpick (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b73b02f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -irmask 0x3f -expected-id $_JRC_TAPID

jtag configure $_CHIPNAME.jrc -event setup \
	"jtag tapenable $_CHIPNAME.etb; jtag tapenable $_CHIPNAME.arm"

################

# various symbol definitions, to avoid hard-wiring addresses
# and enable some sharing of DaVinci-family utility code
global dm355
set dm355 [ dict create ]

# Physical addresses for controllers and memory
# (Some of these are valid for many DaVinci family chips)
dict set dm355 sram0		0x00010000
dict set dm355 sram1		0x00014000
dict set dm355 sysbase		0x01c40000
dict set dm355 pllc1		0x01c40800
dict set dm355 pllc2		0x01c40c00
dict set dm355 psc		0x01c41000
dict set dm355 gpio		0x01c67000
dict set dm355 a_emif		0x01e10000
dict set dm355 a_emif_cs0	0x02000000
dict set dm355 a_emif_cs1	0x04000000
dict set dm355 ddr_emif		0x20000000
dict set dm355 ddr		0x80000000
dict set dm355 uart0		0x01c20000
dict set dm355 uart1		0x01c20400
dict set dm355 uart2		0x01e06000

source [find target/davinci.cfg]

################
# GDB target: the ARM, using SRAM1 for scratch.  SRAM0 (also 16K)
# and the ETB memory (4K) are other options, while trace is unused.
set _TARGETNAME $_CHIPNAME.arm

target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME

# NOTE that work-area-virt presumes a Linux 2.6.30-rc2+ kernel,
# and that the work area is used only with a kernel mmu context ...
$_TARGETNAME configure \
	-work-area-virt [expr 0xfffe0000 + 0x4000] \
	-work-area-phys [dict get $dm355 sram1] \
	-work-area-size 0x4000 \
	-work-area-backup 0

# be absolutely certain the JTAG clock will work with the worst-case
# CLKIN = 24 MHz (best case: 36 MHz) even when no bootloader turns
# on the PLL and starts using it.  OK to speed up after clock setup.
adapter speed 1500
$_TARGETNAME configure -event "reset-start" { adapter speed 1500 }

arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
#
# Texas Instruments DaVinci family: TMS320DM365
#
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dm365
}

# TI boards default to EMU0/EMU1 *high* -- ARM and ETB are *disabled*
# after JTAG reset until ICEpick is used to route them in.
set EMU01 "-disable"

# With EMU0/EMU1 jumpered *low* ARM and ETB are *enabled* without
# needing any ICEpick interaction.
#set EMU01 "-enable"

source [find target/icepick.cfg]

# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
if { [info exists ETB_TAPID] } {
   set _ETB_TAPID $ETB_TAPID
} else {
   set _ETB_TAPID 0x2b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETB_TAPID $EMU01
jtag configure $_CHIPNAME.etb -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 1"

# Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
if { [info exists CPU_TAPID] } {
   set _CPU_TAPID $CPU_TAPID
} else {
   set _CPU_TAPID 0x0792602f
}
jtag newtap $_CHIPNAME arm -irlen 4 -irmask 0xf -expected-id $_CPU_TAPID $EMU01
jtag configure $_CHIPNAME.arm -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 0"

# Primary TAP: ICEpick (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b83e02f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -irmask 0x3f -expected-id $_JRC_TAPID

jtag configure $_CHIPNAME.jrc -event setup \
	"jtag tapenable $_CHIPNAME.etb; jtag tapenable $_CHIPNAME.arm"

################

# various symbol definitions, to avoid hard-wiring addresses
# and enable some sharing of DaVinci-family utility code
global dm365
set dm365 [ dict create ]

# Physical addresses for controllers and memory
# (Some of these are valid for many DaVinci family chips)
dict set dm365 sram0		0x00010000
dict set dm365 sram1		0x00014000
dict set dm365 sysbase		0x01c40000
dict set dm365 pllc1		0x01c40800
dict set dm365 pllc2		0x01c40c00
dict set dm365 psc		0x01c41000
dict set dm365 gpio		0x01c67000
dict set dm365 a_emif		0x01d10000
dict set dm365 a_emif_cs0	0x02000000
dict set dm365 a_emif_cs1	0x04000000
dict set dm365 ddr_emif		0x20000000
dict set dm365 ddr		0x80000000

source [find target/davinci.cfg]

################
# GDB target: the ARM, using SRAM1 for scratch.  SRAM0 (also 16K)
# and the ETB memory (4K) are other options, while trace is unused.
set _TARGETNAME $_CHIPNAME.arm

target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME

# NOTE that work-area-virt presumes a Linux 2.6.30-rc2+ kernel,
# and that the work area is used only with a kernel mmu context ...
$_TARGETNAME configure \
	-work-area-virt [expr 0xfffe0000 + 0x4000] \
	-work-area-phys [dict get $dm365 sram1] \
	-work-area-size 0x4000 \
	-work-area-backup 0

# be absolutely certain the JTAG clock will work with the worst-case
# CLKIN = 19.2 MHz (best case: 36 MHz) even when no bootloader turns
# on the PLL and starts using it.  OK to speed up after clock setup.
adapter speed 1500
$_TARGETNAME configure -event "reset-start" { adapter speed 1500 }

arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
#
# Texas Instruments DaVinci family: TMS320DM6446
#
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME dm6446
}

# TI boards default to EMU0/EMU1 *high* -- ARM and ETB are *disabled*
# after JTAG reset until ICEpick is used to route them in.
set EMU01 "-disable"

# With EMU0/EMU1 jumpered *low* ARM and ETB are *enabled* without
# needing any ICEpick interaction.
#set EMU01 "-enable"

source [find target/icepick.cfg]

# Subsidiary TAP: unknown ... must enable via ICEpick
jtag newtap $_CHIPNAME unknown -irlen 8 -disable
jtag configure $_CHIPNAME.unknown -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 3"

# Subsidiary TAP: C64x+ DSP ... must enable via ICEpick
jtag newtap $_CHIPNAME dsp -irlen 38 -ircapture 0x25 -irmask 0x3f -disable
jtag configure $_CHIPNAME.dsp -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 2"

# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
if { [info exists ETB_TAPID] } {
   set _ETB_TAPID $ETB_TAPID
} else {
   set _ETB_TAPID 0x2b900f0f
}
jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETB_TAPID $EMU01
jtag configure $_CHIPNAME.etb -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 1"

# Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
if { [info exists CPU_TAPID] } {
   set _CPU_TAPID $CPU_TAPID
} else {
   set _CPU_TAPID 0x07926001
}
jtag newtap $_CHIPNAME arm -irlen 4 -irmask 0xf -expected-id $_CPU_TAPID $EMU01
jtag configure $_CHIPNAME.arm -event tap-enable \
	"icepick_c_tapenable $_CHIPNAME.jrc 0"

# Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
if { [info exists JRC_TAPID] } {
   set _JRC_TAPID $JRC_TAPID
} else {
   set _JRC_TAPID 0x0b70002f
}
jtag newtap $_CHIPNAME jrc -irlen 6 -irmask 0x3f -expected-id $_JRC_TAPID

jtag configure $_CHIPNAME.jrc -event setup \
	"jtag tapenable $_CHIPNAME.etb; jtag tapenable $_CHIPNAME.arm"

################
# GDB target: the ARM, using SRAM1 for scratch.  SRAM0 (also 8K)
# and the ETB memory (4K) are other options, while trace is unused.
# Little-endian; use the OpenOCD default.
set _TARGETNAME $_CHIPNAME.arm

target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME
$_TARGETNAME configure -work-area-phys 0x0000a000 -work-area-size 0x2000

# be absolutely certain the JTAG clock will work with the worst-case
# CLKIN = 20 MHz (best case: 30 MHz) even when no bootloader turns
# on the PLL and starts using it.  OK to speed up after clock setup.
adapter speed 1500
$_TARGETNAME configure -event "reset-start" { adapter speed 1500 }

arm7_9 fast_memory_access enable
arm7_9 dcc_downloads enable

# trace setup
etm config $_TARGETNAME 16 normal full etb
etb config $_TARGETNAME $_CHIPNAME.etb
#
# Texas Instruments MSP432 - ARM Cortex-M4F @ up to 48 MHz
#
# http://www.ti.com/MSP432
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME msp432
}

if { [info exists CPUTAPID] } {
	set _DAP_TAPID $CPUTAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

if { [info exists DAP_SWD_ID] } {
	set _DAP_SWD_ID $DAP_SWD_ID
} else {
	set _DAP_SWD_ID 0x2ba01477
}

source [find target/swj-dp.tcl]

if { [using_jtag] } {
	set _DAP_ID $_DAP_TAPID
} else {
	set _DAP_ID $_DAP_SWD_ID
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_ID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x4000
}


$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME msp432 0 0 0 0 $_TARGETNAME

cortex_m reset_config sysresetreq
source [find target/ti_tms570.cfg]
adapter speed 1500

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME tms570
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
	set _ENDIAN big
}

# TMS570 has an ICEpick-C on which we need the router commands.
source [find target/icepick.cfg]

# Main DAP
# DAP_TAPID should be set before source-ing this file
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "icepick_c_tapenable $_CHIPNAME.jrc 0"

# ICEpick-C (JTAG route controller)
# JRC_TAPID should be set before source-ing this file
if { [info exists JRC_TAPID] } {
	set _JRC_TAPID $JRC_TAPID
}

set _JRC_TAPID2 0x0B7B302F
set _JRC_TAPID3 0x0B95502F
set _JRC_TAPID4 0x0B97102F
set _JRC_TAPID5 0x0D8A002F
set _JRC_TAPID6 0x2B8A002F
set _JRC_TAPID7 0x2D8A002F
set _JRC_TAPID8 0x3B8A002F
set _JRC_TAPID9 0x3D8A002F


jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
	-expected-id $_JRC_TAPID \
	-expected-id $_JRC_TAPID2 \
	-expected-id $_JRC_TAPID3 \
	-expected-id $_JRC_TAPID4 \
	-expected-id $_JRC_TAPID5 \
	-expected-id $_JRC_TAPID6 \
	-expected-id $_JRC_TAPID7 \
	-expected-id $_JRC_TAPID8 \
	-expected-id $_JRC_TAPID9 \
	-ignore-version
jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.cpu"
jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Cortex-R4 target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_r4 -endian $_ENDIAN \
	-dap $_CHIPNAME.dap -coreid 0 -dbgbase 0x00001003

# TMS570 uses quirky BE-32 mode
$_CHIPNAME.dap ti_be_32_quirks 1

$_TARGETNAME configure -event "reset-assert" {
	global _CHIPNAME

	# assert warm system reset through ICEPick
	icepick_c_wreset $_CHIPNAME.jrc
}
# TMS570LS20216, TMS570LS20206, TMS570LS10216
# TMS570LS10206, TMS570LS10116, TMS570LS10106
set DAP_TAPID 0x0B7B302F
set JRC_TAPID 0x0B7B302F

source [find target/ti_tms570.cfg]
# TMS570LS3137
set DAP_TAPID 0x0B8A002F
set JRC_TAPID 0x0B8A002F

source [find target/ti_tms570.cfg]
######################################
# Target:    Toshiba TMPA900
######################################

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME tmpa900
}

# Toshiba TMPA900 series MCUs are always little endian as per datasheet.
set _ENDIAN little

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926031
}

#TMPA900 has following IDs:
# CP15.0 register 0x41069265
# CP15.1 register 0x1d152152
# ARM core 0x07926031


#
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst
adapter srst delay 20
jtag_ntrst_delay 20

######################
# Target configuration
######################

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

# Internal RAM-0 (16kB): 0xf8004000
# Internal RAM-1 (8kB): 0xf8008000

# Use internal RAM-0 and RAM-1 as working area (24kB total).
$_TARGETNAME configure -work-area-phys 0xf8004000 -work-area-size 0x6000 \
-work-area-backup 0
######################################
# Target:    Toshiba TMPA910
######################################

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME tmpa910
}

# Toshiba TMPA910 series MCUs are always little endian as per datasheet.
set _ENDIAN little

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x07926031
}

#TMPA910 has following IDs:
# CP15.0 register 0x41069265
# CP15.1 register 0x1d152152
# ARM core 0x07926031


#
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst
adapter srst delay 20
jtag_ntrst_delay 20

######################
# Target configuration
######################

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

# Internal RAM-0 (16kB): 0xf8004000
# Internal RAM-1 (16kB): 0xf8008000
# Internal RAM-2 (16kB): 0xf800c000

# Use internal RAM-0, RAM-1, and RAM-2 as working area (48kB total).
$_TARGETNAME configure -work-area-phys 0xf8004000 -work-area-size 0xc000 \
-work-area-backup 0
# Texas Instruments (TI) TNETC4401, MIPS32 DOCSIS-tailored SoC (4Kc-based)
# Used in Knovative KC-100 and Motorola Surfboard SB5120 cable modems.
# Datasheet: https://brezn.muc.ccc.de/~mazzoo/DOCSIS/tnetc4401.pdf
transport select jtag
set _TARGETNAME tnetc4401
set _CPUTAPID 0x0000100f
jtag newtap $_TARGETNAME tap -irlen 5 -ircapture 0x01 -irmask 0x1f -expected-id $_CPUTAPID
target create $_TARGETNAME mips_m4k -chain-position $_TARGETNAME.tap -endian big

# May need to halt manually before calling reset init
$_TARGETNAME configure -event reset-init {
	halt
	echo "Attempting to disable watchdog..."
	mwb phys 0xa8610b00 0 256
	halt
	wait_halt
}
#  Copyright (C) ST-Ericsson SA 2011
#  Author : michel.jaouen@stericsson.com
#  U8500 target

proc mmu_off {} {
	set cp [arm mrc 15 0 1 0 0]
	set cp [expr ($cp & ~1)]
	arm mcr 15 0 1 0 0 $cp
}

proc mmu_on {} {
	set cp [arm mrc 15 0 1 0 0]
	set cp [expr ($cp | 1)]
	arm mcr 15 0 1 0 0 $cp
}

proc ocd_gdb_restart {target_id} {
    global _TARGETNAME_1
	global _SMP
    targets $_TARGETNAME_1
	if { [expr ($_SMP == 1)] } {
	cortex_a smp off
	}
	rst_run
	halt
	if { [expr ($_SMP == 1)]} {
	cortex_a smp on
	}
}

proc smp_reg {} {
	global _TARGETNAME_1
    global _TARGETNAME_2
    targets $_TARGETNAME_1
	echo "$_TARGETNAME_1"
	set pc1 [reg pc]
	set stck1 [reg sp_svc]
	targets $_TARGETNAME_2
	echo "$_TARGETNAME_1"
	set pc2 [reg pc]
	set stck2 [reg sp_svc]
}


proc u8500_tapenable {chip val} {
	echo "JTAG tap enable $chip"
}


proc pwrsts { } {
	global _CHIPNAME
	irscan $_CHIPNAME.jrc 0x3a
	drscan $_CHIPNAME.jrc 4 0
	set pwrsts [drscan $_CHIPNAME.jrc 16 0]
    echo "pwrsts ="$pwrsts
    set a9 [expr (0x$pwrsts & 0xc)]
	set ape [expr (0x$pwrsts & 0x3)]
	if {[string equal "0" $ape]} {
		echo "ape off"
	} else {
		echo "ape on"
	}
	echo "$a9"
	switch $a9 {
		4 {
			echo "A9 in retention"
		  }
		8 {
			echo "A9 100% DVFS"
		  }
		c {
			echo "A9 50% DVFS"
		}
	}
}

proc poll_pwrsts { } {
	global _CHIPNAME
	set result 1
	set i 0
	irscan $_CHIPNAME.jrc 0x3a
	drscan $_CHIPNAME.jrc 4 0
	set pwrsts [drscan $_CHIPNAME.jrc 16 0]
	set pwrsts [expr (0x$pwrsts & 0xc)]
	while {[string equal "4" $pwrsts] && $i<20} {
		irscan $_CHIPNAME.jrc 0x3a
		drscan $_CHIPNAME.jrc 4 0;
		set pwrsts [drscan $_CHIPNAME.jrc 16 0]
		set pwrsts [expr (0x$pwrsts & 0xc)]
		if {![string equal "4" $pwrsts]} {
			set result 1
		} else {
			set result 0
			sleep 200
			echo "loop $i"
		}
		incr i
	}
	return $result
}

proc halt_ { } {
	if {[poll_pwrsts]==1} {
		halt
	} else {
		echo "halt failed : target in retention"
	}
}


proc u8500_dapenable {chip} {
}

proc u8500_tapdisable {chip val} {
	echo "JTAG tap disable $chip"
}


proc enable_apetap {} {
	global _CHIPNAME
	global _TARGETNAME_2
    global _TARGETNAME_1
	poll off
	irscan $_CHIPNAME.jrc 0x3e
	drscan $_CHIPNAME.jrc 8 0xcf
	jtag tapenable $_CHIPNAME.dap
	irscan $_CHIPNAME.jrc 0x6
	drscan $_CHIPNAME.jrc 32 0
	irscan $_CHIPNAME.jrc 0x6
	drscan $_CHIPNAME.jrc 32 0
	set status [$_TARGETNAME_1 curstate]
    if {[string equal "unknown" $status]} {
	$_TARGETNAME_1 arp_examine
	cache_config l2x 0xa0412000 8
	}

	set status [$_TARGETNAME_2 curstate]
    if {[string equal "unknown" $status]} {
	$_TARGETNAME_2 arp_examine
	}
	}

tcl_port 5555
telnet_port 4444
gdb_port 3333

if { [info exists CHIPNAME] } {
global _CHIPNAME
    set _CHIPNAME $CHIPNAME
} else {
global _CHIPNAME
	set _CHIPNAME u8500
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
 # this defaults to a bigendian
	set _ENDIAN little
}



# Subsidiary TAP: APE with scan chains for ARM Debug, EmbeddedICE-RT,
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x4ba00477
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_CPUTAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable \
	"u8500_dapenable $_CHIPNAME.cpu"
jtag configure $_CHIPNAME.cpu -event tap-disable \
	"u8500_tapdisable $_CHIPNAME.cpu 0xc0"


#CLTAPC TAP JRC equivalent
if { [info exists CLTAPC_ID] } {
   set _CLTAPC_ID $CLTAPC_ID
} else {
   set _CLTAPC_ID 0x22286041
}
jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x6 -irmask 0xf -expected-id $_CLTAPC_ID -ignore-version


if { ![info exists TARGETNAME_1] } {
global _TARGETNAME_1
set _TARGETNAME_1 $_CHIPNAME.cpu1
} else {
global _TARGETNAME_1
set _TARGETNAME_1 $TARGETNAME_1
}

if { [info exists DAP_DBG1] } {
	set _DAP_DBG1 $DAP_DBG1
} else {
	set _DAP_DBG1 0x801A8000
}
if { [info exists DAP_DBG2] } {
	set _DAP_DBG2 $DAP_DBG2
} else {
	set _DAP_DBG2 0x801AA000
}

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME_1 cortex_a -dap $_CHIPNAME.dap -dbgbase $_DAP_DBG1 -coreid 0 -rtos linux


if { ![info exists TARGETNAME_2] } {
global _TARGETNAME_2
set _TARGETNAME_2 $_CHIPNAME.cpu2
} else {
global _TARGETNAME_2
set _TARGETNAME_2 $TARGETNAME_2
}

target create $_TARGETNAME_2 cortex_a -dap $_CHIPNAME.dap -dbgbase $_DAP_DBG2 -coreid 1 -rtos linux


if {![info exists SMP]} {
global _SMP
set _SMP 1
} else {
global _SMP
set _SMP $SMP
}
global SMP
if { $_SMP == 1} {
target smp $_CHIPNAME.cpu2 $_CHIPNAME.cpu1
}




proc secsts1 { } {
	global _CHIPNAME
        irscan $_CHIPNAME.jrc 0x3a
		drscan $_CHIPNAME.jrc 4 4
	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
	echo "secsts1 ="$secsts1
	set secsts1 [expr (0x$secsts1 & 0x4)]
	if {![string equal "4" $secsts1]} {
	echo "APE target secured"
        } else {
        echo "APE target not secured"
        }
}

proc att { } {
	global _CHIPNAME
	jtag arp_init
	irscan $_CHIPNAME.jrc 0x3a
	drscan $_CHIPNAME.jrc 4 4
	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
	echo "secsts1 ="$secsts1
	set secsts1 [expr (0x$secsts1 & 0x4)]
	if {[string equal "4" $secsts1]} {
		if {[poll_pwrsts]==1} {
		enable_apetap
                } else {
		echo "target in retention"
		}
	} else {
		echo "target secured"
	}

}



proc rst_run { } {
	global _CHIPNAME
	global _TARGETNAME_2
	global _TARGETNAME_1
	set status [$_TARGETNAME_1 curstate]
	if {[string equal "halted" $status]} {
	resume
	targets $_TARGETNAME_1
	}
    set status [$_TARGETNAME_2 curstate]
	if {[string equal "halted" $status]} {
	resume
	targets $_TARGETNAME_2
	}
   	poll off
	jtag arp_init
	reset
	sleep 20
	irscan $_CHIPNAME.jrc 0x3a
	drscan $_CHIPNAME.jrc 4 4
	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
	echo "secsts1 ="$secsts1
	set secsts1 [expr (0x$secsts1 & 0x4)]
	while {![string equal "4" $secsts1]} {
		irscan u8500.jrc 0x3a
		drscan u8500.jrc 4 4
		set secsts1 [drscan $_CHIPNAME.jrc 16 0]
		echo "secsts1 ="$secsts1
		set secsts1 [expr (0x$secsts1 & 0x4)]
	}
	echo "ape debugable"
	enable_apetap
	poll on
	targets $_TARGETNAME_1
	dap apsel 1
}

if {![info exists MAXSPEED]} {
global _MAXSPEED
set _MAXSPEED 15000
} else {
global _MAXSPEED
set _MAXSPEED $MAXSPEED
}
global _MAXSPEED
adapter speed $_MAXSPEED


gdb_breakpoint_override hard
set mem inaccessible-by-default-off

jtag_ntrst_delay 100
reset_config trst_and_srst combined
#
# Freescale Vybrid VF610
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME vf610
}

if { [info exists A5_JTAG_TAPID] } {
	set _A5_JTAG_TAPID $A5_JTAG_TAPID
} else {
	set _A5_JTAG_TAPID 0x4BA00477
}

if { [info exists A5_SWD_TAPID] } {
	set _A5_SWD_TAPID $A5_SWD_TAPID
} else {
	set _A5_SWD_TAPID 0x3BA02477
}

if { [using_jtag] } {
	set _A5_TAPID $_A5_JTAG_TAPID
} else {
	set _A5_TAPID $_A5_SWD_TAPID
}

source [find target/swj-dp.tcl]

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_A5_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create ${_TARGETNAME}0 cortex_a -dap $_CHIPNAME.dap -dbgbase 0xc0088000
target create ${_TARGETNAME}1 cortex_m -dap $_CHIPNAME.dap -ap-num 3 -defer-examine
adapter speed 1000
#
# target configuration for
# Xilinx ZynqMP (UltraScale+ / A53)
#
if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME uscale
}

#
# DAP tap (Quard core A53)
#
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x5ba00477
}

jtag newtap $_CHIPNAME tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap

#
# PS tap (UltraScale+)
#
if { [info exists PS_TAPID] } {
    set _PS_TAPID $PS_TAPID
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -expected-id $_PS_TAPID
} else {
    # FPGA Programmable logic. Values take from Table 39-1 in UG1085:
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -ignore-version \
        -expected-id 0x04711093 \
        -expected-id 0x04710093 \
        -expected-id 0x04721093 \
        -expected-id 0x04720093 \
        -expected-id 0x04739093 \
        -expected-id 0x04730093 \
        -expected-id 0x04738093 \
        -expected-id 0x04740093 \
        -expected-id 0x04750093 \
        -expected-id 0x04759093 \
        -expected-id 0x04758093
}

set jtag_configured 0

jtag configure $_CHIPNAME.ps -event setup {
    global _CHIPNAME
    global jtag_configured

    if { $jtag_configured == 0 } {
        # add the DAP tap to the chain
        # See https://forums.xilinx.com/t5/UltraScale-Architecture/JTAG-Chain-Configuration-for-Zynq-UltraScale-MPSoC/td-p/758924
        irscan $_CHIPNAME.ps 0x824
        drscan $_CHIPNAME.ps 32 0x00000003
        runtest 100

        # setup event will be re-entered through jtag arp_init
        # break the recursion
        set jtag_configured 1
        # re-initialized the jtag chain
        jtag arp_init
    }
}

set _TARGETNAME $_CHIPNAME.a53
set _CTINAME $_CHIPNAME.cti
set _smp_command ""

set DBGBASE {0x80410000 0x80510000 0x80610000 0x80710000}
set CTIBASE {0x80420000 0x80520000 0x80620000 0x80720000}
set _cores 4

for { set _core 0 } { $_core < $_cores } { incr _core } {

    cti create $_CTINAME.$_core -dap $_CHIPNAME.dap -ap-num 1 \
        -baseaddr [lindex $CTIBASE $_core]

    set _command "target create $_TARGETNAME.$_core aarch64 -dap $_CHIPNAME.dap \
        -dbgbase [lindex $DBGBASE $_core] -cti $_CTINAME.$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        set _command "$_command -defer-examine"
        set _smp_command "$_smp_command $_TARGETNAME.$_core"
    } else {
        # uncomment when "hawt" rtos is merged
        #set _command "$_command -rtos hawt"
        set _smp_command "target smp $_TARGETNAME.$_core"
    }

    eval $_command
}

eval $_smp_command
targets $_TARGETNAME.0

proc core_up { args } {
    global _TARGETNAME
    foreach { core } [set args] {
        $_TARGETNAME.$core arp_examine
    }
}
#
# Infineon XMC1100/XMC1200/XMC1300 family (ARM Cortex-M0 @ 32 MHz)
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xmc1000
}

#
# Only SWD and SPD supported
#
source [find target/swj-dp.tcl]

if { [info exists CPUTAPID] } {
	set _CPU_SWD_TAPID $CPUTAPID
} else {
	set _CPU_SWD_TAPID 0x0BB11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_SWD_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

$_TARGETNAME configure -work-area-phys 0x20000000 \
                       -work-area-size $_WORKAREASIZE \
                       -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME xmc1xxx 0x10000000 0 0 0 $_TARGETNAME

adapter speed 1000
#
# Infineon XMC4100/XMC4200/XMC4400/XMC4500 family (ARM Cortex-M4 @ 80-120 MHz)
#

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xmc4000
}

source [find target/swj-dp.tcl]

#
# SWJ-DP
#
if { [info exists CPU_JTAG_TAPID] } {
	set _CPU_JTAG_TAPID $CPU_JTAG_TAPID
} else {
	set _CPU_JTAG_TAPID 0x4BA00477
}

#
# SW_DP
#
if { [info exists CPU_SWD_TAPID] } {
	set _CPU_SWD_TAPID $CPU_SWD_TAPID
} else {
	set _CPU_SWD_TAPID 0x2BA01477
}

if { [using_jtag] } {
	set _CPU_TAPID $_CPU_JTAG_TAPID
} else {
	set _CPU_TAPID $_CPU_SWD_TAPID
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

# Work-area is a space in RAM used for flash programming
# By default use 16 kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME xmc4xxx 0x0C000000 0 0 0 $_TARGETNAME

if { ![using_hla] } {
	cortex_m reset_config sysresetreq
}

adapter speed 1000
#
# XMOS xCORE-XA XS1-XAU8A-10: ARM Cortex-M3 @ 48 MHz
#
# http://www.xmos.com/products/silicon/xcore-xa/xa-series
#

if { ![info exists CHIPNAME] } {
	set CHIPNAME xcorexa
}

if { ![info exists WORKAREASIZE] } {
	# XS1-XAU8A-10-FB265: 128 KB SRAM
	set WORKAREASIZE 0x20000
}

source [find target/efm32.cfg]
#
# Xilinx Zynq-7000 All Programmable SoC
#
# http://www.xilinx.com/products/silicon-devices/soc/zynq-7000/index.htm
#

set _CHIPNAME zynq
set _TARGETNAME $_CHIPNAME.cpu

jtag newtap zynq_pl bs -irlen 6 -ircapture 0x1 -irmask 0x03 \
    -expected-id 0x23727093 \
    -expected-id 0x13722093 \
    -expected-id 0x03727093 \
    -expected-id 0x03736093

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id 0x4ba00477

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create ${_TARGETNAME}0 cortex_a -dap $_CHIPNAME.dap \
    -coreid 0 -dbgbase 0x80090000
target create ${_TARGETNAME}1 cortex_a -dap $_CHIPNAME.dap \
    -coreid 1 -dbgbase 0x80092000
target smp ${_TARGETNAME}0 ${_TARGETNAME}1

adapter speed 1000

${_TARGETNAME}0 configure -event reset-assert-post "cortex_a dbginit"
${_TARGETNAME}1 configure -event reset-assert-post "cortex_a dbginit"

pld device virtex2 zynq_pl.bs 1

set XC7_JSHUTDOWN 0x0d
set XC7_JPROGRAM 0x0b
set XC7_JSTART 0x0c
set XC7_BYPASS 0x3f

proc zynqpl_program {tap} {
	global XC7_JSHUTDOWN XC7_JPROGRAM XC7_JSTART XC7_BYPASS
	irscan $tap $XC7_JSHUTDOWN
	irscan $tap $XC7_JPROGRAM
	runtest 60000
	#JSTART prevents this from working...
	#irscan $tap $XC7_JSTART
	runtest 2000
	irscan $tap $XC7_BYPASS
	runtest 2000
}
#  18791
# http://www.module.ru/catalog/micro/mikroshema_dekodera_cifrovogo_televizionnogo_signala_sbis_k1879hb1ya/

adapter speed 1000

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME 18791
}

if { [info exists ENDIAN] } {
    set _ENDIAN $ENDIAN
} else {
    set _ENDIAN little
}

if { [info exists DSP_TAPID] } {
    set _DSP_TAPID $DSP_TAPID
} else {
    set _DSP_TAPID 0x2b900f0f
}

jtag newtap $_CHIPNAME dsp -irlen 4 -expected-id $_DSP_TAPID

if { [info exists CPU_TAPID] } {
    set _CPU_TAPID $CPU_TAPID
} else {
    set _CPU_TAPID 0x07b76f0f
}

jtag newtap $_CHIPNAME arm -irlen 5 -expected-id $_CPU_TAPID

set _TARGETNAME $_CHIPNAME.arm
target create $_TARGETNAME arm11 -chain-position $_CHIPNAME.arm

add_help_text selftest "run selftest using working ram <tmpfile> <address> <size>"

proc selftest {tmpfile address size} {

   for {set i 0} {$i < $size } {set i [expr $i+4]} {
       mww [expr $address+$i] $i
   }

   for {set i 0} {$i < 10 } {set i [expr $i+1]} {
    echo "Test iteration $i"
    dump_image $tmpfile $address $size
	verify_image $tmpfile $address bin
	load_image $tmpfile $address bin
   }

}
adapter srst delay 200
jtag_ntrst_delay 200

#use combined on interfaces or targets that can't set TRST/SRST separately
reset_config trst_and_srst srst_pulls_trst

#LPCs need reset pulled while RTCK is low. 0 to activate JTAG, power-on reset is not enough
adapter assert trst assert srst
adapter deassert trst deassert srst

#jtag scan chain
#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
jtag newtap lpc2148 one -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id 0x4f1f0f0f

#target configuration
#daemon_startup reset

set _TARGETNAME [format "%s.cpu" lpc2148]
target create lpc2148.cpu arm7tdmi -endian little -work-area-size 0x4000 -work-area-phys 0x40000000 -work-area-backup 0

$_TARGETNAME configure -event reset-init {
soft_reset_halt
mvb 0xE01FC040 0x01
}



set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME lpc2000 0x0 0x7d000 0 0 0 lpc2000_v2 14765
echo "\n\nFirmware recovery helpers"
echo "Use -c firmware_help to get help\n"

set known_boards {
    "asus-rt-n16		ASUS RT-N16"
    "asus-rt-n66u		ASUS RT-N66U"
    "linksys-wag200g		Linksys WAG200G"
    "linksys-wrt54gl		Linksys WRT54GL v1.1"
    "netgear-dg834v3		Netgear DG834G v3"
    "tp-link_tl-mr3020		TP-LINK TL-MR3020"
    "bt-homehubv1		BT HomeHub v1"
}

proc firmware_help { } {
    echo "
Your OpenOCD command should look like this:
openocd -f interface/<jtag adapter>.cfg -f tools/firmware-recovery.tcl -c \"<commands>*; shutdown\"

Where:
<jtag adapter> is one of the supported devices, e.g. ftdi/jtagkey2
<commands> are firmware-recovery commands separated by semicolon

Supported commands:
firmware_help			get this help
list_boards			list known boards and exit
board <name>			select board you work with
list_partitions			list partitions of the currently selected board
dump_part <name> <filename>	save partition's contents to a file
erase_part <name>		erase the given partition
flash_part <name> <filename>	erase, flash and verify the given partition
ram_boot <filename>		load binary file to RAM and run it
adapter speed <freq>		set JTAG clock frequency in kHz

For example, to clear nvram and reflash CFE on an RT-N16 using TUMPA, run:
openocd -f interface/ftdi/tumpa.cfg -f tools/firmware-recovery.tcl \\
	-c \"board asus-rt-n16; erase_part nvram; flash_part CFE cfe-n16.bin; shutdown\"
\n\n"
    shutdown
}

# set default, can be overridden later
adapter speed 1000

proc get_partition { name } {
    global partition_list
    dict get $partition_list $name
}

proc partition_desc { name } { lindex [get_partition $name] 0 }
proc partition_start { name } { lindex [get_partition $name] 1 }
proc partition_size { name } { lindex [get_partition $name] 2 }

proc list_boards { } {
    global known_boards
    echo "List of the supported boards:\n"
    echo "Board name\t\tDescription"
    echo "-----------------------------------"
    foreach i $known_boards {
	echo $i
    }
    echo "\n\n"
}

proc board { name } {
    script [find board/$name.cfg]
}

proc list_partitions { } {
    global partition_list
    set fstr "%-16s%-14s%-14s%s"
    echo "\nThe currently selected board is known to have these partitions:\n"
    echo [format $fstr Name Start Size Description]
    echo "-------------------------------------------------------"
    for {set i 0} {$i < [llength $partition_list]} {incr i 2} {
	set key [lindex $partition_list $i]
	echo [format $fstr $key [partition_start $key] [partition_size $key] [partition_desc $key]]
    }
    echo "\n\n"
}

# Magic to work with any targets, including semi-functional
proc prepare_target { } {
    init
    catch {halt}
    catch {reset init}
    catch {halt}
}

proc dump_part { name filename } {
    prepare_target
    dump_image $filename [partition_start $name] [partition_size $name]
}

proc erase_part { name } {
    prepare_target
    flash erase_address [partition_start $name] [partition_size $name]
}

proc flash_part { name filename } {
    prepare_target
    flash write_image erase $filename [partition_start $name] bin
    echo "Verifying:"
    verify_image $filename [partition_start $name]
}

proc ram_boot { filename } {
    global ram_boot_address
    prepare_target
    load_image $filename $ram_boot_address bin
    resume $ram_boot_address
}

echo ""
# Algorithms by Michael Barr, released into public domain
# Ported to OpenOCD by Shane Volpe, additional fixes by Paul Fertser

set CPU_MAX_ADDRESS 0xFFFFFFFF
source [find bitsbytes.tcl]
source [find memory.tcl]

proc runAllMemTests { baseAddress nBytes } {
    memTestDataBus $baseAddress
    memTestAddressBus $baseAddress $nBytes
    memTestDevice $baseAddress $nBytes
}

#***********************************************************************************
# *
# * Function:    memTestDataBus()
# *
# * Description: Test the data bus wiring in a memory region by
# *              performing a walking 1's test at a fixed address
# *              within that region.  The address (and hence the
# *              memory region) is selected by the caller.
# *		 Ported from:
# *		 http://www.netrino.com/Embedded-Systems/How-To/Memory-Test-Suite-C
# * Notes:
# *
# * Returns:     Empty string if the test succeeds.
# *              A non-zero result is the first pattern that failed.
# *
#***********************************************************************************
proc memTestDataBus { address } {
    echo "Running memTestDataBus"

    for {set i 0} {$i < 32} {incr i} {
	# Shift bit
	set pattern [expr {1 << $i}]

	# Write pattern to memory
	memwrite32 $address $pattern

	# Read pattern from memory
	set data [memread32 $address]

	if {$data != $pattern} {
	    echo "FAILED DATABUS: Address: $address, Pattern: $pattern, Returned: $data"
	    return $pattern
	}
    }
}

#***********************************************************************************
# *
# * Function:    memTestAddressBus()
# *
# * Description: Perform a walking 1's test on the relevant bits
# *              of the address and check for aliasing.  This test
# *              will find single-bit address failures such as stuck
# *              -high, stuck-low, and shorted pins.  The base address
# *              and size of the region are selected by the caller.
# *		 Ported from:
# *		 http://www.netrino.com/Embedded-Systems/How-To/Memory-Test-Suite-C
# *
# * Notes:       For best results, the selected base address should
# *              have enough LSB 0's to guarantee single address bit
# *              changes.  For example, to test a 64-Kbyte region,
# *              select a base address on a 64-Kbyte boundary.  Also,
# *              select the region size as a power-of-two--if at all
# *              possible.
# *
# * Returns:     Empty string if the test succeeds.
# *              A non-zero result is the first address at which an
# *              aliasing problem was uncovered.  By examining the
# *              contents of memory, it may be possible to gather
# *              additional information about the problem.
# *
#***********************************************************************************
proc memTestAddressBus { baseAddress nBytes } {
    set addressMask [expr $nBytes - 1]
    set pattern 0xAAAAAAAA
    set antipattern 0x55555555

    echo "Running memTestAddressBus"

    echo "addressMask: [convertToHex $addressMask]"

    echo "memTestAddressBus: Writing the default pattern at each of the power-of-two offsets..."
    for {set offset 32} {[expr $offset & $addressMask] != 0} {set offset [expr $offset << 1] } {
	set addr [expr $baseAddress + $offset]
	memwrite32 $addr $pattern
    }

    echo "memTestAddressBus: Checking for address bits stuck high..."
    memwrite32 $baseAddress $antipattern

    for {set offset 32} {[expr $offset & $addressMask] != 0} {set offset [expr $offset << 1]} {
	set addr [expr $baseAddress + $offset]
	set data [memread32 $addr]

	if {$data != $pattern} {
	    echo "FAILED DATA_ADDR_BUS_SHIGH: Address: [convertToHex $addr], Pattern: [convertToHex $pattern], Returned: [convertToHex $data]"
	    return $pattern
	}
    }

    echo "memTestAddressBus: Checking for address bits stuck low or shorted..."
    memwrite32 $baseAddress $pattern
    for {set testOffset 32} {[expr $testOffset & $addressMask] != 0} {set testOffset [expr $testOffset << 1] } {
	set addr [expr $baseAddress + $testOffset]
	memwrite32 $addr $antipattern

	set data [memread32 $baseAddress]
	if {$data != $pattern} {
	    echo "FAILED DATA_ADDR_BUS_SLOW: Address: [convertToHex $addr], Pattern: [convertToHex $pattern], Returned: [convertToHex $data]"
	    return $pattern
	}

	for {set offset 32} {[expr $offset & $addressMask] != 0} {set offset [expr $offset << 1]} {
	    set addr [expr $baseAddress + $offset]
	    set data [memread32 $baseAddress]

            if {(($data != $pattern) && ($offset != $testOffset))} {
		echo "FAILED DATA_ADDR_BUS_SLOW2: Address: [convertToHex $addr], Pattern: [convertToHex $pattern], Returned: [convertToHex $data], offset: [convertToHex $offset], testOffset [convertToHex $testOffset]"
		return $pattern
	    }
        }
	set addr [expr $baseAddress + $testOffset]
	memwrite32 $addr $pattern
    }
}

#***********************************************************************************
# *
# * Function:    memTestDevice()
# *
# * Description: Test the integrity of a physical memory device by
# *              performing an increment/decrement test over the
# *              entire region.  In the process every storage bit
# *              in the device is tested as zero and as one.  The
# *              base address and the size of the region are
# *              selected by the caller.
# *		 Ported from:
# *		 http://www.netrino.com/Embedded-Systems/How-To/Memory-Test-Suite-C
# * Notes:
# *
# * Returns:     Empty string if the test succeeds.
# *              A non-zero result is the first address at which an
# *              incorrect value was read back.  By examining the
# *              contents of memory, it may be possible to gather
# *              additional information about the problem.
# *
#***********************************************************************************
proc memTestDevice { baseAddress nBytes } {
    echo "Running memTestDevice"

    echo "memTestDevice: Filling memory with a known pattern..."
    for {set pattern 1; set offset 0} {$offset < $nBytes} {incr pattern; incr offset 32} {
	memwrite32 [expr $baseAddress + $offset] $pattern
    }

    echo "memTestDevice: Checking each location and inverting it for the second pass..."
    for {set pattern 1; set offset 0} {$offset < $nBytes} {incr pattern; incr offset 32} {
	set addr [expr $baseAddress + $offset]
	set data [memread32 $addr]

	if {$data != $pattern} {
	    echo "FAILED memTestDevice_pattern: Address: [convertToHex $addr], Pattern: [convertToHex $pattern], Returned: [convertToHex $data], offset: [convertToHex $offset]"
	    return $pattern
	}

	set antiPattern [expr ~$pattern]
	memwrite32 [expr $baseAddress + $offset] $antiPattern
    }

    echo "memTestDevice: Checking each location for the inverted pattern and zeroing it..."
    for {set pattern 1; set offset 0} {$offset < $nBytes} {incr pattern; incr offset 32} {
	set antiPattern [expr ~$pattern & ((1<<32) - 1)]
	set addr [expr $baseAddress + $offset]
	set data [memread32 $addr]
	set dataHex [convertToHex $data]
	set antiPatternHex [convertToHex $antiPattern]
	if {[expr $dataHex != $antiPatternHex]} {
	    echo "FAILED memTestDevice_antipattern: Address: [convertToHex $addr], antiPattern: $antiPatternHex, Returned: $dataHex, offset: $offset"
	    return $pattern
	}
    }
}

proc convertToHex { value } {
    format 0x%08x $value
}
